[toc]

本章主要介绍常见的资源类型，以及PE中资源的组织方式。PE中的相关资源可以通过程序进行深度定位，所获取的二进制字节码与资源脚本语句之间是一一对应的。本章将对这两者的关系进行深入的解析，还会通过直接读资源数据和使用Windows API函数两种方法对资源表进行编程。

在程序设计中，总会涉及一些数据。这些数据可能是源代码内部需要用到的常量，比如菜单选项、界面描述等；也可能是源代码外部的，比如程序的图标文件、背景音乐文件、配置文件等，以上这些数据统称为资源。

按照程序与数据分离的设计思想，最理想的方案是单独为程序所需要的数据安排一个节来存储——PE中的资源就是这么做的。

> 一级目录分类
>
> 二级目录id
>
> 三级目录字符串
>
> 最后文件

# 7.1　资源分类

资源数据在PE里是最复杂的一种。其难度主要体现在对资源数据的遍历定位上，以及资源块的不易阅读性。因为即使通过信息定位方法找到了资源块，其内部结构还需要进一步解析。首先来看资源分类的历史。

当初次将资源概念应用到PE时，人们普遍认为16个类型就足以包含所有的资源数据了；所以，==这16个类型的资源在追加进PE时，并不是赤裸裸地进入，而是全部附加了一些数据结构（尽管这些结构很简单），这些数据结构实现了对不同类别资源块的描述与组织。操作每一个资源块之前，都需要明确该资源在PE中追加的资源头部数据结构==，这便成为用户使用这些资源的主要障碍。

表7-1列出了预定义的16种资源。

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.74wn47jgb7w0.webp)

随着计算机技术的发展，新的技术不断涌现，新的资源类型也被定义。微软首先开始在这16个基本类型后追加新的类型，如多媒体、XML、超文本、MANIFEST、VXD等。随着这些新的信息越来越多，慢慢地，微软意识到，维护这样的信息难度很大，于是就放弃了对这些新信息的扩展；同时，对新加入的资源类别的数据组织方式也不再进行明示。这为程序设计者在操作资源数据时设置了障碍。

现在看来，应该是资源类型的最初定义出现了问题，至少让人感觉不是那么优雅。好在PE中针对资源的数据结构定义是良好的，例如，IMAGE_RESOURCE_DIRECTORY_ENTRY结构中的第一个字段用来表示资源类别。

定义数据结构的工程师在这里用了一个很巧妙的规定，使得资源类型可以被用户随意定义。数据结构规定，该字段高位如果为1，说明对应的资源类别是一个非标准的新类型，用户可以通过扩展这个字段定义一个新的不在预定义里的资源类型。

虽然在16种基础资源类别里也为开发者留了一个扩展，即RT_RCDATA（表7-1中第10项），鉴于新资源类别定义的不公开特性，许多第三方软件不得不扩展该类别，将所有新定义的类型全部设置为RT_RCDATA（在有的书中称此资源类别为二进制）。

> 注意　笔者认为，最优的资源类别设计可以只用这一种，因为所有类别的数据都可以做成文件，只要把赤裸裸的二进制文件复制到PE空间即可；这样存储方便，使用方便，数据的处理更加方便。

历史总是惊人地相似，早期对于资源类别的错误观点，也曾经发生在内存、时间和网络上。早在MS-DOS时代，IBM的专家就预言，“个人计算机只需要640KB的内存就足够了”。可事实是，目前，基于Intel CPU的个人电脑硬是将连续的内存从1MB处分隔开，并美其名曰实模式和保护模式。回顾2000年的千年虫问题，就知道在时间处理上也出现过类似的事情。网络方面，IPv4限制了一个IP地址的位数为32位，从而导致人们不得不重新设计IP，以适应诸物皆互联的理念。

程序中常用的六类资源包括：

- 位图资源
- 光标资源
- 图标资源
- 菜单资源
- 对话框资源
- 自定义资源

下面分别来讨论这几种资源类型。

## 7.1.1　位图、光标、图标资源

位图、光标和图标是标识程序用途、修饰程序的最简约的符号，一般对应ico、cur、ani和bmp文件内容。因为三种资源最终都是基于图片文件的，因此放在一节中讨论。在对资源脚本文件进行定义时，通常使用文件名，最后由资源编译器rc.exe将像素数据读入，再转换为二进制格式存储在PE的资源表指向的位置。位图、光标、图标这三类资源在脚本文件中的定义格式如下：

- 位图定义：nameID BITMAP [DISCARDABLE]位图文件名
- 光标定义：nameID CURSOR [DISCARDABLE]光标文件名
- 图标定义：nameID ICON [DISCARDABLE]图标文件名

1. nameID表示该资源的名字，在程序中使用资源时需要用到它，类似于文件的句柄。
2. BITMAP、CURSOR、ICON表示资源的类型。
3. DISCARDABLE关键字是可选项，表示在不用的时候可以从内存中暂时卸载掉。

> 注意　当文件名包含空格时，需要使用英文半角状态下的双引号引起来。

脚本定义语句举例如下：

------

```assembly
TITLE_ICON icon"abc.ico"
1000 icon discardable 123.ico
```

------

以上定义都是合法有效的。看一个实例：

------

ICO_MAIN ICON "D:\masm32\source\chapter7\main.ico"

------

以上脚本定义了程序的图标main.ico。

> 注意　上面的例子告诉我们，对应的外部文件可以使用绝对路径。

## 7.1.2　菜单资源

菜单是大部分应用程序都具备的资源。在资源脚本文件中，菜单的定义格式如下所示：

------

```assembly
菜单 ID MENU [DISCARDABLE]
BEGIN
菜单项定义
......
END
```

------

其中，菜单ID可以是16位的整数，其赋值范围在1～65535之间。菜单项的定义可以有三种，分别表示：

- 普通菜单项
- 菜单分隔符
- 弹出菜单

其语法结构分别如下所示：

------

```assembly
MENUITEM 菜单文字，命令 ID [,选项列表]
MENUITEM SEPARATOR
POPUP 菜单文字 [,选项列表]
BEGIN
菜单项定义
.......
END
```

------

以下是一个菜单实例，来自chapter7\pe.rc。

------

```assembly
#include <resource.h>

#define ICO_MAIN  1000
#define DLG_MAIN  1000
#define IDC_INFO  1001
#define IDM_MAIN  2000
#define IDM_OPEN  2001
#define IDM_EXIT  2002

#define IDM_1    4000
#define IDM_2    4001
#define IDM_3    4002
#define IDM_4    4003


ICO_MAIN  ICON  "d:\masm32\source\chapter7\main.ico"

DLG_MAIN DIALOG 50,50,544,399
STYLE DS_MODALFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
CAPTION "PE文件基本信息 by qixiaorui"
MENU IDM_MAIN
FONT 9,"宋体"
BEGIN
   CONTROL "",IDC_INFO,"RichEdit20A",196 | ES_WANTRETURN | WS_CHILD | ES_READONLY
               | WS_VISIBLE |WS_BORDER | WS_VSCROLL | WS_TABSTOP,0,0,540,396
END

IDM_MAIN menu discardable
BEGIN
  POPUP "文件(&F)"
  BEGIN
    menuitem "打开文件(&O)...",IDM_OPEN
    menuitem separator
    menuitem "退出(&x)",IDM_EXIT
  END

  POPUP "查看"
  BEGIN
    menuitem "源文件",IDM_1
    menuitem "窗口透明度",IDM_2
    menuitem separator
    menuitem "大小",IDM_3
    menuitem "宽度",IDM_4
  END

END
 
```

------

如以上代码所示，IDM_MAIN为菜单句柄，该菜单包含两个弹出式菜单“文件”和“查看”。其中“文件”弹出菜单包含“打开”、分隔符和“退出”3个菜单选项；“查看”弹出菜单包含“源文件”、“窗口透明度”、分隔符、“大小”和“宽度”5个菜单选项。

想了解与菜单项定义有关的更多资料，请阅读《Windows环境下32位汇编语言程序设计》（ISBN 978-7-121-08663-2）。

## 7.1.3　对话框资源

对话框也是大部分程序具备的一种资源。弹出式对话框人性化地排列着文本框、说明文字和按钮等可视化控件，使复杂的计算机操作变得容易。

在资源脚本的定义中，对话框最为复杂，其语法如下：

------

```assembly
对话框 ID DIALOG [DISCARDABLE]x坐标，y坐标，宽度，高度[options]
BEGIN
子窗口控件1
子窗口控件2
......
END
```

------

对话框的可选属性及描述见表7-2。

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.2do8zx6s1m.webp)

以下是一个对话框实例，代码如下：

------

```assembly
DLG_MAIN DIALOG 50,50,544,399
STYLE DS_MODALFRAME|WS_POPUP|WS_VISIBLE|WS_CAPTION|WS_SYSMENU
CAPTION"PE文件基本信息by qixiaorui"
MENU IDM_MAIN
FONT 9,"宋体"
BEGIN
CONTROL"",IDC_INFO,"RichEdit20A",196|ES_WANTRETURN|WS_CHILD|ES_READONLY|WS_VISIBLE|WS_BORDER|WS_VSCROLL|WS_TABSTOP,0,0,540,396
END
```

------

以上定义为对话框指定了标题文字、在屏幕上的坐标、使用的字体、对话框的样式；此外，还为对话框指定了一个菜单IDM_MAIN，并在对话框上安排了一个富文本控件。该对话框显示界面如图2-1所示。

## 7.1.4　自定义资源

通常，当开发者需要在PE文件中附带自定义数据时，可以使用自定义资源。其在资源文件中的定义语法如下：

------

```assembly
资源ID 类型ID [DISCARDABLE]
BEGIN
数据定义
......
END
```

------

大部分情况下，都是将一个磁盘文件当做资源的内容。此时的语法简化为：

------

```assembly
资源ID 类型ID [DISCARDABLE]文件名
```

------

类型ID可以是大于255的数值或字符串，如可以定义如下自定义资源：

------

```assembly
1001 MP3"gaoshan.mp3"
2000 FLASH"GAOXIAO.FLV"
DIB_WINRESULT DLLTYPE"winResult.dll"
```

------

> 注意　MP3、FLASH并不在常用的资源类别里。这里的资源类别的名字可以自行定义。

# 7.2　PE资源表组织

本节主要介绍了PE文件中资源数据的组织方式，并通过一个实例介绍针对资源数据定义的数据结构以及在PE中定位资源表的方法。

## 7.2.1　资源表的组织方式

PE的资源组织方式类似于操作系统的文件管理方式。从根目录开始，下设一级子目录、二级子目录和三级子目录；三级子目录下才是文件。其三级目录结构如图7-1所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.21d477ekipnk.webp)

图　7-1　三级目录结构

一级子目录按照资源类型分类，如“光标”一级子目录、“位图”一级子目录、“菜单”一级子目录、“字符串”一级子目录、“加速键”一级子目录等多个资源类型。

二级子目录按照资源的ID分类。例如，同样是“菜单”一级子目录的内容，其下可以有：IDM_OPEN的ID号为2001、IDM_EXIT的ID号为2002、IDM_1的ID号为4000等多个菜单项。

三级子目录是按照资源的代码页分类，即不同的语言代码页对应不同的数据。其中，根据语言可以分为简体中文、英文、繁体中文等多个代码页。

三级目录后即为节点，也就是所说的“文件”。这里的“文件”其实就是包含了资源数据的指针和大小等信息的一个数据结构而已。对所有资源数据块的访问均可从这里开始。

扩展阅读　资源目录结构单元

由于一、二、三级目录的数据结构是相同的，均是由一个资源目录头加上多个线性跟随着的资源目录项组成，笔者将主干和枝干的节点称为资源目录结构单元，如图7-2所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.48ov96181r80.webp)

图　7-2　资源目录结构单元

从数据结构角度来看，资源表是一个四层的二叉排序树结构。其中，第一层为主干，第二、三层为枝干，叶子节点为第四层。主干和枝干的节点即为资源目录结构单元，完整示意见图7-3。

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.6prn6gkjnns0.webp)

图　7-3　资源表的二叉树结构

资源表的结构虽然比较复杂，但并不难理解。下面来分析一下资源表在PE文件中的详细定义。首先来看资源表数据的定位。

## 7.2.2　资源表数据定位

资源表是一张描述资源数据在PE中的分布情况的表。==资源表是数据目录中注册的数据类型之一，其描述信息位于数据目录的第3个目录项中==。使用PEDump小工具获取chapter7\PE.exe的数据目录表内容如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.6zaaqzvadaw0.webp)

黑体部分即为资源表数据目录信息。

通过以上字节码可获得与资源表数据有关的两条信息：

==资源表数据所在地址RVA=0x000004000==

==资源表数据大小=000006A0h==

以下是使用PEInfo小工具获取到的该文件所有的节信息：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.6q1hne88is40.webp)

根据RVA与FOA的换算关系，可以得到资源表数据所在文件的偏移地址为0x00000A00。

## 7.2.3　资源目录头IMAGE_RESOURCE_DIRECTORY

==资源表数据从第一级资源目录开始==。==资源的每一级目录都会有一个资源目录头，它标识了该类资源的属性、创建日期和版本等信息，其中也包含了随后的目录项的数量描述信息==。详细结构定义如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.210pkfe94cxs.webp)

下面是结构IMAGE_RESOURCE_DIRECTORY中各字段的详细解释：

#### 73.IMAGE_RESOURCE_DIRECTORY.Characteristics

+0000h，双字。==资源属性==，保留为将来使用，必须为0。

#### 74.IMAGE_RESOURCE_DIRECTORY.TimeDateStamp

+0004h，双字。==时间戳==，即创建该资源的时间。

#### 75.IMAGE_RESOURCE_DIRECTORY.MajorVersion\IMAGE_RESOURCE_DIRECTORY.MinorVersion

+0008h，双字。资源的版本号。未用，大部分情况下为0。

#### 76.IMAGE_RESOURCE_DIRECTORY.NumberOfNamedEntries

+000ch，双字。==以名称命名的资源个数==。

#### 77.IMAGE_RESOURCE_DIRECTORY.NumberOfIdEntries

+000eh，双字。==以ID命名的资源个数==。



以上字段中，最重要的是76和77两个字段。在资源脚本文件中，定义资源时，既可以使用字符串作为名称来标识一个资源，也可以通过ID号来标识资源。资源目录项的数量等于两者之和。

## 7.2.4　资源目录项IMAGE_RESOURCE_DIRECTORY_ENTRY

紧跟在资源目录后的数据结构，就是在资源目录中声明的资源目录项。一个资源目录可能有多个资源目录项（以名称定义的资源目录项或以ID定义的资源目录项，或者两者组合），目录项和目录项之间是线性排列的。首先按照字母升序（不分大小写）排列名称资源目录项，然后再按ID升序排列ID资源目录项。图7-4是资源目录及目录项之间的关系示意图。

> ==资源目录表过后就是具体的资源，名称资源目录项排在前，ID资源目录项排在名称资源目录项后面==

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.5nnjq6bufsw0.webp)

图　7-4　资源目录及目录项之间的关系

资源目录项数据结构的详细定义如下：

------

```assembly
IMAGE_RESOURCE_DIRECTORY_ENTRY STRUCT
	union ;0000h-目录项的名字、字符串指针或ID号
		rName RECORD NameIsString:1,NameOffset:31
		Name1 	dd ?
		Id 		dd ?
	ends
	union ;0004h-目录项指针
		OffsetToData dd ?
		rDirectory RECORD DataIsDirectory:1,OffsetToDirectory:31
	ends
IMAGE_RESOURCE_DIRECTORY_ENTRY ENDS
```

------

因为结构中使用了union类型，所以这个结构稍微难懂一些。每个union字段在不同的使用场合会具有不同的数据解释和不同的数据值。下面分别介绍各字段的含义：

#### 78.IMAGE_RESOURCE_DIRECTORY_ENTRY.Name1

+0000h，==双字。第一个union字段，它定义了目录项的名称或者ID==。

==该双字的高位（即31位）如果为1，则表示低地址部分为一个指向Unicode字符串的指针==（注意，这里的字符串不是Ansi字符串，所以另有规定）；==如果为0，则表示该字段为一个编号==。

==资源中对字符串的定义全部采用Unicode编码，该指针并不直接指向一个以“\0”结尾的字符串所在地址，而是指向了结构`IMAGE_RESOURCE_DIR_STRING_U`==。该结构完善了指针的定义（即不仅包含指针，还包含指针指向的块长度，大家可以自己想想为什么这里需要长度字段），其详细定义如下：

------

```assembly
IMAGE_RESOURCE_DIR_STRING_U STRUCT
	Length1 	dw ? ;0000h-字符串长度
	NameString 	dw ? ;0002h-Unicode字符串，长度不确定
IMAGE_RESOURCE_DIR_STRING_U ENDS
```

------

#### 79.IMAGE_RESOURCE_DIRECTORY_ENTRY.OffsetToData

+0004h，==双字。这个字段是一个指针，当它的高位（第31位）为0时，指针指向的是描述资源数据块的指针，通常出现在第三级目录中==；==当高位为1时，低位数据指向下一级目录块的起始地址==。有关这两个字段更详细的解释参见7.2.6小节。

> 提示　字段78和79中的地址并不是基于文件起始地址的，它的偏移是基于资源表的起始位置。一定要清楚这一点，否则在定位资源数据时会出现错误！

## 7.2.5　资源数据项IMAGE_RESOURCE_DATA_ENTRY

资源数据项其实就是前面所说的“目录-文件”结构中的“文件”。它是通过三次目录定位后找到的一个数据结构，图7-5显示了资源数据项与三级目录和最终的资源数据块之间的关系。

如图7-5所示，==第三级目录项中的字段`IMAGE_RESOURCE_DIRECTORY_ENTRY.OffsetToData`指向了资源数据项，而资源数据项中的`OffsetToData`字段则指向了资源数据块==。

资源数据项的详细结构定义如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.6mcuxlp02hw0.webp)

图　7-5　资源数据块定位中的资源数据项

#### 80.IMAGE_RESOURCE_DATA_ENTRY.OffsetToData

+0000h，双字。==该字段是一个指向资源数据块的指针，是一个RVA值，在文件中访问时需要注意转换成文件偏移==。此处指向的资源数据块还不是赤裸裸的资源信息，而是附加了一些数据结构的资源块。后面7.4节还会对常用的资源块进行进一步的解析。

#### 81.IMAGE_RESOURCE_DATA_ENTRY.Size1

+0004h，双字。==资源数据的大小==。

#### 82.IMAGE_RESOURCE_DATA_ENTRY.CodePage

+0008h，双字。代码页，未用，大多数情况下为0。

#### 83.IMAGE_RESOURCE_DATA_ENTRY.Reserved

+000ch，双字。保留字段。总是为0。

==对资源表的大部分编程，只要能解析出该结构中指定资源块所处的地址和资源块的大小，资源表的使命也就算完成了==。

## 7.2.6　三级结构中目录项的区别

由于目录处的级别不同，目录中各字段所表述的内容也不一样；尽管它们具有相同的数据结构和完全相同的字段，在不同级别的目录项中有些字段的含义是不一样的。本小节就专门研究三级目录中目录项各字段不一样的地方。

### 1.==IMAGE_RESOURCE_DATA_ENTRY.Name1==

#### （1）==字段最高位（即31位）为1==

==当结构用于第一层目录时，表示这是一个非标准的类型==。由该字段的低31位组成一个偏移值，该偏移是相对于资源基地址的特殊偏移地址。该地址指向一个IMAGE_RESOURCE_DIR_STRING_U结构表示的Unicode字符串。字符串为非标准的类型的名字。类似于本章第1节自定义资源中的"DLLTYPE"。

==当结构用于第二层目录时，表示这是一个非标准的命名==。由该字段的低31位组成一个偏移值，该偏移是相对于资源基地址的特殊偏移地址。该地址指向一个IMAGE_RESOURCE_DIR_STRING_U结构表示的Unicode字符串。字符串为非标准的类型下的命名，类似于本章第1节自定义资源中的"DIB_WINRESULT"。

==当结构用于第三层目录时，表示这是一个非标准的语言（没有预定义的代码页）==。由该字段的低31位组成一个偏移值，该偏移是相对于资源基地址的特殊偏移地址。该地址指向一个IMAGE_RESOURCE_DIR_STRING_U结构表示的Unicode字符串。字符串为非标准的语言的名字。

#### （2）==字段第31位为0==

==当结构用于第一层目录时，表示这是标准的类型（预定义的类型）==。由该字段的低16位组成整数标识符ID，由于该类型已定义，所以可以通过该标识符获取预先定义的名字。例如该值为03h，则名字表示预定义当中的"ICON"。

==当结构用于第二层目录时，表示这是标准的命名（预定义的类型）==。由该字段的低16位组成整数标识符ID来定义名字。

==当结构用于第三层目录时，表示这是标准的语言代码（预定义的类型）==。由该字段的低16位组成整数标识符ID，可以通过该标识符获取预先定义的语言的名称。如ID=2052，表示该语言为Simpled _Chinese（简体中文）。大多数情况下，每个资源的代码页只定义一种。

### 2.==IMAGE_RESOURCE_DATA_ENTRY.OffsetToData==

#### （1）==字段第31位为1==

==当结构用于第一层目录时，由该字段低31位组成一个整数偏移地址==。==该地址是相对于资源起始地址的偏移，该偏移指向下一个目录。==

==当结构用于第二层目录时，由该字段低31位组成一个整数偏移地址==。==该地址是相对于资源起始地址的偏移，该偏移指向下一个目录。==

==第三层目录的该值第31位不为1==。

#### （2）==字段第31位为0==

==第一层目录的该值第31位不为0==。

==第二层目录的该值第31位不为0==。

==当结构用于第三层目录时，表示该字段指向一个数据项IMAGE_RESOURCE_DATA_ENTRY==。

> 注意　由低31位组成的地址是基于资源起始地址的。

# 7.3　资源表遍历

有的读者会问：PE中是否存在资源表？资源表的具体位置在哪里？

这些信息可以从数据目录表中获得。==在PE文件头IMAGE_OPTIONAL_HEADER32的数据目录中，第3个IMAGE_DATA_DIRECTORY结构描述的就是资源表==。==以下是PE中资源表所在位置和大小的获取方法==：

- ==资源表位置：IMAGE_DATA_DIRECTORY[8*2].VirtualAddress==
- ==资源表大小：IMAGE_DATA_DIRECTORY[8*2].isize==

通过程序定位到资源表，将资源表内容按照人性化方式显示出来。和前面其他数据的遍历一样，需要在PEInfo.asm的_openFile中加入以下遍历代码：

------

```assembly
;显示资源表信息
invoke _getResource,@lpMemory,esi,@dwFileSize
```

------

代码清单7-1是函数_getResource的代码。

代码清单7-1　获取PE文件的资源信息的函数_getResource（chapter7\peinfo.asm）

------

```assembly
;--------------------
; 获取PE文件的资源信息
;--------------------
_getResource proc  _lpFile,_lpPeHead,_dwSize
  local @szBuffer[1024]:byte
  pushad
  ;通过PE头定位资源表所在RVA
  mov esi,_lpPeHead
  assume esi:ptr IMAGE_NT_HEADERS
  mov eax,[esi].OptionalHeader.DataDirectory[8*2].VirtualAddress
  .if !eax
     invoke _appendInfo,addr szNoResource
     jmp _ret
  .endif
  push eax
  ;求资源表在文件的偏移
  invoke _RVAToOffset,_lpFile,eax
  add eax,_lpFile
  mov esi,eax
  pop eax
  invoke _getRVASectionName,_lpFile,eax
  invoke wsprintf,addr @szBuffer,addr szOut4,eax
  invoke _appendInfo,addr @szBuffer

  ;传入的四个参数分别表示
  ;1、文件头位置
  ;2、资源表位置
  ;3、目录位置
  ;4、目录级别
  invoke _processRes,_lpFile,esi,esi,1
_ret:
  assume esi:nothing
  popad
  ret
_getResource endp
```

------

如代码所示，首先通过查询数据目录表获取资源表的RVA，然后调用\_RVAToOffset获取资源表在文件的偏移，并显示资源表所处的节名。所有这些操作完成后，将指针定位到资源表起始，使用递归函数\_processRes开始遍历资源表。代码清单7-2是该函数的源代码。

代码清单7-2　用递归函数_processRes遍历资源表项（chapter7\peinfo.asm）

------

```assembly
;-------------------------
;递归函数，遍历资源表项
;_lpFile：文件地址
;_lpRes：资源表地址
;_lpResDir：目录地址
;_dwLevel：目录级别
;-------------------------
_processRes  proc _lpFile,_lpRes,_lpResDir,_dwLevel
  local @dwNextLevel,@szBuffer[1024]:byte
  local @szResName[256]:byte
  
  pushad
  mov eax,_dwLevel
  inc eax
  mov @dwNextLevel,eax  ;为下一次递归准备第四个参数
  
  mov esi,_lpResDir     ;指向目录表

  ;计算目录项的个数
  assume esi:ptr IMAGE_RESOURCE_DIRECTORY
  mov cx,[esi].NumberOfNamedEntries
  add cx,[esi].NumberOfIdEntries
  movzx ecx,cx
 
  ;跳过目录头定位到目录项
  add esi,sizeof IMAGE_RESOURCE_DIRECTORY
  assume esi:ptr IMAGE_RESOURCE_DIRECTORY_ENTRY
  .while ecx>0
    push ecx
    ;查看IMAGE_RESOURCE_DIRECTORY_ENTRY.OffsetToData
    mov ebx,[esi].OffsetToData
    .if ebx & 80000000h ;如果最高位为1
      and ebx,7FFFFFFFh ;求其他目录项
      add ebx,_lpRes    ;偏移是基于资源表起始地址的
                        ;为下一次递归准备第三个参数
             
      .if _dwLevel==1   ;如果是第一级资源类别
          
        mov eax,[esi].Name1  
        .if eax & 80000000h   ;如果是按名称定义的资源类型
                
           ;该部分结束后，eax指向了名称字符串
              
           and eax,7FFFFFFFh
           add eax,_lpRes
           movzx ecx,word ptr [eax] ;ecx=名字长度
           ;跳过2个字节的IMAGE_RESOURCE_DIR_STRING_U.Length1
           add eax,2    
           mov edx,eax              ;edx=名字地址
           ;将UNICODE字符转换为多字节字符
           invoke WideCharToMultiByte,CP_ACP,\
                       WC_COMPOSITECHECK,edx,ecx,\
                       addr @szResName,sizeof @szResName,\
                       NULL,NULL
           lea eax,@szResName
        .else                 ;如果是按编号定义的资源类型
            
           ;该分支结束后，eax指向了资源编号
           
           .if eax<=10h  ;系统内定的资源编号
             ;定位编号所在字符串eax=(n-1)*sizeof szType
             dec eax  
             mov ecx,sizeof szType
             mul ecx
             add eax,offset szType            
           .else
             invoke wsprintf,addr @szBuffer,\
                    addr szOut5,eax
             jmp _goHere
           .endif
        .endif
        invoke wsprintf,addr @szBuffer,addr szLevel1,eax
_goHere:
      .elseif _dwLevel==2    ;如果是第二级资源ID
                
        mov edx,[esi].Name1  
        .if edx & 80000000h   ;如果是按字符串定义的资源ID
                         
           and edx,7FFFFFFFh
           add edx,_lpRes
           movzx ecx,word ptr [edx] ;ecx=名字长度
           ;跳过2个字节的IMAGE_RESOURCE_DIR_STRING_U.Length1
           add edx,2    
           ;将UNICODE字符转换为多字节字符
           invoke WideCharToMultiByte,CP_ACP,\
                       WC_COMPOSITECHECK,edx,ecx,\
                       addr @szResName,sizeof @szResName,\
                       NULL,NULL
           invoke wsprintf,addr @szBuffer,addr szLevel2,\
                                           addr @szResName
        .else                 ;如果是按编号定义的资源类型
                
           invoke wsprintf,addr @szBuffer,\
                    addr szOut6,edx
        .endif
       .else
           .break  ;跳出递归
       .endif
       invoke _appendInfo,addr @szBuffer
       invoke _processRes,_lpFile,_lpRes,ebx,@dwNextLevel
         
         
     ;如果IMAGE_RESOURCE_DIRECTORY_ENTRY.OffsetToData最高位为0
      
    .else   ;第三级目录 
       add ebx,_lpRes
       mov ecx,[esi].Name1 ;代码页
       assume ebx:ptr IMAGE_RESOURCE_DATA_ENTRY
       mov eax,[ebx].OffsetToData
       invoke _RVAToOffset,_lpFile,eax
       invoke wsprintf,addr @szBuffer,addr szLevel3,\
               ecx,eax,[ebx].Size1
       invoke _appendInfo,addr @szBuffer
    .endif
    add esi,sizeof IMAGE_RESOURCE_DIRECTORY_ENTRY
    pop ecx
    dec ecx
  .endw
  assume esi:nothing
  assume ebx:nothing
  popad
  ret
_processRes endp
```

------

该函数是一个递归程序。函数内部包含一个循环，用于处理不同目录级别下资源目录结构单元。循环的结束条件是该目录级别下所有的目录项均已处理完毕。目录项的个数由21～23行代码计算得出。

37～72行是对第一级资源目录结构单元的处理。主要是根据IMAGE_RESOURCE_DIRECTORY_ENTRY.Name1的最高位为0还是为1，来确定是显示名称还是显示编号。

74～104行是对第二级资源目录结构单元的处理。方法和第一级资源目录结构单元的处理方法一样。

105～114行是对第三级资源目录结构单元的处理。该级的处理直接涉及资源块的最终地址和大小。该部分处理完毕，整个递归也结束。

编译链接生成新的PEInfo.exe程序，使用它打开记事本程序并进行分析。以下内容显示了记事本程序的资源表数据的部分内容。

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.4iigacby9vy0.webp)

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.votjjrwinds.webp)

# 7.4　PE资源深度解析

==PE中的资源表结构只帮助我们查找指定资源（可以通过指定名称或指定编号）的资源数据块所在文件的位置和大小。而对于某个特定的资源，比如对话框或菜单，其详细的数据块格式需要在本小节中完成==。本节以PE.exe为例，对PE.exe中的资源数据块进行深度解析。首先来看一下PE.exe的资源脚本定义，该定义在第2章中出现过。

## 7.4.1　资源脚本

==PE.exe的资源定义在文件pe.rc中，文件中一共定义了三种资源：图标、菜单和对话框==。详细定义如下。

------

```assembly
#include <resource.h>

#define ICO_MAIN  1000
#define DLG_MAIN  1000
#define IDC_INFO  1001
#define IDM_MAIN  2000
#define IDM_OPEN  2001
#define IDM_EXIT  2002

#define IDM_1    4000
#define IDM_2    4001
#define IDM_3    4002
#define IDM_4    4003


ICO_MAIN  ICON  "d:\masm32\source\chapter7\main.ico"

DLG_MAIN DIALOG 50,50,544,399
STYLE DS_MODALFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
CAPTION "PE文件基本信息 by qixiaorui"
MENU IDM_MAIN
FONT 9,"宋体"
BEGIN
   CONTROL "",IDC_INFO,"RichEdit20A",196 | ES_WANTRETURN | WS_CHILD | ES_READONLY
               | WS_VISIBLE |WS_BORDER | WS_VSCROLL | WS_TABSTOP,0,0,540,396
END

IDM_MAIN menu discardable
BEGIN
  POPUP "文件(&F)"
  BEGIN
    menuitem "打开文件(&O)...",IDM_OPEN
    menuitem separator
    menuitem "退出(&x)",IDM_EXIT
  END

  POPUP "查看"
  BEGIN
    menuitem "源文件",IDM_1
    menuitem "窗口透明度",IDM_2
    menuitem separator
    menuitem "大小",IDM_3
    menuitem "宽度",IDM_4
  END

END
```

------

资源脚本文件中涉及程序图标、对话框、菜单的定义。这三个是在接下来的内容中要重点讨论的。首先通过PEInfo简单地分析一下PE.exe中的资源表，然后针对资源脚本文件中存在的三种类型的资源进行深度解析。

## 7.4.2　使用PEInfo分析资源表

使用PEInfo查看PE.exe中的资源表，内容如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.416aeocno2u0.webp)

在深度解析资源字节码之前，首先明确几个概念。

### 1.资源表中的Unicode字符

==资源文件中的所有字符串都以Unicode格式存储，每个字符都由一个16位（单字）值表示，字符串以UNICODE_NULL（该值是两个“\0”字节）结束==。资源编译器调用Windows API中的MultiByteToWideChar函数将ASCⅡ字符串转换为Unicode字符串，所有溢出的字符都被当做合法的Unicode字符直接存储。当这些字符串被程序以ASCⅡ字符读出（例如使用LoadString API）时，系统将它们再由Unicode转换为ASCⅡ字符。

仅有的例外是在RCDATA语句中的字符串。这些“伪”字符串并不是真正的字符串，只被当做一些字节的集合。用户可能会用RCDATA语句存储一些自定义的数据结构，如果一个“伪”字符串被自动转换为Unicode字符串存储起来，这个“伪”字符串就会按照Unicode字符串的格式被存储，从而导致这个“伪”字符串字节码内容的改动。假设这个“伪”字符串是一个PE文件的字节码，再次被释放以后，这个PE文件就可能无法运行了。因此，这些“伪”字符串必须以它的本来面目存储下来，即字节码。若想在RCDATA语句中包含Unicode字符串，用户可以使用带"L"前缀的字符串。

### 2.资源字节码对齐

==为使二进制资源文件更容易读写，在Win32下，文件中的所有对象都是双字对齐的,包括头信息和数据项==。这并不会改变资源数据结构中每个字段的顺序，但会在这些字段中间增加一些填充域；通常情况下，这些填充域的值均为0。

资源中的大部分类型都遵循该规则，但有两个除外，一个是字体（font），另一个是字体目录（fontdir）。因为这两个结构直接复制自别的文件，它们并不被资源编译器所使用。

### 3.一个字段的多重定义

==在接下来的数据结构中，大家会看到类似于“[名称或序数]”这样的字段描述。[名称或序数]字段的第一个单字，标志这个字段到底是一个数字还是一个字符串==。如果它等于0xffff（一个非法的Unicode字符），那么在它后面的单字信息就是一个类型序号（一个数字）；否则，这个字段就是一个Unicode字符串。

如果类型域是一个数字，那它就代表一个标准的或者用户自定义的资源类型。所有标准的Windows资源类型都被赋予一个特定的值（如下所示），它包含了绝大多数资源类型的类型序数。

------

```assembly
/*预定义的资源类型*/
#define RT_NEWRESOURCE 0x2000
#define RT_ERROR 0x7fff
#define RT_CURSOR 1
#define RT_BITMAP 2
#define RT_ICON 3
#define RT_MENU 4
#define RT_DIALOG 5
#define RT_STRING 6
#define RT_FONTDIR 7
#define RT_FONT 8
#define RT_ACCELERATORS 9
#define RT_RCDATA 10
#define RT_MESSAGETABLE 11
#define RT_GROUP_CURSOR 12
#define RT_GROUP_ICON 14
#define RT_VERSION 16
#define RT_NEWBITMAP(RT_BITMAP|RT_NEWRESOURCE)
#define RT_NEWMENU(RT_MENU|RT_NEWRESOURCE)
#define RT_NEWDIALOG(RT_DIALOG|RT_NEWRESOURCE)
```

------

初步了解了资源字节码的相关规定后，下面开始我们的解析之旅。

## 7.4.3　菜单资源解析

以下内容以PE.exe为例，首先来看对菜单资源的解析。

### 1.菜单资源定位

从PEInfo中查看到菜单资源的位置和大小分别是：

文件位置：0x00001018

菜单项大小：134字节

### 2.菜单资源数据提取

使用PEDump将该位置的数据提取出来，字节码显示如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230918/image.692puls4kbk0.webp)

以上字节码对应以下定义：

------

```assembly
POPUP"文件(＆F)"
BEGIN
	menuitem "打开文件(＆O)...",IDM_OPEN
	menuitem separator
	menuitem "退出(＆x)",IDM_EXIT
END
```

------

继续看下面的字节码：

![image](https://github.com/YangLuchao/img_host/raw/master/20230918/image.5fox3d3pip80.webp)

以上字节码对应以下定义：

------

```assembly
POPUP "查看"
BEGIN
	menuitem "源文件",IDM_1
	menuitem "窗口透明度",IDM_2
	menuitem separator
	menuitem "大小",IDM_3
	menuitem "宽度",IDM_4
END
```

------

### 3.菜单资源数据结构

菜单资源由一个菜单头加一个菜单项的序列组成。菜单项有两种：弹出式（POPUP）菜单项和普通菜单项。

菜单头结构定义如下：

------

```assembly
MenuHeader STRUCT
	wVersion 		dw ? ;版本号。暂时取值为0
	cbHeaderSize 	dw ? ;头大小。暂时取值为0
MenuHeader ENDS
```

------

菜单头后面紧跟着菜单项，不同的菜单项具有不同数据结构的定义。

一般菜单项数据结构完整定义如下：

------

```assembly
NormalMenuItem STRUCT
	fItemFlags 	dw ? ;菜单项标志
	wMenuID 	dw ? ;菜单ID
	szItemText 	dd ? ;Unicode格式字符串，不确定长度
NormalMenuItem ENDS
```

------

其中，菜单分隔符MENUITEM SEPARATE也是普通菜单项，不过，其名称为空，ID为0，标志也为0。

fItemFlags是描述菜单项的标志集合。如果POPUP位被设置，则此项为弹出式的菜单项，否则就是一个普通的菜单项。常见标志及对应的值见表7-3。

![image](https://github.com/YangLuchao/img_host/raw/master/20230918/image.3rfycm4allo0.webp)

弹出式菜单项数据结构定义如下：

------

```assembly
PopupMenuItem STRUCT
	fItemFlags dw ? ;菜单标志
	szItemText dd ? ;Unicode字符，大小不确定
PopupMenuItem ENDS
```

------

### 4.字节码解析

------

```cpp
＞＞ 00 00 00 00
```

------

菜单头数据结构。两个字段的值均为0x00。

------

```cpp
＞＞10 00
＞＞87 65 F6 4E 28 00 26 00 46 00 29 00 00 00
```

------

PopupMenuItem.fItemFlags=0x0010，表示接下来的是一个弹出式菜单项。第二行为Unicode字符串，以一个字的0结尾，内容是“文件(＆F)”。

------

```cpp
＞＞00 00 D1 07
＞＞53 62 00 5F 87 65 F6 4E 28 00 26 00 4F 00 29 00 2E 00 2E 00 2E 00 00 00
```

------

普通菜单项。标志为0x0000，编号为0x07d1，十进制为2001。第二行为Unicode字符串，以一个字的0结尾，内容是“打开文件(＆O)...”。

------

```cpp
＞＞00 00 00 00 00 00
```

------

这是一个菜单分隔符，即"menuitem separate"。

------

```cpp
＞＞80 00 D2 07
＞＞00 90 FA 51 28 00 26 00 78 00 29 00 00 00
```

------

普通菜单项，标志0x0080说明这个菜单项是弹出菜单的最后一个。0x07D2是菜单的ID。第二行的Unicode字符，内容是

“退出(＆x)”。

第二部分的菜单资源字节码留给大家自己分析。

## 7.4.4　图标资源解析

图标有一套标准的大小和属性格式，且通常是小尺寸的。以ICO文件为例，一个ICO文件就是一套相似的图片，每一张图片具有不同的尺寸和颜色数，目的是适应不同的计算机操作系统和显示设备。

操作系统在显示一个图标时，会按照一定的标准选择图标中最适合当前显示环境和状态的图像。如果使用Windows 98操作系统，其显示环境是800×600分辨率，32位色深，你在桌面上看到的每个图标的图像格式就是256色、32×32像素大小。如果在相同的显示环境下，这些图标在Windows XP操作系统中的图像格式就是：真彩色（32位色深）、32×32像素大小。

扩展阅读　Windows各个操作系统中的标准图标格式（单位：大小像素——颜色）

> Windows 98 SE/ME/2000
>
> 48×48-256 32×32-256 16×16-256
>
> 48×48-16 32×32-16 16×16-16
>
> Windows XP
>
> 48×48-32bit 32×32-32bit 24×24-32bit*16×16-32bit
>
> (32位真彩色支持多通道透明。)
>
> 48×48-256 32×32-256 24×24-256*16×16-256
>
> 48×48-16 32×32-16 24×24-16*16×16-16
>
> 注意，*这种格式在Windows XP图标中并不是必需的。在Vista系统下最大可以支持256×256；同时，非标准的ICO文件也支持不规则尺寸的存储。

要想保证良好的显示效果，必须确保你所设计的图标中至少含有以上所列的图像格式。如果操作系统在图标中找不到特定的图像格式，它总是采用最接近的图像格式来显示，比如把大小为48×48的图标缩小为24×24像素大小，当然，效果就差些了。如果我们开发的软件同时支持Windows XP和Windows 2000，那么为了达到视觉上的最佳效果，每一个ICO文件应至少包含两个图标，一个是32位色的，一个是256色的。

### 1.ICO文件结构

每个ICO文件的开始都有一个头部信息。该头部信息描述了ICO文件中存在多少个图标，以及每个图标的基本信息，头部信息的结构如下：

------

```assembly
ICON_DIR STRUCT
	idreserved 	dw ? ;保留字，必须为0
	idtype 		dw ? ;资源类别，如果是1表示为ICO文件
	idcount 	dw ? ;图标数量
	icondirentry ICON_DIR_ENTRY [idcount]＜?＞ ;图标项，一个图标一项
ICON_DIR ENDS
```

------

idcount表示该ICO文件包含图标的数量。理论上，一个ICO文件最多可以包含65535个图标。接下来，是该文件所包含的每一个图标的详细描述。

------

```assembly
ICON_DIR_ENTRY STRUCT
	bWidth db ? ;宽度
	bHeight db ? ;高度
	bColorCount db ? ;颜色数
	bReserved db ? ;保留字，必须为0
	wPlanes dw ? ;调色板
	wBitCount dw ? ;每个像素的位数
	dwBytesInRes dd ? ;资源长度
	dwImageOffset dd ? ;资源在文件偏移
ICON_DIR_ENTRY ENDS
```

------

ICON_DIR_ENTRY结构记录了每一个图标的尺寸、色深、图标资源占用的字节数。dwImageOffset是一个文件偏移地址，指向图标资源数据起始位置。PE文件中的图标保存格式与".ico"文件中图标的保存格式略有不同。PE文件中，把ICON_DIR和图标资源作为两种资源类型分别保存，前者是RT_GROUP_ICON类型，后者是RT_ICON类型。

在".ico"文件中，ICON_DIR_ENTRY结构最后一个成员dwImageOffset表示图标资源文件偏移地址，是一个双字；而在PE文件中，GRP_ICON_DIR_ENTRY结构最后一个成员nID是一个字，表示图标的索引ID。图7-6是ICO文件大致结构图。

![image](https://github.com/YangLuchao/img_host/raw/master/20230918/image.76x0h333evg0.webp)

图　7-6　ICO文件结构

如图7-6所示，ICO文件分为三部分：图标头、图标项和图标数据。这三部分在PE文件中会被重新组合，其中，图标头会被重新组合为资源类型RT_GROUP_ICON，图标项和图标数据则被组合为资源类型RT_ICON。三部分间关系如图所示，图标头的idcount字段定义ICO里图标的个数；每个图标的属性由图标项定义；图标项的字段dwImageOffset则指向了ICO文件中该图标数据的位置。

### 2.图标资源定位

从PEInfo中查到PE.exe程序的图标资源的位置和大小分别是：

文件位置：0x00000b60

图标资源大小：744字节

### 3.图标资源数据提取

使用PEDump将该位置的数据提取出来，字节码显示如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230918/image.hnwat41qrog.webp)

以上所列字节码是从PE.exe文件中提取的图标数据的一部分。这部分数据的资源类型被定义为RT_ICON，对应图7-6中的图标数据。

注意　这些字节码并不包含图7-6中的图标头和图标项两部分。如前所述，以上数据只是main.ico的一部分。

### 4.main.ico数据

为了将PE中的图标资源数据与原始的main.ico文件内容进行比对，以下获取了main.ico文件的部分字节码：

![image](https://github.com/YangLuchao/img_host/raw/master/20230918/image.6548nvjtppo0.webp)

黑体部分即为资源表中的图标数据。可以看出，PE中的图标数据是直接从图标文件中复数过来的，未做任何修改。

### 5.字节码解析

main.ico文件开头的38字节为ICO头（图7-6中图标头和图标项两部分），其内容如下。

![image](https://github.com/YangLuchao/img_host/raw/master/20230918/image.397e9h05fue0.webp)

#### （1）图标头

![image](https://github.com/YangLuchao/img_host/raw/master/20230918/image.3wpsjfug0xw0.webp)

#### （2）第一个图标项定义

![image](https://github.com/YangLuchao/img_host/raw/master/20230918/image.1fui0ghlu62o.webp)

#### （3）第二个图标项定义

![image](https://github.com/YangLuchao/img_host/raw/master/20230918/image.3racavqfvcy0.webp)

有了以上信息，开发者就可以通过PE资源表中的资源数据块提取所有的图标为自己所用了。

## 7.4.5　图标组资源解析

为什么"pe.rc"脚本文件里只定义了三种资源，在PEInfo中却显示四种资源（多了一个图标组）？为什么我们只用了一个图标main.ico文件，在PEInfo中却显示有两个图标资源？通过对ICO文件的了解相信大家能够找到答案。

PE里的图标组资源RT_GROUP_ICON的数据来源于ICO文件的头部，但与ICO文件头部内容并不完全一致。它记录了某个图标具有相似性的一系列图片数据的基本信息，这些基本信息包括：相似图片数量及每个图片的宽、高、颜色数、在图标资源（RT_ICON）里的编号等。如果没有图标组资源，系统就无法识别在图标资源里哪些编号的图片数据是属于一个系列的（即相似图片）。

### 1.图标组资源定位

从PEInfo中可以定位到PE.exe文件中图标组的地址和大小，图标组其实就是ICO文件的文件头描述。只是其中一个字段的解释和值略有不同而已。

在文件中的偏移地址：0x00000F70

图标组资源大小：34字节

### 2.图标组资源数据提取

使用PEDump获取图标组资源的数据如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230918/image.372le6gzkt60.webp)

与ICO文件头比较发现，每一个图标项除了最后一个字段的值不一样外，其他基本就是上一节字节码解析部分解释过的图标头+图标项的数据。粗体部分数据为图标的ID标识。

以下是文件main.ico中对应的值。

![image](https://github.com/YangLuchao/img_host/raw/master/20230918/image.53n6o6gv7ss0.webp)

可以看到，在PE资源表中图标的ID标识值（一个字）到了文件中就变成了两个字，其含义也更改为对应图标数据的偏移地址。

## 7.4.6　对话框资源解析

### 1.对话框资源定位

根据PEInfo分析，获取PE.exe对话框资源所在文件位置和大小如下：

在文件偏移地址：0x00000f98

对话框资源大小：122字节

### 2.对话框资源提取

使用PEDump获取字节码，内容如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230919/image.5y8zwsu4ibk0.png)

### 3.对话框资源数据结构

对话框的头是一个DialogBoxHeader结构，其详细定义如下：

------

```assembly
DialogBoxHeader STRUCT
	lStyle dd ? ;标准窗口样式
	lExtendedStyle dd ? ;扩展窗口样式
	NumberofItems dw ? ;控件数量
	x dw ? ;起点坐标x
	y dw ? ;起点坐标y
	cx dw ? ;宽度
	cy dw ? ;高度
	[名称或序数] menuName ;菜单名或ID
	[名称或序数] ClassName ;类名或ID
	szCaption []dd ? ;对话框标题Unicode字符
	wPointSize dw ? ;字体大小（如果有）
	szFontName []dd ? ;字体名（如果有）
DialogBoxHeader ENDS
```

------

lStyle项是一个标准窗口样式，由windows.inc文件中的标志组成。对话框的默认样式为：

------

```assembly
WS_POPUP|WS_BORDER|WS_SYSMENU
```

------

lExtendedStyle项用来指定扩展窗口样式。当在DIALOG语句或其他可设置的语句中指定了扩展样式，那么它们的值就会被存储在这个双字字段中。菜单名和类名存储一个名称或一个序数ID；若第一个字为0xffff，则第二个字就是一个序数ID；如果第一个字为0x0000，则表示一个空字符串。

wPointSize和szFontName项仅当对话框中包含FONT语句时才会设置。可以通过检查lStyle项确定对话框是否包含字体设置。若lStyle＆DS_SETFONT(DS_SETFONT=0x40)为真，则这两项就会被设置。

> 注意　每个控件都由一个数据结构开始，每个控件的数据开始于一个双字，同样以双字对齐方式结束，所以两个控件中间可能会存在填充用的数据。
>

以下是每个控件开始的数据结构ControlData的定义：

------

```assembly
ControlData STRUCT
	lStyle dd ? ;标准窗口样式
	lExtendedStyle dd ? ;扩展窗口样式
	x dw ? ;左上角坐标x
	y dw ? ;左上角坐标y
	cx dw ? ;控件长度
	cy dw ? ;控件宽度
	wID dw ? ;控件ID
	[名称或序数]ClassID ;控件类型
	[名称或序数]Text ;控件类型名称
	nExtraStuff dw ? ;附加信息
ControlData ENDS
```

------

与前面一样，lStyle项是一个标准窗口样式，由windows.h文件中的标志组成。控件的类型由class指定。为节省空间、加速处理，许多通用Windows类型都以一个单字表示。由于Unicode中0x8000是一个合法字符，类型序数必须前置0xffff，和前面讲到的Type和Name域的序数表示方式相似。常用classID的值列表如下：

------

```assembly
#define BUTTON 0x8000
#define EDIT 0x8100
#define STATIC 0x8200
#define LISTBOX 0x8300
#define SCROLLBAR 0x8400
#define COMBOBOX 0x8500
```

------

lExtendedStyle双字用来指定此控件的扩展样式。扩展样式标志置于CONTROL语句的最后，跟在坐标后面。控件数据最后的附加信息当前并不使用，但将来可能会被用来存储菜单项信息，通常它的长度为0。对话框脚本中使用的绝大多数语句都被映射为这些类型（包括它们的样式），这些样式的值可以在windows.h中找到。所有对话框控件都有默认的WS_CHILD和WS_VISIBLE样式。表7-4为脚本语句使用的默认样式。

![image](https://github.com/YangLuchao/img_host/raw/master/20230919/image.1nxr8wxir468.jpg)

![image](https://github.com/YangLuchao/img_host/raw/master/20230919/image.5y8p9z0z82s0.jpg)

控件文本存储在上面介绍的“名称或序数”字段中。

### 4.字节码解析

第一部分：对话框定义。

控件二进制字节码分析如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230919/image.7fpo8r5yvqs0.jpg)

对话框标题栏文字为“PE文件基本信息by qixiaorui”，对应资源脚本文件定义中的语句：

![image](https://github.com/YangLuchao/img_host/raw/master/20230919/image.18itamd6ygao.jpg)

第二部分，控件定义。

![image](https://github.com/YangLuchao/img_host/raw/master/20230919/image.fgxg40i2enc.jpg)

类名。Unicode字符串。控件的名称"RichEdit20A"。对应资源脚本文件中的以下部分：

![image](https://github.com/YangLuchao/img_host/raw/master/20230919/image.3kndazoyple0.jpg)

### 5.PE2.exe对话框资源解析

因为PE.exe对话框资源中只存在一个控件，相对简单。大家可以自行分析一下PE2.exe中的对话框资源。在分析时请注意资源的双字对齐补足部分，以下是分析用到的相关资料：

PE2的资源脚本文件中有关对话框定义的部分如下：

------

```assembly
#include＜resource.h＞
#define ICO_MAIN 1000
#define DLG_MAIN 1000
#define IDC_INFO 1001
#define IDM_MAIN 2000
#define IDM_OPEN 2001
#define IDM_EXIT 2002
#define IDM_1 4000
#define IDM_2 4001
#define IDM_3 4002
#define IDM_4 4003
#define ID_TEXT 3000
#define ID_CONSOLE 3001
ICO_MAIN ICON"main.ico"
DLG_MAIN DIALOG 50,50,544,399
STYLE DS_MODALFRAME|WS_POPUP|WS_VISIBLE|WS_CAPTION|WS_SYSMENU
CAPTION"PE文件基本信息by qixiaorui"
MENU IDM_MAIN
FONT 9,"宋体"
BEGIN
	CONTROL"",IDC_INFO,"RichEdit20A",196|ES_WANTRETURN|WS_CHILD|ES_READONLY|WS_VISIBLE|WS_BORDER|WS_VSCROLL|WS_TABSTOP,0,0,540,396
	LTEXT"请选择要执行的文件:",-1,10,13,200,8
	EDITTEXT ID_TEXT,90,10,300,14
	CHECKBOX "控制台程序",ID_CONSOLE,10,30,100,14
END
......
```

------

字节码的分析如下图所示，这些字段由读者自己分析。这里不再详细描述，其中[]是Unicode字符串。方框框起来的是为了对齐而补足的0x00。

![image](https://github.com/YangLuchao/img_host/raw/master/20230919/image.u4p282z6tz4.jpg)

# 7.5　==资源表编程==

本节将利用前面学习的对资源字节码的深度解析知识来提取图标。在正式编写程序之前，先来看一个实验。

## 7.5.1　更改图标实验

在"PE.rc"文件的基础上，再加入一个ICO文件，生成另外一个PEDumpIcon.rc，其资源脚本代码如下：

------

```assembly
#include＜resource.h＞
#define ICO_MAIN 1000
#define DLG_MAIN 1000
#define IDC_INFO 1001
#define IDM_MAIN 2000
#define IDM_OPEN 2001
#define IDM_EXIT 2002
#define IDM_1 4000
#define IDM_2 4001
#define IDM_3 4002
#define IDM_4 4003
ICO_MAIN ICON "main.ico"
ICO_BOY ICON "boy.ico"
DLG_MAIN DIALOG 50,50,544,399
```

------

复制pe.asm到文件PEDumpIcon.asm，然后编译链接PEDumpIcon.asm文件，发现生成的程序图标发生了变化，由原来的main.ico变成了boy.ico。使用PEInfo查看资源信息如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230919/image.1pz0i9qvz9ds.jpg)

使用FlexHex打开PEDumpIcon.exe文件，只修改其中的一个字节。看看程序是否可以重新回到main.ico图标。在文件偏移位置0x002B02处，将原来的值03更改为01，然后回到文件夹，刷新一下，发现图标显示果然回到原来的main.ico。如图7-7所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230919/image.2p2b282g5ua0.jpg)

图　7-7　将原来的值03更改为01程序图标的变化

如上图所示，图7-7a是未修改前PEDumpIcon.exe在操作系统中显示的图标，图7-7b是修改字节以后该程序在操作系统中显示的图标。

如果你感觉程序修改图标就这么简单，那就大错特错了，做任何事情都要知其然知其所以然。解读一下PEInfo显示的资源信息，你会发现，01号图标的数据长度和03号图标的数据长度刚好相等。这就是为什么我们直接修改一个字节就可以成功的原因。

如果图标对应的数据长度和03号图标的数据长度不相等会怎样呢？

你可以自己尝试一下，将03的值修改为02，看看会出现什么情况。如图7-8所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230919/image.4dahg3k4qag0.jpg)

图　7-8　将03的值修改为02程序图标的变化

如图所示，图7-8a是boy.ico的图标文件，在图标资源中的编号为01；图7-8b是main.ico的图标文件，在图标资源中的编号为03；图7-8c显示的是图标资源中编号为02的图标数据。修改之后好像也没有什么问题，系统只是将16×16的小图标放大到32×32显示。

如果更改为一个不存在的值会怎样呢？

这和在窗口程序中不指定图标的效果，也就是说和PE资源表中不存在图标组的效果是一样的。将PEDumpIcon.exe文件0x002B02处的值更改为一个不存在的值（如05）的时候，操作系统会在显示时帮助你画出一个图标来当做该程序的图标，如图7-9所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230919/image.4a42i1949280.jpg)

图　7-9　将03的值修改为05程序图标的变化

如图所示，因为在PE资源中指定了一个不存在的图标，操作系统从PE的资源表中无法定位到该索引的图标，所以系统就帮你画了一个图标作为该程序的默认图标，如图7-9c所示。

掌握了更改程序图标的方法后，下面看一个提取程序图标的实例。

## 7.5.2　提取程序图标实例

回顾图7-6，==一个ICO文件由三大部分组成：第一部分是图标头，第二部分是图标项，第三部分为图标数据==。其中，对应到PE资源表中，第一部分和第二部分组合成图标组资源（某些值稍有变化，见7.4.5小节），第三部分的每个图标数据对应一个图标资源。

本实例程序假设图标是由多个图标数据组成，即资源表中一定存在图标组，以下程序实现的是提取图标组中包含的所有的图标。

### 1.从资源文件到ICO文件的数据组合

ICO头部分+ICO项描述在资源图标组里定义，每一部分数据则在资源图标里定义。程序首先检测是否存在图标组资源，如果不存在则退出；如果存在，就定位到图标组资源数据，通过将字段编号（1个字）修改为偏移（2个字），重新组合ICO头部使其符合ICO文件头部要求。最后，分别读取各部分图标资源数据，顺序连接到ICO头部后即可。

### 2.源码分析

完整源代码见随书文件chapter7\PEDumpIcon.asm，以下是对部分源代码的简单分析。程序复制自PE.asm，更新的代码从函数_openFile开始，代码如下：

------

```assembly
;显示资源表信息
invoke _getResource,@lpMemory,esi,@dwFileSize
```

------

函数_getResource完成了整个图标数据的提取工作，其实现如代码清单7-3所示。

代码清单7-3　获取PE文件的资源信息（chapter7\PEDumpIcon.asm）

------

这段代码执行以下操作：

1. 初始化打开文件对话框配置。
2. 弹出打开文件对话框，让用户选择要打开的文件。
3. 创建文件句柄，并获取文件大小。
4. 创建文件的内存映射。
5. 映射文件到内存，获取文件在内存中的映像起始位置。
6. 设置异常处理程序，用于处理文件格式验证错误。
7. 检测文件是否以"MZ"字样开头，如果不是则跳转到错误处理代码。
8. 调整指针指向PE文件头，并检查是否有"PE"字样。
9. 如果文件验证通过，显示文件名并获取并显示资源表信息。
10. 如果文件格式验证失败，显示错误消息框。
11. 最后，恢复异常处理程序和栈，关闭内存映射文件，关闭文件映射句柄，关闭文件句柄

```assembly
;--------------------
; 打开PE文件并处理
;--------------------
_openFile proc
  local @stOF:OPENFILENAME    ; 存储打开文件对话框的配置信息
  local @hFile, @dwFileSize, @hMapFile, @lpMemory  ; 文件句柄、文件大小、内存映射文件句柄、映射内存的指针

  ; 清空编辑框文本
  invoke SendMessage, hWinEdit, WM_SETTEXT, NULL, 0

  ; 初始化打开文件对话框配置
  invoke RtlZeroMemory, addr @stOF, sizeof @stOF
  mov @stOF.lStructSize, sizeof @stOF
  push hWinMain
  pop @stOF.hwndOwner
  mov @stOF.lpstrFilter, offset szExtPe  ; 文件过滤器
  mov @stOF.lpstrFile, offset szFileName  ; 存储选择的文件路径
  mov @stOF.nMaxFile, MAX_PATH
  mov @stOF.Flags, OFN_PATHMUSTEXIST or OFN_FILEMUSTEXIST

  ; 打开文件对话框，让用户选择要打开的文件
  invoke GetOpenFileName, addr @stOF
  .if !eax
    jmp @F
  .endif

  ; 创建文件句柄
  invoke CreateFile, addr szFileName, GENERIC_READ, \
         FILE_SHARE_READ or FILE_SHARE_WRITE, NULL, \
         OPEN_EXISTING, FILE_ATTRIBUTE_ARCHIVE, NULL
  .if eax != INVALID_HANDLE_VALUE
    mov @hFile, eax

    ; 获取文件大小
    invoke GetFileSize, eax, NULL
    mov @dwFileSize, eax

    .if eax
      ; 创建文件的内存映射
      invoke CreateFileMapping, @hFile, \  ; 内存映射文件
             NULL, PAGE_READONLY, 0, 0, NULL
      .if eax
        mov @hMapFile, eax

        ; 映射文件到内存
        invoke MapViewOfFile, eax, \
               FILE_MAP_READ, 0, 0, 0
        .if eax
          ; 获取文件在内存中的映像起始位置
          mov @lpMemory, eax
          assume fs:nothing

          ; 设置异常处理程序
          push ebp
          push offset _ErrFormat
          push offset _Handler
          push fs:[0]
          mov fs:[0], esp

          ; 检测PE文件是否有效
          mov esi, @lpMemory
          assume esi:ptr IMAGE_DOS_HEADER

          ; 检查文件是否以MZ字样开头
          .if [esi].e_magic != IMAGE_DOS_SIGNATURE
            jmp _ErrFormat
          .endif

          ; 调整ESI指针指向PE文件头
          add esi, [esi].e_lfanew
          assume esi:ptr IMAGE_NT_HEADERS

          ; 检查是否有PE字样
          .if [esi].Signature != IMAGE_NT_SIGNATURE
            jmp _ErrFormat
          .endif

          ; 到此为止，文件已经通过验证，被确认为PE格式

          ; 显示文件名
          invoke wsprintf, addr szBuffer, addr szOut1, \
                          addr szFileName
          invoke _appendInfo, addr szBuffer

          ; 显示资源表信息
          invoke _getResource, @lpMemory, esi, @dwFileSize

          ; 跳转到错误处理代码
          jmp _ErrorExit
 
_ErrFormat:
          ; 显示错误消息框
          invoke MessageBox, hWinMain, offset szErrFormat, \
                                                 NULL, MB_OK
_ErrorExit:
          ; 恢复异常处理程序和栈
          pop fs:[0]
          add esp, 0ch

          ; 关闭内存映射
          invoke UnmapViewOfFile, @lpMemory
        .endif

        ; 关闭文件映射句柄
        invoke CloseHandle, @hMapFile
      .endif

      ; 关闭文件句柄
      invoke CloseHandle, @hFile
    .endif
  .endif
@@:        
  ret
_openFile endp

```

------

函数从根目录开始，根据从一级目录项的Name1字段获取的类别编号，判断是否存在图标组（值为14，即0eh）。如果存在，则继续遍历，直到找到该图标组的偏移地址和大小；不存在则退出，不做处理。92～99行是对找到的该图标组的信息进行处理的函数，函数名为\_getIcoData，针对每一个图标组，将生成一个单独的ICO磁盘文件。代码清单7-5是处理函数\_getIcoData的代码。

代码清单7-5　通过PE中对图标组资源的描述获取ICO数据（chapter7\PEDumpIcon.asm）

------

==这段汇编代码的功能是从PE文件的ICO头部分析和提取ICO图标数据，然后将这些数据写入一个新的ICO文件==。以下是对代码中不同部分的详细注释：

- ==该过程的目的是获取PE文件中的ICO图标数据，参数包括PE文件指针 `_lpFile`、资源表指针 `_lpRes`、图标编号 `_number`、ICO头偏移量 `_off` 和ICO头大小 `_size`。==
- ==首先，汇编代码构造新的ICO文件名，然后创建一个用于输出的磁盘文件。==
- ==定位到ICO图标目录并获取图标的数量。==
- ==然后，循环遍历每个ICO图标，将其信息写入文件，包括图标的宽度、高度、颜色深度等。==
- ==在循环中，根据每个图标的偏移量，从PE文件中读取图标数据。==
- ==最后，关闭文件句柄，完成ICO数据的提取和保存。==

此代码的主要功能是将PE文件中的ICO图标数据提取并保存到一个新的ICO文件中。这些注释应有助于理解代码的功能和执行过程。

```assembly
;-------------------------------
; 通过PE ICO头获取ICO数据
;
; 参数1：文件开始
; 参数2：资源表开始
; 参数3：PE ICO头开始
; 参数4：编号（由此构造磁盘文件名g12.ico）
; 参数5：PE ICO头大小
;-------------------------------
_getIcoData proc _lpFile, _lpRes, _number, _off, _size
  local @dwTemp, @dwCount, @dwTemp1
  local @lpMem, @dwForward 

  pushad

  ; 构造ICO文件名
  invoke wsprintf, addr szFileName1, addr szOut11, _number
  invoke wsprintf, addr szBuffer, addr szFile, addr szFileName1
  invoke _appendInfo, addr szBuffer

  ; 创建磁盘文件以供检查
  invoke CreateFile, addr szFileName1, GENERIC_WRITE, \
             FILE_SHARE_READ, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0
  mov hFile, eax

  ; 定位文件指针
  mov eax, _lpFile
  add eax, _off
  mov lpMemory, eax
  mov @lpMem, eax

  ; 写入ICO文件的前6个字节，即ICO文件头
  invoke WriteFile, hFile, lpMemory, 6, addr @dwTemp, NULL

  ; 计算图标组包含的图标个数
  mov esi, dword ptr [lpMemory]
  add esi, 4
  xor ecx, ecx
  mov cx, word ptr [esi]
  mov @dwCount, ecx
  invoke wsprintf, addr szBuffer, addr szOut13, _number, @dwCount
  invoke _appendInfo, addr szBuffer

  ; 计算第一个图标数据在文件中的偏移量
  xor edx, edx
  mov eax, @dwCount
  mov cx, 2  ; 每个图标记录多2个字节
  mul cx
  add eax, _size
  mov @dwForward, eax  ; 上一个图标的偏移量

  ; 定位到ICO图标项的起始位置
  mov esi, dword ptr [lpMemory]
  add esi, 6
  assume esi:ptr PE_ICON_DIR_ENTRY
  mov dwIcoDataSize, 0

  mov eax, @dwCount
  mov @dwTemp1, eax

  .while @dwTemp1 > 0
     push esi

     ; 从PE ICO头中读取大部分图标信息，除了最后一个字段
     mov al, [esi].bWidth
     mov lpIconDE.bWidth, al

     mov al, [esi].bHeight
     mov lpIconDE.bHeight, al

     mov al, [esi].bColorCount
     mov lpIconDE.bColorCount, al

     mov al, [esi].bReserved
     mov lpIconDE.bReserved, al

     mov ax, [esi].wPlanes
     mov lpIconDE.wPlanes, ax

     mov ax, [esi].wBitCount
     mov lpIconDE.wBitCount, ax

     mov eax, [esi].dwBytesInRes
     mov lpIconDE.dwBytesInRes, eax

     ; 计算图标数据在文件中的偏移量
     ; 对于第一个图标，这个值是文件ICO头的大小
     ; 对于以后的图标，这个值是上一个图标的偏移量加上数据长度
     mov eax, dwIcoDataSize
     add @dwForward, eax
     mov eax, @dwForward
     mov lpIconDE.dwImageOffset, eax

     ; 将图标信息写入文件
     invoke WriteFile, hFile, addr lpIconDE, \
              sizeof ICON_DIR_ENTRY, addr @dwTemp, NULL

     mov eax, [esi].dwBytesInRes ; 为下一次计算地址做准备
     mov dwIcoDataSize, eax

     pop esi
     add esi, sizeof PE_ICON_DIR_ENTRY    
     dec @dwTemp1
  .endw ; 图标信息写入循环结束，所有头部信息已完成。

  invoke _appendInfo, addr szICOHeader

  ; 开始写入每个图标的数据到文件
  mov esi, dword ptr [lpMemory]
  add esi, 6
  assume esi:ptr PE_ICON_DIR_ENTRY

  mov eax, @dwCount
  mov @dwTemp1, eax

  .while @dwTemp1 > 0
     push esi

     xor eax, eax
     mov ax, [esi].dwImageOffset  ; 获取图标的顺序号

     ; 从PE文件中读取图标数据
     ; 返回eax为图标数据的大小
     invoke _getFinnalData, _lpFile, _lpRes, eax

     pop esi
     add esi, sizeof PE_ICON_DIR_ENTRY    
     dec @dwTemp1
  .endw ; 所有图标数据写入循环结束，只等待偏移地址修正
  
  ; 关闭文件句柄
  invoke CloseHandle, hFile

  popad

  ret
_getIcoData endp

```

------

代码32～33行完成了6字节ICO头的文件写入操作。函数中用了两个循环，第一个循环是61～105行，它将资源目录表的ICO_DIR_ENTRY项写入到了ICO文件的头部；第二个循环是109～129行，该部分代码完成了将所有图标数据写入文件。函数\_getFinnalData完成的工作是将指定编号_num的图标数据取出并写入文件hFile中，代码如代码清单7-6所示。

代码清单7-6　将图标数据写入文件（chapter7\PEDumpIcon.asm）

------

==这段汇编代码的功能是将从PE文件中提取的ICO图标数据写入文件中==。以下是对代码中不同部分的详细注释：

- ==该过程接受三个参数：`_lpFile` 表示文件内存的起始地址，`_lpRes` 表示资源表的起始地址，`_number` 表示图标的顺序号。==
- ==在此过程中，首先初始化一些局部变量，并清零 `@ret`，`dwICO` 表示图标计数器。==
- ==代码开始遍历资源表，查找符合指定图标顺序号的图标。==
- ==先遍历第一级资源目录项，检查是否按名称定义的资源类型（最高位为1），如果是，则跳过；如果是按编号定义的资源类型，则进一步查找。==
- ==如果找到匹配的图标，继续查找第二级和第三级目录，最终找到图标数据。==
- ==根据图标数据的偏移和大小，将数据从PE文件中读取并写入新文件。==
- ==最后，返回 `@ret` 表示是否成功找到并写入了图标数据。==

此代码的主要功能是从PE文件中提取指定顺序号的ICO图标数据并写入文件。这些注释应有助于理解代码的功能和执行过程

```assembly
;-------------------------------
; 将图标数据写入文件
;
; 参数1：_lpFile 文件内存起始地址
; 参数2：_lpRes 资源表起始地址
; 参数3：_number 为图标顺号
;-------------------------------
_getFinnalData proc _lpFile, _lpRes, _number
  local @ret, @dwTemp
  local @szBuffer[1024]:byte
  local @szResName[256]:byte
  local @dwTemp1, @dwTemp2, @dwTemp3
  local @lpMem
  
  pushad
  mov @ret, 0

  mov dwICO, 0
  
  mov esi, _lpRes     ; 指向第一级目录表

  ; 计算目录项的个数
  assume esi:ptr IMAGE_RESOURCE_DIRECTORY
  mov cx, [esi].NumberOfNamedEntries
  add cx, [esi].NumberOfIdEntries
  movzx ecx, cx
 
  ; 跳过目录头定位到目录项
  add esi, sizeof IMAGE_RESOURCE_DIRECTORY
  assume esi:ptr IMAGE_RESOURCE_DIRECTORY_ENTRY
  .while ecx > 0

    ; 查看IMAGE_RESOURCE_DIRECTORY_ENTRY.OffsetToData
    mov ebx, [esi].OffsetToData
    .if ebx & 80000000h ; 如果最高位为1
        and ebx, 7fffffffh     ; 二级子目录
        add ebx, _lpRes
        mov eax, [esi].Name1 
        ; 如果是按名称定义的资源类型，跳过 
        .if eax & 80000000h   
            jmp _next         
        .else        ; 如果是按编号定义的资源类型

           ; 第一层，eax指向了资源类别
           .if eax == 03h  ; 判断编号是否为图标

             ; 移动到第二级目录
             ; 计算目录项的个数
             mov esi, ebx
             assume esi:ptr IMAGE_RESOURCE_DIRECTORY
             mov cx, [esi].NumberOfNamedEntries
             add cx, [esi].NumberOfIdEntries
             movzx ecx, cx
             mov dwICO, ecx

             mov ecx, dwICO

             ; 跳过第二级目录头定位到第二级目录项
             add esi, sizeof IMAGE_RESOURCE_DIRECTORY
             assume esi:ptr IMAGE_RESOURCE_DIRECTORY_ENTRY

             mov @dwTemp1, 0
             .while ecx > 0
               push ecx
               push esi
               
               ; 直接访问到数据，获取数据在文件的偏移及大小
               add @dwTemp1, 1

               ; 判断序号是否和指定的一致
               mov eax, _number
               .if @dwTemp1 != eax
                 jmp _loop
               .endif

               ; 如果一致，则继续查找数据
   
               mov ebx, [esi].OffsetToData
               .if ebx & 80000000h ; 最高位为1
                  and ebx, 7fffffffh
                  add ebx, _lpRes   ; 第三级

                  ; 移动到第三级目录，假设目录项数量都为1
                  mov esi, ebx
                  assume esi:ptr IMAGE_RESOURCE_DIRECTORY
                  add esi, sizeof IMAGE_RESOURCE_DIRECTORY
                  assume esi:ptr IMAGE_RESOURCE_DIRECTORY_ENTRY  

                  ; 地址指向数据项
                  mov ebx, [esi].OffsetToData
                  add ebx, _lpRes
                    
                  assume ebx:ptr IMAGE_RESOURCE_DATA_ENTRY
                  mov eax, [ebx].OffsetToData
                  mov edx, [ebx].Size1
                  mov @dwTemp3, edx
                  invoke _RVAToOffset, _lpFile, eax
                  mov @dwTemp2, eax

                  invoke wsprintf, addr szBuffer, addr szLevel31,\
                              @dwTemp1, @dwTemp2, @dwTemp3
                  invoke _appendInfo, addr szBuffer 

                  mov eax, _lpFile
                  add eax, @dwTemp2
                  mov @lpMem, eax
                    
                  ; 将@dwTemp2开始的@dwTemp3个字节写入文件
                  invoke WriteFile, hFile, @lpMem, \
                          @dwTemp3, addr @dwTemp, NULL
                  invoke _appendInfo, addr szFinished 

                  pop esi
                  pop ecx
                  mov @ret, 1
                  jmp _ret 
               .endif

_loop:         pop esi
               pop ecx
               add esi, sizeof IMAGE_RESOURCE_DIRECTORY_ENTRY
               dec ecx
             .endw
             jmp _next        
           .else
             jmp _next
           .endif
           
        .endif
    .endif
_next:
    add esi, sizeof IMAGE_RESOURCE_DIRECTORY_ENTRY
    dec ecx
  .endw

  .if dwICO == 0
    invoke _appendInfo, addr szNoIconArray
  .endif
_ret:
  assume esi:nothing
  assume ebx:nothing
  popad
  mov eax, @ret
  ret
_getFinnalData endp

```

------

与定位图标组的方法一样，即判断第一级目录项中的Name1字段的值是什么，如果为4，则表示图标。顺着这条路径进行下去，直到从二叉树结构中找到该图标数据所在文件偏移和数据大小，然后将数据原样附加到ICO文件末尾。整个程序只取第一个代码页的数据，图标组如是，图标亦如是。

### 3.提取Internet Explorer程序的图标

编译链接PEDumpIcon.asm后运行程序。打开IExplorer.exe文件，运行结果如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230919/image.1cwngepdmwf4.jpg)

运行的界面如图7-10所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230919/image.49bpdz1jxz4.jpg)

图　7-10　PEDumpIcon运行界面

如图所示，程序首先显示待处理的PE文件中一共有多少个图标组。然后依次显示每个图标组的相关信息，这些信息包括：图标组的编号、所在文件的位置，以及图标组资源的长度。最后，将该图标组中所有的图标，按每个图标一个ICO文件的方式将资源表中的数据转储到文件中。

本节依据PE资源表中对图标文件的处理方式，完成了从资源数据到图标的反抓取。在编写本程序时，重点阅读如何在PE资源表中得到指定类别、指定名称（或编号）的资源的位置和资源的长度。

## 7.5.3　更改程序图标实例

本小节学习如何更改程序的图标。因为通过直接修改PE资源文件实现图标的修改，涉及许多还没有讲过的知识，本实例将使用现有的Windows API函数来完成这个任务。

Windows操作系统为开发者提供了几个API函数，用来更新PE文件中资源的函数有：BeginUpdateResource、UpdateResource、EndUpdateResource。用来枚举PE文件中资源的函数有：EnumResourceTypes、EnumResourceNames、EnumResourceLanguages。具体的使用方法可以参见MSDN，以下将使用这些函数实现图标资源的替换。

本实例的目标是将指定PE程序显示的图标更改为boy.ico图标。这里还是从函数_openFile开始，不再对PE文件进行格式检测，而是直接处理，代码如代码清单7-7所示。

代码清单7-7　选择PE文件并处理的函数_openFile（chapter7\PEUpdateIcon.asm）

```assembly
;--------------------
; 选择PE文件并处理
;--------------------
_openFile proc
  local @stOF:OPENFILENAME
  local @hFile,@dwFileSize,@hMapFile,@lpMemory

  invoke RtlZeroMemory,addr @stOF,sizeof @stOF
  mov @stOF.lStructSize,sizeof @stOF
  push hWinMain
  pop @stOF.hwndOwner
  mov @stOF.lpstrFilter,offset szExtPe
  mov @stOF.lpstrFile,offset szFileName
  mov @stOF.nMaxFile,MAX_PATH
  mov @stOF.Flags,OFN_PATHMUSTEXIST or OFN_FILEMUSTEXIST
  invoke GetOpenFileName,addr @stOF  ;让用户选择打开的文件
  .if !eax
    jmp @F
  .endif

  ;将boy.ico的图标数据写入PE文件

  invoke _doUpdate,addr lpszBoyIcon,addr szFileName
  .if eax
    invoke _appendInfo,addr szSuccess
  .else
    invoke _appendInfo,addr szFailure
  .endif
@@:        
  ret
_openFile endp
```

调用函数_doUpdate写入PE图标boy.ico。先修改第一个图标组，然后再更新编号为1的图标数据，如代码清单7-8所示。

代码清单7-8　用指定ICO文件替换PE程序的图标（chapter7\PEUpdateIcon.asm）

------

```assembly
;-----------------------------------
;将boy.ico图标替换指定PE程序的图标
;使用win32 api函数UpdateResource实现此功能
;-----------------------------------
_doUpdate proc _lpszFile, _lpszExeFile
     local @stID:ICON_DIR
     local @stIDE:ICON_DIR_ENTRY
     local @stGID:PE_ICON_DIR
     local @hFile:DWORD
     local @dwReserved:DWORD
     local @nSize:DWORD
     local @nGSize:DWORD
     local @pIcon:DWORD
     local @pGrpIcon:DWORD
     local @hUpdate:DWORD
     local @ret:DWORD

     invoke CreateFile,_lpszFile,GENERIC_READ,\
               NULL,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL
     mov @hFile,eax
     .if eax==INVALID_HANDLE_VALUE
          xor eax, eax
          ret
     .endif

     invoke RtlZeroMemory,addr @stID,sizeof @stID
     invoke ReadFile,@hFile,addr @stID,sizeof @stID,\
                                   addr @dwReserved,NULL
     invoke RtlZeroMemory,addr @stIDE,sizeof @stIDE
     invoke ReadFile,@hFile,addr @stIDE,sizeof @stIDE,\
                                    addr @dwReserved,NULL

     push @stIDE.dwBytesInRes
     pop @nSize
     invoke GlobalAlloc,GPTR,@nSize 
     mov @pIcon,eax
     invoke SetFilePointer,@hFile,@stIDE.dwImageOffset,\
                                              NULL,FILE_BEGIN
     invoke ReadFile,@hFile,@pIcon,@nSize,\
                                        addr @dwReserved, NULL

     .if eax==0
        jmp _ret
     .endif     

     invoke RtlZeroMemory,addr @stGID,sizeof @stGID
     push @stID.idCount
     pop @stGID.idCount
     mov @stGID.idReserved, 0
     mov @stGID.idType, 1
     invoke RtlMoveMemory,addr @stGID.idEntries,addr @stIDE,12
     mov @stGID.idEntries.nID,0
     mov @nGSize,sizeof @stGID
     invoke GlobalAlloc,GPTR,@nGSize
     mov @pGrpIcon, eax
     invoke RtlMoveMemory,@pGrpIcon,addr @stGID,@nGSize

     ;开始修改
     invoke BeginUpdateResource,_lpszExeFile,FALSE
     mov @hUpdate,eax
     nop
     invoke UpdateResource,@hUpdate,RT_GROUP_ICON,1,\
                                 LANG_CHINESE,@pGrpIcon,@nGSize
     invoke UpdateResource,@hUpdate,RT_ICON,1,
                                 LANG_CHINESE,@pIcon,@nSize
     mov @ret, eax
     invoke EndUpdateResource, @hUpdate, FALSE
     .if @ret == FALSE
        invoke MessageBox,NULL,addr szBuffer,NULL,MB_OK
        jmp _ret
     .endif

     mov eax, 1
     jmp _exit
_ret:
     invoke GlobalFree,@pIcon
     invoke CloseHandle,@hFile
     xor eax, eax
_exit:
     invoke CloseHandle,@hFile
     ret
_doUpdate endp
```

------

如以上代码所示，18～24行打开指定的ICO文件，26～31行读取ICO文件的图标头和图标项内容分别存储在变量@stID和@stIDE中。46～56行通过读取的ICO文件的图标头和图标项生成PE文件的图标组资源数据。在这里要特别注意，从ICO文件到PE资源图标组数据的变化，即每个图标项的双字偏移地址要更改为单字的编号。行58～71通过调用相应的API函数实现PE程序的图标的替换。

# 7.6　小结

本章着重介绍了PE中的资源表。==PE中的资源表实际是一个四层的排序二叉树的典型应用。通过对资源表数据结构的解析，我们可以获得某个资源在文件中的位置及该资源数据块的大小，进一步获取该资源块==。本章还针对常见的资源类型对资源块的字节码进行深度解析，让读者了解在资源脚本文件中，脚本与资源编译程序最终生成的资源数据块字节码之间存在一一对应的关系。
