[toc]

从本章开始，我们将深入地研究PE文件中除文件头部以外的其他数据组织，本章学习导入表。

==导入表是PE数据组织中的一个很重要的组成部分，它是为实现代码重用而设置的。通过分析导入表数据，可以获得诸如PE文件的指令中调用了多少外来的函数，以及这些外来函数都存在于哪些动态链接库里等信息==。Windows加载器在运行PE时会将导入表中声明的动态链接库一并加载到进程的地址空间，并修正指令代码中调用的函数地址。在数据目录中一共有四种类型的数据与导入表数据有关。这四种数据依次为：

- ==导入表==
- ==导入函数地址表==
- ==绑定导入表==
- ==延迟加载导入表==

本章涉及导入函数地址表和绑定导入表，延迟加载导入表将在第8章进行详细描述。

# 4.1　何谓导入表

为了使读者更快地理解导入表，我们以程序HelloWorld.asm源代码为例进行讲解。该程序的主要功能是在桌面上弹出一个窗口提示，但是在源文件中并没有关于如何画窗口、如何显示指定字符串这样功能的代码，只是简单地调用了Windows API函数。这些调用的函数的详细代码在HelloWorld.asm中并不存在。那么，它到底存储在哪里呢？答案是：这些代码存储在DLL文件，即动态链接库中。==在动态链接库里存放的不是函数的源代码，而是编译链接以后生成的字节码==。看下面的两个调用语句：

------

```assembly
invoke MessageBox,NULL,offset szText,NULL,MB_OK
invoke ExitProcess,NULL
```

------

MessageBox是一个从外界（相对于HelloWorld.asm本身而言）引入的函数，ExitProcess也是一个从外界引入的函数。Windows API函数有所了解的人都知道，前者的指令字节码在user32.dll动态链接库中，而后者则是在kernel32.dll中。

==当程序调用了动态链接库的相关函数，在进行编译和链接的时候，编译程序和链接程序就会将调用的相关信息写入最终生成的PE文件中，以告诉操作系统这些函数的执行指令字节码从哪里能够获取。这些信息就是导入表所要描述的内容==。首先来看导入函数。

# 4.2　导入函数

程序开发者在基于汇编语言的源程序中，通过invoke指令调用用户自定义的函数，或者从其他动态链接库中导入的函数。如果没有导入函数的调用机制，程序开发者必须面对自行开发大量基础源码的尴尬，这将直接导致开发工作无法进行下去。

## 4.2.1　invoke指令分解

==在汇编语言中，程序一旦被编译，编译器会对invoke指令进行适当分解。分解后的指令中将会包含指向导入函数的地址的操作数==。==当PE文件被装载到内存中时，该操作数就会变成导入函数所在虚拟地址空间真实的VA==。

使用OD打开HelloWorld.exe程序，查看汇编后的字节码以及相关调用如图4-1所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.49bbg397y400.webp)

图　4-1　汇编语言引入函数的调用

如上图所示，将源代码中对两个导入函数MessageBoxA和ExitProcess的调用语句翻译成字节码分别为：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.4emxfvu9oni0.webp)

第一个调用语句被编译器解释为从地址0x00401000到0x0040100B的反汇编代码。根据地址0x0040100B处的调用关系来看，该语句还包含0x00401018处的跳转指令。第二个调用语句被编译器解释为从地址0x00401010到0x00401012的反汇编代码。根据地址0x00401012处的调用关系来看，该语句还包含0x0040101E处的跳转指令。

回顾第1章，HelloWorld.exe文件偏移0x400处是代码段，其中存放程序指令。以上显示的是PE被装载后在内存中的代码段，装载前文件中的代码段字节码如下所示：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.4ofq46lukq20.webp)

可以看出，装载前文件中和装载后内存中的指令的字节码是完全一样的，这意味着，该程序在被装载以后加载的基址和IMAGE_OPTIONAL_HEADER32.ImageBase是相等的，不存在重定位问题（如果两者不相等，则指令中涉及全局操作数的部分就会有不同）。同时，从指令的反汇编代码中可以看出，在对源代码HelloWorld.asm进行编译时，编译器对invoke指令实施了分解。以第一个调用语句为例，对invoke指令的分解操作包含以下三步：

- **步骤1**　==压栈。即先将要调用的所有参数push到栈中。StdCall，压栈时按照先推后参数，再推前参数的规则，即第一个推入栈的应该是调用的最后一个参数MB_OK，最后一个推入栈的参数应该是调用中的第一个参数NULL，尽管两者的值看起来都是0。==

- **步骤2**　==段内调用。即通过指令call调用一个段内地址，即call 00401018==。

- **步骤3**　==无条件转移。call指令操作数0x00401018处的值是：FF25 08204000，将该字节码反汇编，得到一个无条件跳转指令，跳转到了位置00402008处==。


> 注意　从位置00402008处获取的值是导入函数MessageBoxA在内存中的VA。

## 4.2.2　导入函数地址

==导入函数是从动态链接库引入的函数，所以，导入函数的地址位于被加载的进程地址空间中的相应的动态链接库模块内==。系统在执行用户程序对导入函数的调用语句时，会跳转到该地址处执行导入函数代码。

使用OD打开HelloWorld.exe，选择地址0x0040101E所在行，在其上单击鼠标右键，选择“数据窗口中跟随”|“内存地址”。OD的③区就会显示内存从00402000开始的数据，如下所示：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.5u47v25didw0.webp)

如上所示，==加粗部分即为导入表数据（大小为3Ch字节）==。到目前为止，感觉两个jmp指令中的操作数0x00402008和0x00402000都不在该导入表（黑体部分）的范围内，API函数调用好像与导入表无关。其实不是这样的，jmp指令中的操作数虽然不在导入表范围内，但导入表的数据结构描述中有一个字段是指向这个操作数所在位置的。从跳转指令的操作数所指向的位置0x00402008获取的值为77D507Eah（图中方框里的值）。该值是MessageBoxA这个导入函数在进程HelloWorld.exe中的VA。

==现在来对比一下磁盘文件和内存映像的导入函数的地址数据，看看是否存在差别==。

以下是==从文件中获取的导入表相关数据==：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.4e5ehf4o7ds0.webp)

以下是从内存中获取的导入表相关数据：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.3isig88ni3i0.webp)

可以看到：==在同样功能的位置（文件0x0608处，内存0x00402008处），内存映像中的值为77D507EAh，而文件中此处的值为0000205Ch。这意味着，文件被装载到内存后，这里的值发生了变化，真正标识MessageBoxA函数地址的应该是内存中此处的值==。那么这两个值之间有什么联系呢？

==先来看文件中该位置的值，它是一个RVA。按照第3章中RVA地址与FOA的转换关系可以计算出该值在文件中的位置==。具体计算过程如下：

首先，通过小工具PEInfo获取HelloWord.exe中与节有关的信息，如下所示：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.2smpcsupel00.webp)

其次，通过三步计算法计算出RVA对应的FOA。

- ==步骤1　0000205Ch是落在节.rdata中，因为节.rdata的真实数据的范围是00002000h～00002092h，而提供的值恰好在这个范围内。==
- ==步骤2　计算偏移offset1 = 0000205ch - 00002000h = 005ch。==
- ==步骤3　计算在文件中的偏移RVA = 0600h + 005ch = 065ch。==

查看文件偏移0x065c处的值，发现是019Dh+字符串'MessageBoxA'，前者是一个编号（hint），后者是调用的函数名（name）。重新调整一下思路，在将PE文件装载进内存时，Windows加载器会根据以下指令中的地址查找到0x00401018处。

------

```assembly
Call 00401018
```

------

此处的指令是一个跳转指令，如下：

------

```assembly
JMP DWORD PTR DS:[00402008]
```

------

==加载器继续查找对应位置0x00402008得到值0000205ch，然后从文件的0x0000205c处获取函数的名字MessageBoxA和函数在动态链接库里的编号。加载器会根据函数的Hint/Name从内存地址空间中查找到函数的VA为77d507eah，并将找到的函数地址重新覆盖内存的0x00402008这个位置==。

==当程序真正被装载进内存以后，0x00402008这个位置就已经被替换成为函数的正确的虚拟内存地址了==。

## 4.2.3　导入函数宿主

==指令要运行，就必须将指令字节码调入到内存中。既然程序中调用了动态链接库的有关函数，那么程序进程地址空间中也一定会有这些函数的指令代码。也就是说，操作系统会在加载时根据导入表的描述将调用的函数指令字节码复制到进程地址空间中。==

事实上，==操作系统总是会将该函数所处的动态链接库全部复制到进程地址空间，这些动态链接库便是导入函数的指令宿主==。如果一个动态链接库在一个进程中被加载过，且在其他进程中也引用了该链接库的函数，操作系统不会再次加载这个动态链接库，而是通过页面调度机制使两个进程同时访问一个动态链接库。也就是说，==为了节约内存资源，操作系统只保证有一份代码存在于物理内存中，大家看到的在每个进程中加载的不同地址的相同动态链接库，其实只是在页面存取机制下的一个映射而已==。

在内存映像中，从跳转指令的操作数0x00402008处取出的值为0077d507EAh。该值看起来离HelloWorld的线程空间很远，通过OD查看0x0077d507EA这个地址处的数据，根据OD显示的种种蛛丝马迹，基本可以断定0x0077d507ea这个虚拟内存空间的地址附近装载的正是user32.dll链接库的MessageBoxA函数的源字节码。如下所示：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.3nsemidymvc0.webp)

上面的代码比较复杂，从反汇编代码里能猜出此处列出的代码应该属于user32.dll模块，但必须找到确凿的证据。图4-2是在菜单“查看”|“内存”界面中截取的画面。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.6ydlwomeths0.webp)

图　4-2　user32.dll被加载进内存后的地址空间分配

==从画面中可以看出虚拟地址空间的0x77D10000处为user32的PE文件头；而user32的代码段范围是0x77D11000～0x77D71000，所以说跳转指令的地址0x0077d507EA恰好落在user32.dll的代码段范围内==。

还可以从静态文件分析中证实这个结果，首先使用PEInfo查看文件user32.dll的信息，该链接库位于C:\windows\system32文件夹中，显示结果如下。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.31ntyvgfqka0.webp)

从结果中可以看出，user32.dll的默认加载地址为0x77d10000，代码段.text在文件中的偏移为0x400。

有了代码段在文件中的起始偏移，我们就可以使用PEDump来查看文件user32.dll的代码段的字节码，截取部分字节码如下所示：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.1g32egiewgtc.webp)

使用OD打开HelloWorld.exe，在命令文本框中输入"d 77d11000"后回车，显示如图4-3所示。

“HEX数据”列显示了从该地址开始的指令字节码。从文件和内存（见图4-3）中的进程显示的字节码来看，两者是一致的。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.7b60y02kff40.webp)

图　4-3　OD中user32代码段指令

> 注意　由于每个程序的虚拟地址空间是独立的，所以一般情况下，user32.dll的装载基地址是固定的，这个地址由字段IMAGE_OPTIONAL_HEADER32.ImageBase来决定。从PEInfo运行的结果来看，HelloWorld.exe被加载到内存以后，一起加载进内存的user32.dll所在进程地址空间的基地址并没有发生变化，还是IMAGE_OPTIONAL_HEADER32.ImageBase字段指定的0x77D11000这个值。

==现在做一个简单的总结：编译程序在编译汇编语言源文件时，会把程序中的invoke语句分解成三部分==：

- 将参数压栈部分
- call指令部分
- jmp指令部分

==call的操作数是jmp指令所在的地址==；==而jmp指令的操作数则是该导入函数在导入表的地址==。

==在程序中所有的导入函数地址被排列在一起，组成IAT，通过这样的分解操作配合导入表实现对外部函数的调用==。

以上总结可以用图4-4来描述。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.1jezun9ktlog.webp)

图　4-4　导入函数调用机制

# 4.3　PE中的导入表

本节将重点研究PE文件结构中的导入表。

## 4.3.1　导入表定位

==导入表是数据目录中注册的数据类型之一，其描述信息位于数据目录的第2个目录项中==。==IAT也是数据目录中注册的数据类型之一，其描述信息位于数据目录的第13个目录项中==。使用PEDump小工具获取chapter4\HelloWorld.exe的数据目录内容如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.3q1fx06zrqq0.webp)

加黑部分为数据目录表中的导入表项，加框部分为导入函数地址表项。通过以上字节码得到如下信息：

- ==导入表数据所在地址RVA=0x0000002010==
- ==导入表数据大小=0000003Ch==
- ==导入函数地址表数据所在地址RVA=0x0000002000==
- ==导入函数地址表数据大小=00000010h==

以下是使用小工具PEInfo获取的chapter4\HelloWorld.exe所有节的相关信息：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.7jiqgydxf640.webp)

根据RVA与FOA的换算关系，可以得到：

- ==IAT数据所在文件的偏移地址=0x00000600==
- ==导入表数据所在文件的偏移地址=0x00000610==

定位到HelloWorld.exe文件0x00000600位置处得到IAT和导入表数据如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.1oj0wiqfne9s.webp)

其中==下划线部分为导入表数据，共60个字节。方框部分为IAT数据，共16个字节==。

到目前为止，你只需要明确的是==IAT实际是导入表数据组织中的一个重要的组成部分==。下面首先从导入表数据入手，分析导入表的数据组织。

## 4.3.2　导入表描述符IMAGE_IMPORT_DESCRIPTOR

导入表数据的起始是一组导入表描述符结构。每组为20个字节，实例中60个字节的导入表数据被分成三个组。前两组均代表两个动态链接库，最后一组为全0结构，表示导入表描述已经结束。可以通过导入表起始地址和这个空结构计算出导入表中引用的动态链接库的个数。

其实，Windows在查找导入表的时候并不一定要求最后一组的20个字节都为0，只要其中的字段Name1是0就已经满足结束条件了。==导入表的每一组都是一个结构，称为导入表描述符IMAGE_IMPORT_DESCRIPTOR==，该结构的具体定义如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.2y4inzgj3d40.webp)

以下是对每个字段的具体解释。

#### 54.IMAGE_IMPORT_DESCRIPTOR.OriginalFirstThunk

+0000h，双字。因为==它是指向另外数据结构的通路，因此简称为桥1。该字段指向一个包含了一系列结构的数组==。

==指向的数组中的每个结构定义了一个导入函数的信息，最后以一个内容为全0的结构作为结束==。==指向的数组中每一项为一个结构，此结构名称是IMAGE_THUNK_DATA==。==该结构实际上只是一个双字，但在不同的时刻却拥有不同的解释==。该字段有两种解释：

- ==双字最高位为0，表示导入符号是一个数值，该数值是一个RVA。==
- ==双字最高位为1，表示导入符号是一个名称。==

#### 55.IMAGE_IMPORT_DESCRIPTOR.TimeDateStamp

+0004h，双字。时间戳，一般不用，多为0。如果该导入表项被绑定，那么绑定后的这个时间戳就被设置为对应DLL文件的时间戳。操作系统在加载时，可以通过这个时间戳来判断绑定的信息是否过时。

#### 56.IMAGE_IMPORT_DESCRIPTOR.ForwarderChain

+0008h，双字。==链表的前一个结构==。

#### 57.IMAGE_IMPORT_DESCRIPTOR.Name1

+000ch，双字。==这个字段的含义和名称并不一致，这里的Name1是一个RVA，它指向该结构所对应的DLL文件的名称，而这个名称是以“\0”结尾的Ansi字符串==。

#### 58.IMAGE_IMPORT_DESCRIPTOR.FirstThunk

+0010h，双字。==与OriginalFirstThunk相同，它指向的链表定义了针对Name1这个动态链接库引入的所有导入函数，简称桥2==。

## 4.3.3　导入表的双桥结构

==桥1和桥2最终通向了一个目的地，都指向了引入函数的“编号-名称”（Hint/Name）描述部分==。==而从桥2到目的地的过程中，还经过了另外一个很重要的结构IAT==。

图4-5为引入了ExitProcess等3个函数的kernel32.dll的导入表描述符结构示意图。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.6r78lr1djyc0.webp)

图　4-5　kernel32.dll的导入描述结构

以下是对HelloWorld.exe中的导入表数据的详细解释：

------

```assembly
＞＞54 20 00 00
```

------

==桥1，最高位为0，这是一个RVA，表明函数是以字符串类型的函数名导入的==。==先将RVA转换为FOA，值为0x00000654，从文件的该位置开始取双字，直到取出的双字为“0”结束==。==每一个双字都是结构IMAGE_THUNK_DATA==。该结构的详细定义如下：

------

```assembly
IMAGE_THUNK_DATA STRUCT
	union u1
		ForwarderString dd ?
		Function dd ?
		Ordinal dd ?
		AddressOfData dd ?
	ends
IMAGE_THUNK_DATA ENDS
```

------

连续取出的数分别为：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.7ewmjzdkjsg0.webp)

因为这个动态链接库只调用了一个函数，所以，数组里只有两个元素。如果调用的函数多了，数组中的元素也会增加。==这组数中每一个都是一个RVA，不过这个RVA却指向了另外一个结构IMAGE_IMPORT_BY_NAME。这个结构大小不确定，是桥1的最终目的地。结构的第一个为字，紧跟着的是函数的名字==。

从文件偏移0x0000065C开始的数据是（碰到“0”即结束）：

------

```assembly
9D 01 4D 65 73 73 61 67 65 42 6F 78 41 00
```

------

==这些值组成的数据结构就是IMAGE_IMPORT_BY_NAME==，详细描述如下：

------

```assembly
IMAGE_IMPORT_BY_NAME STRUCT
	Hint dw ? 	;0000h-函数编号
	Name1 db ? 	;0004h-表示函数名的字符串
IMAGE_IMPORT_BY_NAME ENDS
```

------

以下是对每个字段的具体解释。

#### 59.IMAGE_IMPORT_BY_NAME.Hint

+0000h，双字。==函数的编号，在DLL中对每个函数都进行了编号，访问函数时可以通过名称访问，也可以通过编号访问==。

#### 60.IMAGE_IMPORT_BY_NAME.Name1

+0004h，大小不确定。==函数名字字符串的具体内容，以“\0”作为字符串结束标志==。

其中019dh标识该函数在user32.dll中的编号，后面紧跟着函数名"MessageBoxA"。

------

```assembly
＞＞00 00 00 00
```

------

时间戳，这里为0。

------

```assembly
＞＞00 00 00 00
```

------

链表的前一个结构，这里为0。

------

```assembly
＞＞6A 20 00 00
```

------

RVA，指向动态链接库user32.dll的名字字符串。

------

```assembly
＞＞08 20 00 00
```

------

你会发现，在文件中==尽管通过桥2和桥1指向的数据值相同，但其存储的位置却是不同的。桥1指向的INT与桥2指向的IAT内容完全一样，但INT和IAT却存储在文件的不同位置==。

==每一个结构IMAGE_IMPORT_DESCRIPTOR都对应一个唯一的动态链接库文件，以及引用了该动态链接库的多个函数，每个函数的最终“值-名称”描述均可以沿着桥1或者桥2找到，这种导入表结构被称为双桥结构==。

==双桥结构的导入表在文件中存在两份内容完全相同的地址列表==。一般情况下，==桥2指向的地址列表被定义为IAT，而桥1指向的地址列表则被定义为INT（Import Name Table）==。有的链接程序只为导入表存储一个桥，如Borland公司的Tlink只保留桥2，这样的导入表我们称之为单桥结构的导入表。

> 注意　单桥结构的导入表是无法执行绑定导入操作的。

使用同样的方法大家可以自行分析第二个IMAGE_IMPORT_DESCRIPTOR项。该项目描述的是与动态链接库kernel32.dll有关的导入信息。

## 4.3.4　导入函数地址表

==PE文件中所有导入函数jmp指令操作数的集合，组成了另外一个数据结构，这个结构就是导入函数地址表（Import Address Table，IAT）。该地址表是数据目录的第13个数据目录项==。

==导入函数地址表是一个双字的数组，每个双字代表的是一个导入函数的VA，该地址称为导入函数地址（Import Address，IA）。用户程序通过无条件跳转指令跳转到VA指定处，便可以运行引入函数的指令。由于IAT中定义了不止一个链接库的函数，为了区分这些从不同链接库引入的函数，规定所有引入函数按照链接库分类；相同链接库的函数地址排列在一起，最后以一个双字的0结束==。IAT结构可以用图4-6表示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.2xbgz86uzsk0.webp)

图　4-6　IAT结构

前面讲过，导入表和IAT是有紧密联系的，通过桥2即可定位到IAT。==在内存中，桥1可以让你找到调用的函数名称或函数的索引编号，桥2却可以帮助你找到该函数指令代码在内存空间的地址==。导入表与IAT的关系如图4-7所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.14d5ceaey140.webp)

图　4-7　文件中的导入表与IAT

==当PE被加载进虚拟地址空间以后，IAT的内容会被操作系统更改为函数的VA。这个修改最终会导致通向“值-名称”描述的桥2发生断裂==，如图4-8所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.25j2s8jdcqu8.webp)

图　4-8　内存中的导入表与IAT的关系

==当桥2发生断裂以后，如果没有桥1作为参照（因为桥1和桥2维护了两个一一对应的函数RVA），我们就无法重新找到该地址到底是调用了哪个函数。这就是为什么会在导入表数据结构中存在两个桥的原因，也是为什么单桥导入表结构中无法实施绑定的原因==。

## 4.3.5　构造调用同一个DLL文件的多个函数的导入表

由于HelloWorld.exe过于简单，下面构造一个调用同一个DLL文件的多个函数的导入表——LockTray。通过分析LockTray，进一步明晰复杂导入链表的具体构造。

#### 1.源代码

保存代码清单4-1内容到文件LockTray.asm，或从随书文件的chapter4目录下获取该文件。该源代码实现了锁定任务栏的功能，执行程序后任务栏无法操作，包括“开始”菜单也无法打开。

代码清单4-1　锁定任务栏（chapter4\LockTray.asm）

------

```assembly
;------------------------
; 锁定任务栏
; 戚利
; 2006.2.28
;------------------------
    .386
    .model flat,stdcall
    option casemap:none

include    windows.inc
include    user32.inc
includelib user32.lib
include    kernel32.inc
includelib kernel32.lib

;数据段
    .data
sz1     db  'Shell_TrayWnd',0
hTray  	dd  ?

;代码段
    .code
start:
    invoke FindWindow,addr sz1,0
    mov hTray,eax
    invoke ShowWindow,hTray,SW_HIDE
    invoke EnableWindow,hTray,FALSE

    invoke ExitProcess,NULL
    end start

```

------

代码很简单，首先调用函数FindWindow获取任务栏的句柄（行24）存储到hTray变量中。然后调用ShowWindow（行26）将任务栏窗口隐藏起来，最后通过函数EnableWindow将任务栏设置为禁止操作。编译链接生成最终要分析的PE文件LockTray.exe。

#### 2.LockTray的导入表

使用工具PEInfo分析LockTray.exe文件结构，得出以下内容：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.zbkwr8hx2m8.webp)

以下是从编译链接后的LockTray.exe中获取到的导入表部分数据。该数据被分配进节.rdata中。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.1hbv8pofidxc.webp)

程序中一共使用了user32.dll的三个API函数，依次为：EnableWindow、FindWindow和ShowWindow，那么PE是如何构造这个导入表的呢？下面来看具体分析：

------

```assembly
＞＞5C 20 00 00
```

------

==桥1，最高位为0，表示这是一个RVA，表示函数是以字符串类型的函数名导入的==。从文件偏移0x0000065C处取出的值应该是一组IMAGE_THUNK_DATA，一直找到双字0为止。取出的这些IMAGE_THUNK_DATA结构依次是：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.58r46fk9tz00.webp)

前三个RVA分别指向了IMAGE_IMPORT_BY_NAME结构，代表调用的三个函数。

------

```assembly
＞＞00 00 00 00
＞＞00 00 00 00
＞＞98 20 00 00
```

------

指向user32.dll\0字符串。

------

```assembly
＞＞08 20 00 00
```

------

桥2，分析方法同桥1。

最后，用一个图来表示LockTray.exe的导入表结构，见图4-9。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.3z2rmaoe5fo0.webp)

图　4-9　文件中的LockTray导入表

在上图中，FirstThunk应该和OriganalFirstThunk一样也有一份函数指针表，即桥2。只是在这里没有画出来而已，图4-10是装入内存后的LockTray.exe的导入表。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.7kxjjdoo1kg0.webp)

图　4-10　内存中的LockTray导入表

从现在掌握的对导入表的知识来看，==定位导入函数地址表的方法有两种==：

1. ==第一种方法是从导入表的最后一个导入表项IMAGE_IMPORT_DESCRIPTOR结构中的字IMAGE_IMPORT_DESCRIPTOR.FirstThunk定位IAT==。
2. ==第二种方法是通过数据目录第13个数据项的描述直接定位IAT==。

诚如结构里所描述的那样，每个动态链接库都维护了自己的IAT内容，而且不同链接库维护的这些内容可以是不连续的，这在后面还会讲到。

==当程序加载到内存以后，导入表部分发生变化的值正是IMAGE_IMPORT_DESCRIPTOR结构中的FirstThunk字段指向的函数指针表内容。这些内容已经不是指向函数名的指针了，而是指向了虚拟内存中该函数的可执行代码的地址==！所以其含义也由原来的函数指针更改为函数的入口地址。现在看来，所有的这些值最终都指向了同一片连续的区域，从而形成了我们常说的IAT。

图4-11从另一个侧面分析了导入表的数据组织。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.1p2te00cw6kg.webp)

图　4-11　导入表平面解析

如图所示：

- (1)是user32.dll动态链接库。
- (2)是kernel32.dll动态链接库。
- ①‘是指向引入user32函数名的指针数组。
- ②’是指向引入kernel32函数名的指针数组。
- ①是指向引入user32函数入口地址的指针数组。
- ②是指向引入kernel32函数入口地址的指针数组。
- ①'+②'组成了标准的IAT。如果在内存中，这里的地址会被修改成相关函数的绝对地址，程序只要跳转到这里就可以执行相关函数了。

图中涉及与导入表有关的所有数据，但是狭义上的导入表却只是几个IMAGE_IMPORT_DESCRIPTOR结构而已，因为在数据目录中记录的导入表长度只计算了这些结构的大小，其他的数据并没有包含在内！这一点一定要清楚。上图的导入表长度只有3ch个字节，但与导入表相关的数据却长达92h个字节。

接下来，介绍与导入表有关的编程，主要学习如何根据导入表的数据组织方式从PE文件中获取导入表的相关信息。

# 4.4　导入表编程

本节将围绕导入表结构讲述如何对导入表进行遍历。遍历输出的内容包括导入表使用了哪些动态链接库，都调用了这些动态链接库的哪些函数等。通过分析一个PE文件的导入表信息，可以猜测出该PE文件的大致功能，这种应用在逆向工程和病毒分析方面比较常见。

## 4.4.1　导入表遍历的思路

遍历导入表的大致步骤如下：

1. ==步骤1　将导入表的第一个IMAGE_IMPORT_DESCRIPTOR的起始地址给edi。==
2. ==步骤2　获取导入表所处的节的名称，并显示。==
3. ==步骤3　构造循环条件，当IMAGE_IMPORT_DESCRIPTOR结构中所有的字段均不为0时作为执行条件。==
4. ==步骤4　获取IMAGE_IMPORT_DESCRIPTOR结构所有字段，并显示该结构对应的动态链接库名称。==
5. ==步骤5　显示该动态链接库下调用的所有函数的编号和名称。==

## 4.4.2　编写函数`_getImportInfo`

回顾本书第2章介绍的PEInfo小工具，利用该工具可以输出PE文件头部结构的大部分信息。作为整个小工具输出信息的一部分，本小节将讲述如何通过编码输出导入表信息。本节的源程序来自第2章的PEInfo.asm。打开该文件，在`_openFile`函数中加入以下代码（加黑部分）：

------

```assembly
;到此为止，该文件的验证已经完成。为PE结构文件
;接下来分析文件映射到内存中的数据，并显示主要参数
invoke _getMainInfo,@lpMemory,esi,@dwFileSize
;显示导入表
invoke _getImportInfo,@lpMemory,esi,@dwFileSize
```

------

加入的代码调用了函数`_getImportInfo`，该函数即为遍历PE导入表的函数。详细编码见代码清单4-2所示。

代码清单4-2　遍历PE文件导入表的函数\_getImportInfo（chapter4\peinfo.asm）

------

```assembly
;--------------------
; 获取PE文件的导入表
; 参数：
;   _lpFile - PE文件的基地址
;   _lpPeHead - PE文件的PE头地址
;   _dwSize - 数据缓冲区的大小
;--------------------
_getImportInfo proc _lpFile,_lpPeHead,_dwSize
  local @szBuffer[1024]:byte
  local @szSectionName[16]:byte

  ; 保存寄存器状态
  pushad

  ; 获取导入表的虚拟地址
  mov edi,_lpPeHead
  assume edi:ptr IMAGE_NT_HEADERS
  mov eax,[edi].OptionalHeader.DataDirectory[8].VirtualAddress

  ; 如果导入表不存在，添加错误信息并返回
  .if !eax
    invoke _appendInfo,addr szErrNoImport
    jmp _Ret
  .endif

  ; 转换虚拟地址为文件偏移地址
  invoke _RVAToOffset,_lpFile,eax
  add eax,_lpFile
  mov edi,eax     ; 计算引入表所在文件偏移位置
  assume edi:ptr IMAGE_IMPORT_DESCRIPTOR

  ; 获取引入表所在节名并添加到信息
  invoke _getRVASectionName,_lpFile,[edi].OriginalFirstThunk
  invoke wsprintf,addr @szBuffer,addr szMsg1,eax  ; 显示节名
  invoke _appendInfo,addr @szBuffer

  ; 循环处理每个导入描述符
  .while [edi].OriginalFirstThunk || [edi].TimeDateStamp ||\
                 [edi].ForwarderChain || [edi].Name1 ||\
                 [edi].FirstThunk
    ; 获取导入模块的名称
    invoke _RVAToOffset,_lpFile,[edi].Name1
    add eax,_lpFile
    invoke wsprintf,addr @szBuffer,addr szMsgImport,eax,\
           [edi].OriginalFirstThunk,[edi].TimeDateStamp,\
           [edi].ForwarderChain,[edi].FirstThunk
    invoke _appendInfo,addr @szBuffer

    ; 获取IMAGE_THUNK_DATA列表到EBX
    .if [edi].OriginalFirstThunk
      mov eax,[edi].OriginalFirstThunk
    .else
      mov eax,[edi].FirstThunk
    .endif
    invoke _RVAToOffset,_lpFile,eax
    add eax,_lpFile
    mov ebx,eax

    ; 循环处理导入的函数
    .while dword ptr [ebx]
      ; 检查是否按序号导入
      .if dword ptr [ebx] & IMAGE_ORDINAL_FLAG32
        mov eax,dword ptr [ebx]
        and eax,0ffffh
        invoke wsprintf,addr @szBuffer,addr szMsg3,eax
      .else  ; 按名称导入                                      
        invoke _RVAToOffset,_lpFile,dword ptr [ebx]
        add eax,_lpFile
        assume eax:ptr IMAGE_IMPORT_BY_NAME
        movzx ecx,[eax].Hint
        invoke wsprintf,addr @szBuffer,\
              addr szMsg2,ecx,addr [eax].Name1
        assume eax:nothing
      .endif
      invoke _appendInfo,addr @szBuffer
      add ebx,4
    .endw
    add edi,sizeof IMAGE_IMPORT_DESCRIPTOR
  .endw

_Ret:
  ; 恢复寄存器状态
  popad

  ; 返回
  ret
_getImportInfo endp ; 结束过程

```

------

行11定位数据目录表项，获取导入表所在内存的RVA。==[edi].OptionalHeader.Data Directory[8]表示从数据目录表开始地址再加8个字节，这8个字节刚好跳过数据目录的第1项导出表，从而定位到导入表==。

行12～15==判断取出的RVA是否为0，如果是0则表示该PE文件无导入表，显示信息，返回==。

行16～23==将取到的RVA值转换为FOA，并将指针EDI调整到该位置，输出导入表数据所处的节的名称==。

行24～62是一个循环，该==循环的主要功能是处理每个导入表项IMAGE_IMPORT_DESCRIPTOR结构，显示每个导入表项的相关信息==，这些信息包括：

- ==动态链接库名称==
- ==IMAGE_IMPORT_DESCRIPTOR结构的每个字段的值==
- ==导入的函数“编号/名称”==

循环的结束条件是IMAGE_IMPORT_DESCRIPTOR的每个字段的值均为0。行43～60是内嵌循环，显示了从每个动态链接库导入的函数列表。

## 4.4.3　运行测试

编译链接生成PEInfo.exe，运行后取chapter4\HelloWorld.exe文件分析其导入表部分结果显示如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.1pvdcpnzuog0.webp)

从输出的分析结果可以看出，HelloWorld.exe一共调用了两个动态链接库的2个函数，与源代码中的invoke调用个数是一致的。

# 4.5　绑定导入

绑定导入是一种提高PE加载速度的技术。它只能起辅助性的作用，它的存在与否只影响加载过程，并不影响PE的最终加载结果和运行结果。

## 4.5.1　绑定导入机制

双桥结构的导入表中，桥2是指向IAT的，Windows加载程序负责IAT中地址的修正工作。如果一个PE中导入的函数比较多，那么这部分工作就会占用一些时间，PE加载速度就会变慢。==绑定导入的目的就是把由Windows加载程序负责的IAT地址修正工作提前到加载前进行==，要么由用户手工完成，要么由专门的程序来完成；==然后，通过在PE文件中声明绑定导入数据，以便告诉操作系统加载器说这部分工作不需要你做了==。

那么，为什么说它只是辅助性的工作呢？不同的操作系统中，动态链接库的基地址通常是不一样的。比如kernel32.dll，在Windows 2000中其加载到进程空间的基地址为0x77e60000，而在Windows XP SP3中其加载地址则是0x7c800000。同一动态链接库加载后处于不同的基地址，直接导致了同一个导入函数在不同操作系统中其导入地址VA是不一样的。所以，经过绑定导入的一个PE程序可能在Windows 2000里运行得很好，但到了Windows XP中却因地址出现错误而造成无法运行。

在为PE加入绑定导入机制的时候，微软就已经考虑到了这个问题，所以假定PE加载前对IAT的修正都是正确的。那么PE的加载速度是加快的，即使绑定以后的EXE程序在其他的兼容系统中运行时，其地址出现错误，PE加载也有检测错误的机制。如果地址检测出错误，PE加载器会重新接管这项工作，加载时对IAT进行修正。

==微软提供了一个绑定工具bind.exe程序，该程序可以把导入表中IAT表项IMAGE_THUNK_DATA32的内容都静态替换成虚拟内存地址，然后在数据目录表的第12项指定的位置声明这些更改。Windows在加载目标PE相关的动态链接库时，会首先检查这些地址是否正确合法，这些检查包括当前系统的DLL版本是否符合绑定导入结构中描述的版本号，如果不符合或者DLL需要被重新定位，加载器就会去遍历OriginalFirstThunk指向的数组（也就是INT），计算新的地址。如果导入表是单桥结构，此时的遍历会失效，所以说单桥结构无法实施静态绑定操作。==

## 4.5.2　绑定导入数据定位

绑定数据是数据目录中注册的一种类型，位于数据目录的第12项。打开chapter4下的notepad.exe，可以找到该位置的数据。以下所示为notepad.exe的数据目录内容（从地址0x00000158开始）。加黑部分为绑定数据项。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.2hicl6t285q0.webp)

从以上字节码可以看出：

```assembly
绑定导入数据RVA=0x00000250
绑定导入数据大小=000000D0h
```

根据RVA与FOA的换算关系，可以计算出绑定导入数据所在文件的偏移为：0x00000250。

> 注意　系统文件的绑定导入数据在文件中的存放位置：大部分情况下，该数据被存储在PE文件头部，紧跟在节表后。

## 4.5.3　绑定导入数据结构

绑定导入数据由一系列的绑定导入描述符`IMAGE_BOUND_IMPORT_DESCRIPTOR`的结构组成。每一个结构对应一个导入的动态链接库，它描述了导入动态链接库的版本信息（通过时间戳来定义），该结构的详细定义如下：

------

```assembly
IMAGE_BOUND_IMPORT_DESCRIPTOR STRUCT
	TimeDateStamp 					dword 	? ;0000h-时间戳
	OffsetModuleName 				word 	? ;0004h-指向DLL名称
	NumberOfModuleForwarderRefs 	word 	? ;0006h-ModuleForwarderRef数目
IMAGE_BOUND_IMPORT_DESCRIPTOR ENDS
```

------

结构中各字段的详细解释如下：

#### 61.IMAGE_BOUND_IMPORT_DESCRIPTOR.TimeDateStamp

+0000h，双字。==该字段的值必须与要引用的DLL的文件头`IMAGE_FILE_HEADER.TimeDateStamp`字段值相吻合，否则就会促使加载器去重新计算新IAT，这种情况一般发生在DLL版本不同时或者DLL映像被重定位时==。

#### 62.IMAGE_BOUND_IMPORT_DESCRIPTOR.OffsetModuleName

+0004h，单字。==该字段包含了以第一个`IMAGE_BOUND_IMPORT_DESCRIPTOR`作为基址，DLL名称字符串(ASCⅡ且以“\0”结束)的偏移==。

> 注意　该偏移地址是一个特殊地址，它即不是RVA，也不是FOA。
>

#### 63.IMAGE_BOUND_IMPORT_DESCRIPTOR.NumberOfModuleForwarderRefs

+0006h，单字。==该字段描述了紧接在`IMAGE_BOUND_IMPORT_DESCRIPTOR`结构后的另一个结构`IMAGE_BOUND_FORWARDER_REF`数组的元素个数==。

以下是结构`IMAGE_BOUND_FORWARDER_REF`的定义：

------

```assembly
IMAGE_BOUND_FORWARDER_REF STRUCT
	TimeDateStamp 		dword 	? ;0000h-时间戳
	OffsetModuleName 	word 	? ;0004h-指向DLL名称
	Reserved 			word 	? ;0006h-预留
IMAGE_BOUND_FORWARDER_REF ENDS
```

------

为什么会存在该结构呢？出于不同的目的（如代码更新、结构调整或实施补丁等），动态链接库中的某些函数的实现代码会被转移到别的动态链接库中。但为了提供向前的兼容，这些动态链接库中还保留了该函数的定义。也就是说，==一个导入函数将涉及对多动态链接库函数的调用，数据结构`IMAGE_BOUND_FORWARDER_REF`就是在这样一个背景下产生的，它将引入函数涉及的所有动态链接库都列举出来。该结构的字段定义和`IMAGE_BOUND_IMPORT_DESCRIPTOR`是基本一致的，所以前面的描述“绑定导入数据由一系列的绑定导入描述符`IMAGE_BOUND_IMPORT_DESCRIPTOR`的结构组成”也是成立的==。

绑定导入数据的组织方式见图4-12。

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.2szp98of5000.webp)

图　4-12　绑定导入数据的组织方式

## 4.5.4　绑定导入实例分析

在Windows XP操作系统中，大部分系统PE文件都使用了绑定导入技术。下面将以记事本程序为例，为大家讲述绑定导入的实例，以帮助读者了解绑定导入的数据组织方式。

使用小工具PEDump从notepad.exe中获取绑定导入数据如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.76aygl0g4yo0.webp)

我们看一个特殊的具有`IMAGE_BOUND_FORWARDER_REF`的结构，如上列表中黑体部分所示。字节码分析如下：

先分析`IMAGE_BOUND_IMPORT_DESCRIPTOR`。

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.4zpoxjbn49c0.webp)

> 01 00　表示该动态链接库中的函数实现字节码存储在另外一个动态链接库中。

再分析`IMAGE_BOUND_FORWARDER_REF`。

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.61xfjd7vneo0.webp)

# 4.6　手工重组导入表

接下来的实验相对难一点，==我们要为HelloWorld增加一些功能。比如在显示弹出对话框前往注册表里写入一些数据==。这一小节将着重于手工打造这个增加功能的HelloWorld.exe，通过==手工修改现有PE文件，进一步了解和掌握导入表以及PE文件头格式==。

==挑战目标是在HelloWorld.exe运行时，在注册表的以下项目中增加一项，机器重启时会运行任务栏锁定程序==。

------

```bash
[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run]
"NewValue"="D:\\masm32\\source\\chapter5\\LockTray.exe"
```

------

## 4.6.1　常用注册表API

==Win32 API提供了大约25个有关注册表操作的函数，这些函数位于动态链接库文件advapi32.dll中。其中提供了对注册表的打开、读取、写入、删除、关闭等操作，并且具有对注册表实施备份，连接，以及对远程注册表查看等功能==。API经历和发展了很多年，有些函数已经重复，比如函数RegSetValue和函数RegSetValueEx都是用来设置注册表键值的。两者的区别在于：前者是设置注册表键的默认值，仅支持字符串数据类型；而后者不仅继承了前者的所有功能，而且还能对多值或其他数据类型进行操作。比较新的API函数通常会在原函数的名称后面追加"Ex"以示区别，建议在编程中尽可能地选用新函数。下面介绍几个比较常用的操作注册表的API函数。

### 1.函数RegCreateKey

==该函数用于新建一个键==。==如果这个键在注册表中已经存在，那么函数将打开它==。这个函数与Windows 3.1兼容。基于Win32的应用程序应该使用RegCreateKeyEx函数。函数原型如下：

------

```assembly
LONG RegCreateKey(
	HKEY 	hKey,			//要打开键的句柄
	LPCTSTR lpSubKey,		//要打开子键的名字的地址
	PHKEY 	phkResult		//已打开句柄的缓存区的地址
);
```

------

各参数的解释如下：

##### 1）hKey

当前打开键的句柄或下列预定义的句柄值。

- HKEY_CLASSES_ROOT
- HKEY_CURRENT_CONFIG
- HKEY_CURRENT_USER
- HKEY_LOCAL_MACHINE
- HKEY_USERS
- HKEY_PERFORMANCE_DATA

##### 2）lpSubKey：

指向包含了要打开或新建键的名字，该名字以空字符结束。这个键必须是能被hKey参数识别的子键。如果hKey是已确定的保留句柄值之一，lpSubKey可以为NULL。

##### 3）phkResult：

指向接收打开或新建键的变量。当你不再需要返回句柄时，需要调用函数RegCloseKey关闭它。

##### 4）返回值：

如果调用成功，返回ERROR_SUCCESS。如果调用失败，返回一个非零错误码（定义在WINERROR.H）。你可以使用带有FORMAT_MESSAGE_FROM_SYSTEM标记的函数FormatMessage获得普通错误的描述信息。

### 2.函数RegCreateKeyEx

==该函数用于打开指定的键或子键==。==如果要打开的键不存在的话，本函数会试图建立它==。函数原型如下：

------

```assembly
LONG RegCreateKeyEx(
	HKEY 		hKey,
	LPCTSTR 	lpSubKey,
	DWORD 		Reserved,
	LPTSTR 		lpClass,
	DWORD 		dwOptions,
	REGSAM 		samDesired,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	PHKEY 		phkResult,
	LPDWORD		lpdwDisposition
);
```

------

各参数的解释如下：

##### 1）hKey：

主键值。

##### 2）lpSubKey：

一个指向以零结尾的字符串的指针，其中包含了将要创建或打开的子键的名称。其子键不可以用反斜线（\）开始，该参数可以为NULL。

##### 3）Reserved：

保留值，必须设置为0。

##### 4）lpClass：

一个指向包含键类型的字符串。如果该键已经存在，则忽略该参数。

##### 5）dwOptions：

为新创建的键设置一定的属性。可以取下面的一些数值：

- `REG_OPTION_NON_VOLATILE`：表示新创建的键为一个非短暂性的键（即数据信息保存在文件中，当系统重新启动时，数据信息恢复）。
- `REG_OPTION_VOLATILE`：表示新创建的键为一个短暂性的键（数据信息保存在内存中）。
- `REG_OPTION_BACKUP_RESTORE`：仅在WINNT中被支持，可以提供优先级支持。

##### 6）samDesired：

用来设置对键访问的权限，可以取下面的一些数值：

- `KEY_CREATE_LINK`：表示准许生成符号键。
- `KEY_CREATE_SUB_KEY`：表示准许生成子键。
- `KEY_ENUMERATE_SUB_KEYS`：表示准许生成枚举子键。
- `KEY_EXECUTE`：表示准许进行读操作。
- `KEY_NOTIFY`：表示准许更换通告。
- `KEY_QUERY_VALUE`：表示准许查询子键。
- `KEY_ALL_ACCESS`：提供完全访问，是上面数值的组合。
- `KEY_READ`：是KEY_QUERY_VALUE、KEY_ENUMERATE_SUB_KEYS和KEY_NOTIFY数值的组合。
- `KEY_SET_VALUE`：表示准许设置子键的数值。
- `KEY_WRITE`：是KEY_SET_VALUE和KEY_CREATE_SUB_KEY两个数值的组合。

##### 7）lpSecurityAttributes：

一个指向`SECURITY_ATTRIBUTES`结构的指针，确定返回的句柄是否被子处理过程继承。如果该参数为NULL，则句柄不可以被继承。在WINNT中，该参数可以为新创建的键增加安全性方面的描述。

##### 8）phkResult：

指向新创建或打开的键的句柄的指针。

##### 9）lpdwDispition：

指明键是被创建还是被打开的，可以是下面的一些数值：

- `REG_CREATE_NEW_KEY`：表示键先前不存在，现在被创建。
- `REG_OPENED_EXISTING_KEY`：表示键先前已存在，现在被打开。

##### 10）返回值：

如果该函数调用成功，则返回ERROR_SUCCESS；否则，返回值为文件WINERROR.h中定义的一个非零的错误代码。可以通过设置FORMAT_MESSAGE_FROM_SYSTEM标识并调用函数FormatMessage获得普通错误的描述信息。

### 3.函数RegOpenKeyEx

==该函数用于打开一个指定的键，并返回打开键的句柄==。函数原型如下：

------

```assembly
LONG RegOpenKeyEx(
	HKEY 	hKey,
	LPCTSTR lpSubKey,
	DWORD 	ulOptions,
	REGSAM 	samDesired,
	PHKEY 	phkResult
);
```

------

各参数解释如下：

##### 1）hKey：

同RegCreateKeyEx函数中的hKey参数。

##### 2）lpSubKey：

指向以0结尾的字符串的指针，其中包含子键的名称，可以利用反斜线（\）分隔不同的子键名。如果字符串为空，则根据hKey参数创建一个新的句柄。在这种情况下，并不关闭先前打开的句柄。

##### 3）ulOption：

保留，通常必须设置为0。

##### 4）samDesired：

其含义同RegCreateKeyEx函数中的samDesired参数。

##### 5）phkResult：

它是一个指针，用来指向打开的键的句柄。可以通过RegCloseKey函数关闭这个句柄。

##### 6）返回值：

函数的返回值同RegCreateKeyEx函数的返回值。

### 4.函数RegSetValueEx

该函数用来设置注册表的键值和键的类型。函数原型如下：

------

```assembly
LONG RegSetValueEx（
	HKEY 	hKey,		//打开键的句柄
	LPCTSTR lpValueName,//值的名字
	DWORD 	Reserved,	//保留
	DWORD 	dwType,		//数值类型
	const 	BYTE * lpDate,	//缓冲区,存放值
	DWORD 	cbData		//值的长度
);
```

------

各参数解释如下：

##### 1）hKey：

表示一个被打开的键的句柄，该键必须以KEY_SET_VALUE安全级别打开。该句柄可以是由函数RegCreateKeyEx或者RegOpenKeyEx返回的句柄，也可以是函数RegOpenKeyEx参数hKey中预定义的句柄值。

##### 2）lpValueName：

字符串指针，所指的字符串表示将要设定的键的名称。如果该键值不存在，该函数则设定该键值；如果该指针为NULL或者指向的字符串为空，则该函数为一个无名字或者默认名字的键设定键值和类型。

##### 3）Reserved：

保留，必须为0。

##### 4）dwType：

定义由lpDate所指向的数据的类型，该参数的值如下：

- REG_BINARY：任意二进制数。
- REG_DWORD：32位的数字。
- REG_DWORD_LITTLE_ENDIAN：little-endian格式32位的数字。该值在Windows头文件中被定义为REG_DWORD。
- REG_DWORD_BIG_ENDIAN：big-endian格式的32位数字，一些UNIX系统支持bigendian格式。
- REG_EXPAND_SZ：字符串（如"%PATH%"）。当你使用Unicode函数，该值则表示Unicode字符串，否则表示Ansi字符串。
- REG_LINK：保留值，供系统使用。
- REG_MULTI_SZ：字符串数组，以两个空字符结束。
- REG_NONE：为定义类型。
- REG_QWORD：64位的数字。
- REG_QWORD_LITTLE_ENDIAN：little-endian格式的64位数字。Windows系统是在little-endian结构的计算机上运行的，因此该值在Windows头文件中被定义为REG_QWORD。
- REG_SZ：字符串。当使用Unicode函数时，该类型表示Unicode字符串，否则表示Ansi字符串。

##### 5）lpData：

指向一个缓存区，该缓存区保存要设置的键值。如果是字符类型，则该字符串必须以“\0”结尾；如果是REG_MULTI_SZ类型，该值必须以两个“\0”字符结尾。如果最后一个字符不是“\0”，该函数将会检查下一个字符，并判断是否以“\0”结尾。如果需要，该函数会增加字符串长度以便可以容纳更多的字符。

##### 6）cbData：

lpData所指向信息的字节长度。如果是字符串类型，必须包含字符串结束符号。

##### 7）返回值：

如果成功，则返回ERROR_SUCCESS。

### 5.函数RegCloseKey

==该函数用来释放给定键的句柄==，函数原型如下：

------

```assembly
LONG RegCloseKey(
	HKEY hKey//要关闭键的句柄
);
```

------

函数参数解释如下：

##### 1）hKey：

要关闭已打开键的句柄。

##### 2）返回值：

如果调用成功，返回ERROR_SUCCESS；如果调用失败，返回非零错误代码（定义在WINERROR.H）。你可以使用带有FORMAT_MESSAGE_FROM_SYSTE标记的函数FormatMessage获得普通错误描述信息。

> **与设计目标有关的汇编代码如下**
>
> ------
>
> ```assembly
> invoke RegCreateKey,HKEY_LOCAL_MACHINE,_lpszKey,addr @hKey
> invoke RegSetValueEx,@hKey,_lpszValueName,NULL,_lpdwType,_lpszValue,_lpdwSize
> invoke RegCloseKey,@hKey
> ```
>
> ------
>
> ==别小看这三行代码，如果通过手工修改，将这些代码人为地添加到目标PE中，难度还是相当大的==，现在就来挑战一下吧。

## 4.6.2　构造目标指令

==本小节将根据汇编代码模拟编译程序的指令代码构造，生成最终要添加到目标PE的指令字节码==。

### 1.模拟指令代码

通过之前对汇编语言与指令字节码的了解，相信大家可以很容易地模拟出此次挑战的三行汇编代码，大致字节码如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.624wxoeeg2s0.webp)

### 2.细化指令

下面，对模拟的指令字节码进行细化，具体包括：

#### （1）68xxxxxxxx push addr @hKey

如果数据在`.data`段中，而传递的是地址，比如`addr @hKey`，则push的指令码为68h，后面紧跟着8位的地址，该地址指示了数据所在位置的VA。==即@hKey所在的VA。关于这个值的计算方法如下：==

- ==获得程序默认装载地址=0x00400000==

- ==获得数据段.data的起始RVA=0x03000==

假设数据段的安排如下所示：

------

```assembly
.data
	szText 	db 'HelloWorld',0
	sz1 	db 'SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN',0
	sz2 	db 'NewValue',0
	sz3 	db 'd:\masm32\source\chapter5\LockTray.exe',0
	@hKey 	dd ?
```

------

对应的字节码为：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.dee3tpetkgw.webp)

根据数据段各变量的位置，==从上述所列字节码中找到@hKey所在的位置为0x00403069，所以第一条指令字节码是68 69 30 40 00==。

#### （2）68xxxxxxxx push addr sz1

采用和第1条指令相同的分析方法，获取注册表分支所在位置，最后得出第二条压栈指令。==第二条指令字节码是68 0B 30 40 00==。

#### （3）68xxxxxxxx push HKEY_LOCAL_MACHINE

因为HKEY_LOCAL_MACHINE是一个双字常量，所以压栈的指令字节码为68h，其后是该常量的值。打开D:\masm32\include\windows.inc文件，找到该常量的定义语句：

------

```assembly
HKEY_LOCAL_MACHINE equ 80000002h
```

------

得到第==三条指令字节码是68 02 00 00 80==。

#### （4）E8xxxxxxxx call RegCreateKeyA

由于这是一个段内调用，所以call的指令字节码为E8，而其后跟随的则是距离真正跳转指令的偏移。那么，真正跳转的指令距离这个指令到底有多远呢？可以通过以下方法计算出来。

首先，确定最初HelloWorld.exe的指令长度为24h（通过PEDump获知）。

其次，它要跳过自身后面的所有指令，如下所示：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.228mi706resg.webp)

这些指令加起来的长度为26h，两者相加即为call到jmp的偏移量4Ah；所以，==第四条指令的字节码是E8 4A 00 00 00==。

#### （5）6A27 PUSH 27H

如果往栈里推入的双字可以控制在一个字节内，那么需要使用6A指令。后面直接跟一个字节的数值。

==第五条指令的字节码是6A 27==。

使用以上分析方法，不难得出6～9条指令的字节码依次为：

==第六条指令字节码是68 42 30 40 00==。

==第七条指令字节码是6A 01==。

==第八条指令字节码是6A 00==。

==第九条指令字节码是68 39 30 40 00==。

#### （6）FF35 xxxxxxxx push @hKey

当要将数据段指定位置的双字值压入栈时，需要使用指令FF35，其跟着指定位置的VA。其实该指令可以解释为：

```assembly
push dword ptr ds:[xxxxxxxx]。
```

所以==第十条指令字节码是FF 35 69 30 40 00==。

#### （7）E8 xxxxxxxx call RegSetValueExA

同第四条指令，该跳转的地址紧跟在第四条指令跳转的后面。现在计算操作数，长度由以下部分组成：

##### 1）该指令下的其他指令如下，总计0Bh个字节。

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.5vs31jsw8x80.webp)

##### 2）原Helloworld.exe指令，总计24h个字节。

##### 3）第四条指令的跳转指令FF 25 XX XX XX XX，总计6h个字节。

以上长度加起来以后的结果是35h。所以==第十一条指令字节码为E8 35 00 00 00==。

#### （8）FF35 xxxxxxxx Push @hKey

==第十二条指令字节码是FF 35 69 30 40 00==。

#### （9）E8xxxxxxxx Call RegClose 

同第四条指令，该跳转地址紧跟在第十一条指令后，其长度的计算包括以下几个部分：

其后再无添加代码（0h）

原Helloworld.exe指令（24h）

第四条指令的跳转指令FF 25 XX XX XX XX（6h）

第十一条指令的跳转指令FF 25 XX XX XX XX（6h）

以上长度加起来以后的结果是30h。==第十三条指令字节为E8 30 00 00 00==。

#### （10）跳转指令

跳转指令为FF25，后面跟着要跳转到的VA地址。从前面对导入表的分析看，这三个函数的地址是IAT的前三个，也就是最后一个非零IMAGE_IMPORT_DESCRIPTOR结构中字段FirstThunk指向的位置。其地址依次为00402000、00402004、00402008，所以，最后三个跳转指令依次为：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.1yh1g4c1sfj4.webp)

综上所述，新增加代码的字节码如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.35m7lzy3p380.webp)

与原HelloWorld.exe的字节码相比，代码部分增加了4Ch大小。指令字节码构造完成后，接下来的任务就是分析此次修改导致的PE头部的变化。

## 4.6.3　PE头部变化

#### 1.IMAGE_SECTION_HEADER(.data).VirtualSize

新增加的常量都定义在源代码的数据段主要包括以下内容：

------

```assembly
sz1 db 'SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN',0
sz2 db 'NewValue',0
sz3 db 'd:\masm32\source\chapter5\LockTray.exe',0
@hKey dd ?
```

------

==共98个字节，所以`.data`节的尺寸要增加62h==。

#### 2.IMAGE_DATA_DIRECORY[IAT].isize

由于新增加了一个IMAGE_IMPORT_DESCRIPTOR，所以在IAT中要加入新增加的三个入口函数地址；同时，增加一个结尾的0，共四个双字，16个字节，==故IMAGE_DATA_DIRECORY[IAT].isize要多加10h==。

#### 3.IMAGE_DATA_DIRECORY[IT].VirtualAddress

由于导入表的起始地址紧跟在IAT后，IAT多增加的字节数也是导入表起始地址的后移数量，所以该字段要后移16个字节，即==IMAGE_DATA_DIRECORY[IT].VirtualAddress要多加10h==。

#### 4.IMAGE_SECTION_HEADER(.rdata).VirtualSize

##### 1）==增加一个动态链接库，就增加一个IMAGE_IMPORT_DESCRIPTOR结构，大小为14h==。

##### 2）==OriginalFirstThunk部分，3个新增注册表操作函数名指针和一个0结尾的指针共10h==。

##### 3）“编号/名称”部分包含以下定义：

------

```assembly
xxRegCreateKeyA\0xxRegSetValueExA\0xxRegCloseKey\0advapi32.dll\0\0
```

------

==共计61个字节，即十六进制的3Dh==。

#### 4）FirstThunk部分，3个新增注册表函数名指针和一个0结尾的指针共10h。

综上所述，IMAGE_SECTION_HEADER(.rdata).VirtualSize的值需要多加71h。

#### 5.IMAGE_DATA_DIRECORY[IT].isize

多了一个动态链接库，就多出一个IMAGE_IMPORT_DESCRIPTOR结构，该结构大小为14h。==即IMAGE_DATA_DIRECORY[IT].isize多加14h==。

#### 6.IMAGE_SECTION_HEADER(.text).VirtualSize

代码大小前面已分析过，增加了4Ch大小。

由于插入代码而使得PE头部发生变化之处见表4-1。

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.6kizixz8r2k0.webp)

## 4.6.4　手工重组

完成了指令字节码构造，明确了PE头部需要更改的字段，接下来就是手工重组部分。由于新的代码和数据与原来的代码和数据加在一起没有超出文件对齐要求的粒度，所以DOS头、PE头的大部分字段不需要修改。下面就逐项列出手工重组过程中需要修改的地方和修改的具体方法。

### 1.数据段

首先，添加程序中用到的数据。定位到HelloWorld.exe文件的800h处，从第一个字节为0的地方复制以下数据：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.2dstywxh2bwg.webp)

这些数据总共为98个字节，即十六进制的62H。

> ==注意　录入时要采用覆盖方式，以保证.data的长度不变。==

然后，修改与数据段有关的字段。定位`IMAGE_SECTION_HEADER(.data).VirtualSize`，并将原来的值0000000Bh更改为0000006Dh。

由于目前只修改了数据段内容，并没有破坏PE文件的结构，所以到现在为止修改后的HelloWorld.exe还是可以正常运行的。

### 2.代码段

首先看数据部分。原代码段位于0400h处，其字节码如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.75l9ajkxvg00.webp)

对代码段的修改需要将新增加的指令字节码加入到该段中，最终变成以下内容：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.3athmzbn3wo0.webp)

细心的你可能已经发现了，加入代码以后，原来HelloWorld.exe的部分内容也发生了变化（黑体部分）。

发生变化的部分是调用函数的入口地址。如果不健忘，这个位置的数据应该指向IAT。==当导入表发生变化以后，新产生的IA被安排在IAT的头部，所以其他的调用地址必须往后调整==。==在程序中，一共增加了三个函数（这三个函数均来自同一个动态链接库），所以按照导入表的要求，在IAT表头需要增加三个函数的入口地址（12个字节）和一个全0（4个字节）的地址。这样，原来的入口函数地址都要往后调整10h个字节，所以在HelloWorld.exe的原代码中两个地址均增加了10h==。

修改完代码段以后要注意对齐，以保证下面的0600h处起始为.rdata的数据。

现在来修改与代码段有关的字段。定位IMAGE_SECTION_HEADER(.text).VirtualSize，并将原来的值00000024h更改为00000070h。

由于代码发生了变更，而代码中涉及的函数调用地址等还没有完全构造好，所以，这时候一定不要去测试，运行HelloWorld.exe程序是不会成功的。

### 3.".rdata"段

由于涉及对导入表的重组，所以对这个段的修改是最复杂的，不过只要掌握了导入表有关的知识，相信这个修改也难不倒你。

修改前，先看一下导入表数据的原始字节码如下所示：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.5jcyjhsl1uw0.webp)

修改后的内容如下所示（带下划线为新增加部分，斜线部分的值并不是真实的，待定）：

##### （1）INT，即OriginalFirstThunk部分（4\*4+2\*4+2\*4=20h）

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.7bptfhir4680.webp)

##### （2）导入表项部分（20\*3+20=50h）

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.6ypwzuw568o0.webp)

##### （3）IAT，即FirstThunk部分（4\*4+2\*4+2\*4=20h）

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.28gc2mwzab40.webp)

##### （4）函数编号、函数名以及动态链接库名部分

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.1gcioymc24tc.webp)

以上列出了导入表的四个组成部分，只要知道了代码中调用函数的个数以及链接库的个数，INT、导入表项、IAT三个部分的大小就是固定的了。事实上，导入表的重组只需要先将第4部分也就是函数编号、函数名和动态链接库这一部分根据编码设置好，剩下的其他部分的数据就可以按照数据结构自行构造了。

> 注意　无论是原来HelloWorld的字节码还是新加入的字节码，涉及的VA都需要重新计算。

首先根据源代码把第4部分编排好，然后构造一张动态链接库及调用函数的地址表，内容见表4-2。

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.2fy0rs5oqfz.webp)

最后一步，根据表4-2的内容，完成导入表其他三个部分的字节码构造。先来看第1部分和第2部分字节码的构造：

第1部分（INT）：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.5mwrkfh3qk80.webp)

第2部分（导入表项）：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.6d7ecpr6ibg0.webp)

第三个导入表项IMAGE_IMPORT_DESCRIPTOR的OriginalFirstChunk值为00002070h，它是一个RVA，转换为文件偏移为0x00000670。FirstChunk的值为00002000h，它也是一个RVA，转换为文件偏移为0x00000600。文件中IAT和INT维护了两份值相同的双字数组。

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.6y9kkpf5g3k0.webp)

第一个双字的值000020C6h来自于表4-2中函数RegCreateKeyA的VA地址。由于该值在导入表结构中定义为RVA，所以，需要用函数RegCreateKeyA的VA地址减掉模块加载的基址。另外两个双字用同样的方法填充。构造好的第3部分字节码如下：

第3部分（IAT）：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.1728f7xj87xc.webp)

> 提示　在真正的导入表重组过程中，为了能减少工作量，降低复杂度，通常会将该导入表的现有数据全部作废，利用一块新的空间重新构造PE的导入表数据，并修改PE头部数据目录表的第2项的相关值，重新注册导入表起始地址和大小。这种方法在第14章会用到。

### 4.修改与数据目录表项和节表项相关字段

定位IMAGE_SECTION_HEADER(.rdata).VirtualSize，并将原来的值00000092h更改为00000103h。

定位IMAGE_DATA_DIRECORY[IT].VirtualAddress，并将原来的值00002010h更改为00002020h。

定位IMAGE_DATA_DIRECORY[IT].isize，并将原来的值0000003ch更改为00000050h。

定位IMAGE_DATA_DIRECORY[IAT].isize，并将原来的值00000010h更改为00000020h。

> 注意　经过以上修改，可能会导致节".rdata"的数据没有按照内存对齐粒度对齐，请注意查看。

### 5.运行测试

手工改造任务基本完成。伟大的工程等待一次伟大的检验，赶紧运行吧！运行后发现只是注册表被更改，而后面的弹出对话框没有出来。怎么回事呢？

回到程序字节码部分，看看调用函数MessageBox和函数ExitProcess时使用的地址，由于我们手工生成了IAT，在生成的时候并没有考虑到这两个函数的调用顺序。所以，只需要在字节码中，将代码段涉及这两个函数的指令字节码中的jmp的地址调换一下即可。事实上，IAT总是按照函数名或函数编号的升序进行排列的，所以在导入表重组时一定要考虑这个问题，不然就会出现程序运行错误。

重新运行一次，怎么样？是不是很有成就感？图4-13是被修改的注册表启动项。

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.1ylrldaibj7k.webp)

图　4-13　修改后的注册表启动项

完整的字节码请查看随书文件chapter4\newHelloWorld.exe。以上我们所做的工作只是链接器程序要做的工作的一小部分。

## 4.6.5　程序实现

刚才的工作如果让链接器来做会是怎样的呢？代码清单4-3列出了通过程序代码实现添加注册表启动项的功能代码。

代码清单4-3　添加注册表项（chapter4\HelloWorld2.asm）

------

```assembly
	.386
    .model flat,stdcall
    option casemap:none

include    windows.inc
include    user32.inc
includelib user32.lib
include    kernel32.inc
includelib kernel32.lib
include    advapi32.inc
includelib advapi32.lib

;数据段
    .data
szText     db  'HelloWorld',0
sz1        db  'SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN',0
sz2        db  'NewValue',0
sz3        db  'd:\masm32\source\chapter5\LockTray.exe',0
@hKey      dd  ?

;代码段
    .code
start:
    invoke RegCreateKey,HKEY_LOCAL_MACHINE,addr sz1,addr @hKey
    invoke RegSetValueEx,@hKey,addr sz2,NULL,\
                 REG_SZ,addr sz3,27h
    invoke RegCloseKey,@hKey

    invoke MessageBox,NULL,offset szText,NULL,MB_OK
    invoke ExitProcess,NULL
    end start

```

------

为了对比手工修改与程序自动生成的字节码之间的区别，在程序编码时尽量使用手工修改时的数据定义及代码编码。编译链接生成最终的可执行程序，其运行效果和手工修改以后的NewHelloWorld.exe是完全一样的。

使用PEComp工具把刚才改造的NewHelloworld.exe与HelloWorld2.exe进行对比，结果见图4-14，你会发现两个程序实现的功能虽然一样，但还是有很多不一样的地方，比如位于节".rdata"中的导入表数据部分。节".rdata"的IMAGE_SECTION_HEADER2.VirtualSize是不一样的，链接器在定义函数RegSetValueExA的名字时后面多加了一个“\0”。凡是函数名字符串的字符个数为偶数，则后面跟两个“\0”，如果函数名后面为奇数，则后面跟1个“\0”。“\0”的个数是为了保持2个字节对齐而设置的。

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.13mgq9nfbyv4.webp)

图　4-14　手工与自动编码PE的对比

> 特别提醒　不要被程序运行的表象所迷惑，说不定后台就会有你看不到的代码正在运行中！测试完成后请务必删除启动项添加的那个键，不要说我没有告诉你哦！

## 4.6.6　思考：关于IAT的连贯性

==IAT必须是连续的吗？答案是否定的==。

从对代码段的分析来看，只要跳转指令FF25跳转到正确的位置，导入表的FirstThunk字段指针指向正确的位置，则IAT可以不连续。关于这个结论大家可以自己做实验进行验证。

以下是对AnotherHelloWorld.exe各部分的修改。

### （1）代码段的跳转指令

将其中对有关函数调用的地址从004020XX更改为004021xx，如下所示：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.45cn65d6puk0.webp)

### （2）导入表部分

为了使改动最小，将原来位于文件偏移610h的新增加的IAT移动到710h处，并将导入表的数据结构的最后一个非0的FirstThunk指针，修改为00002110，即下面加框的部分。

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.7180eev3wk00.webp)

文件偏移量600h处的16个字节和偏移量710h处的16个字节共同组成了IAT，该程序依旧可以被装载并正确运行。那么如果更改了IAT的大小情况会怎样呢？数据目录中IAT的大小部分可以任意更改，起始位置RVA也可以更改，但不能将位置改动到有其他属性的节中，不然会出现如图4-15所示的错误。

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.35ne5b6rh5a0.webp)

图　4-15　改动IAT位置导致失败提示

## 4.6.7　思考：关于导入表的位置

==导入表通常在常量节里，但这并不是定理。我们可以把它放到代码节里，或其他的任何可读属性的节里。==

比如，将HelloWorld2.exe中的导入表数据放入代码段的空闲位置。即文件偏移0x000004B0处，如下所示：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.47s6euzhryk0.webp)

导入表原来位置的数据替换为0或不用都可以。其实，在有些时候，要想从PE文件中找出间隙来还是很难的。根据FOA和RVA的转换关系，得出导入表新位置在内存中的RVA值为000010B0h。修改数据目录表中导入表项的字段为新的RVA值，如下所示：

![image](https://github.com/YangLuchao/img_host/raw/master/20230911/image.5o3efa0ixho0.webp)

导入表转移到代码段后程序依旧可以很好地运行。

# 4.7　小结

==本章首先分析了导入函数的使用机制；然后，介绍了导入表的数据组织方式和数据结构，并通过导入表重组实验练习了导入表及其他数据的手工修改过程；同时，还详细阐述了绑定导入的机制及实例。==

==因为导入表是加壳应用时需要重点处理的一个部分，所以深入研究这部分内容具有很现实的意义。==
