[toc]

本章是全书的重点内容之一。==PE文件头记录了PE文件中的所有数据的组织方式，它类似于一本书的目录，通过目录我们可以快速定位到某个具体的章节；通过PE文件头部分对某些数据结构的描述，我们也可以定位到那些不在文件头部的信息，比如导入表数据、导出表数据、资源表数据等==。

由于本章涉及PE文件头部的数据结构中大量字段的描述和说明，因此阅读起来会稍显枯燥，但是，在后续的章节中会经常用到本章的内容，所以请大家认真学习。

# 3.1　PE的数据组织方式

PE的数据组织是一种数据管理技术，但笔者更愿意把它看成是一种艺术。希望读者在学习完PE格式后，不仅能把握PE格式本身，还能够从中学会==使用数据结构管理数据的方式==，当大家理解其他格式的文件（如音视频格式、数据库文件格式、图片格式等）时会有所启发。

1993年，第一个Windows NT操作系统诞生，到现在有将近18年的时间。目前，使用PE作为可执行文件格式的Windows操作系统已经更换了很多版本。对于操作系统来说，其结构的变化、新特性的添加、文件存储格式的转换，以及内核的重新定位等，都发生了翻天覆地的变化，而这些变化对PE格式的影响却不大。由于PE有较好的数据组织方式和数据管理算法，面对如此多的变化却依然能保持其一贯的优雅和优越。

简言之，PE的数据组织是大量的字节码与数据结构的有机融合。字节码是一些毫无意义的数字，而数据结构却为这些数字赋予了人类可以理解的精准含义。

以图书馆为例，假如你是图书管理员，你会怎样管理大量的图书呢？

如果你很懒，你可能会把所有的图书随意地堆放到一间屋子里，然后在门上贴上标签如“书库一”注明这是一个书库。尽管看起来很简单，但这其实也是一种管理方式。至少你没有把不相关的东西放到这间屋子里；而且你还很有心地在门上做了书库符号标记。

以上描述的书库可以用如下的几个数据结构来定义。

### 1.书库数据结构BookStore

根据汇编语言对结构的定义，可以将上面提到的书库描述为以下数据结构：

------

```assembly
BookStore STRUCT
	Name db 8 dup(0) 	;书库的名字
	Address dd ? 		;书库所在地址
	Count dd ? 			;书库中的藏书量
BookStore ENDS
```

------

以上结构中包含了书库的名称、所在的地址和书库中的藏书量。这种定义方式只是概念上的定义，在程序中还需要对该书库进行实例化，代码如下：

------

```assembly
name1 db '书库一',0
lib1 BookStore ＜?＞
mov ebx,lib1
assume ebx:ptr BookStore
invoke MemCopy,addr name1,[ebx].Name ;为书库命名
mov eax,123456h ;确定书库的位置
mov [ebx].Address,eax
mov eax,2 ;指定书库的藏量
mov [ebx].Count,eax
assume ebx:nothing
```

------

如上所示，通过定义变量lib1，实例化一个BookStore结构，然后通过赋值语句为该结构中的每个字段指定不同的值。

### 2.书库的字节码

在书库结构中有一个字段为BookStore.Address，这个字段是一个地址，这里暂时将这个地址指向的对象称作书库的字节码。书库的字节码对应这个书库本身，与具体的书没有任何关系，假设由地址123456h来标识（你可以把这个地址理解为12号街34号门5单元6号房间）。

数据结构和字节码都定义好了以后，管理员的日常工作也就明确了：找到书库的位置，知道里面共有多少本书，就这么简单。

以上这种数据组织方式可以用图3-1来表示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230725/image.6iqlaf0on580.webp)

图　3-1　书库一的数据组织

因为书库管理不够细化，所以该管理员经常会找不到借阅者急需的书籍，于是这个管理员就在某天丢了工作。新来的管理员对书库里杂乱无章的书进行了排架，并按照中图法[[1\]](file:///Applications/Koodo Reader.app/Contents/Resources/app.asar/build/part0033.xhtml#ch1-back)对每本书进行了分类。这就引出了“书的数据结构”这个概念。

### 3.书的数据结构Book

新的管理员将工作所涉及的对象抽象为BookStore和Book两个结构的组合。在程序员眼睛里，新书库的数据组织方式可用如下数据结构表示：

------

```assembly
;书库的定义：
BookStore STRUCT
	Name db 8 dup(0) 	;书库的名字
	Address dd ? 		;书库所在地址
	Count dd ? 			;书库中的藏书量
BookStore ENDS
;书的定义：
Book STRUCT
	Name db 50 dup(0) 	;书的名字
	Contents dd ? 		;书字节码所在地址
Book ENDS
```

------

将以上数据结构中的概念实例化的代码如下：

------

```assembly
name1 db '书库一',0
name2 db '《Windows PE权威指南》',0
lib1 BookStore ＜?＞
book1 Book ＜?＞
book2 Book ＜?＞
bookArray 	dd offset book1 ;指向第一本书
			dd offset book2 ;指向第二本书
			dd 0 ;结束
assume ebx:ptr Book
invoke MemCopy,addr name1,[ebx].Name ;为书命名
mov eax,234567h ;确定书字节码的位置
mov [ebx].Address,eax
assume ebx:nothing

...... ;此处省略了对book2的定义

mov ebx,lib1
assume ebx:ptr BookStore
invoke MemCopy,addr name1,[ebx].Name ;为书库命名
mov eax,offset bookArray ;确定书库的位置
mov [ebx].Address,eax
mov eax,2 ;指定书库的藏书量
mov [ebx].Count,eax
assume ebx:nothing
```

------

当我们增加了书的结构定义后，书库一中的Address就有了一个明确的含义。它指向了地址数组bookArray的起始位置，该数组中的每个地址都是一个指向Book的双字地址。从这个意义上讲，bookArray是书库一的字节码。

### 4.书的字节码

在前面实例中，书的字节码已经具体到了每一本书，可以把它理解为书所在书架的位置，也可以理解为书的内容。这里假设地址234567h指向了《Windows PE权威指南》一书的字节码。

现在，对这个新的管理员而言，不仅能立刻找到书库，还能找到具体要找的书。所以，这个管理员的工作效率就提高了不少。

新的数据组织方式可以用图3-2来表示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230725/image.60nxvu3jt0g0.webp)

图　3-2　新的书库数据组织

不知不觉中，笔者用面向对象的知识为大家介绍了数据组织的常见方法。在上述案例中，数据结构BookStore和Book均为类（暂时未添加方法的类），而针对该数据结构的每个实例都是一个对象。

PE文件结构基本采用了类似的组织方式。在后续章节的学习过程中，你会看到很多类似的结构。如第10章，加载配置数据的数据结构定义为：

------

```assembly
IMAGE_LOAD_CONFIG_DIRECTORY STRUCT
	Characteristics dd ? ;0000h-加载配置属性，一般为48h
	......
	SecurityCookie dd ?
	SEHandlerTable dd ? ;0040h-指向安全SEH异常处理函数列表
	SEHandlerCount dd ? ;0044h-列表中安全Handler的个数
IMAGE_LOAD_CONFIG_DIRECTORY ENDS
```

------

字段SEHandlerTable指向了一个地址数组，该地址数组的个数由SEHandlerCount来定义。地址数组中的每个值都是一个相对虚拟内存地址（RVA），它指向了结构化异常处理函数字节码，加载配置数据的大致组织方式如图3-3所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230725/image.3m4qj8kxe820.webp)

图　3-3　加载配置信息中的数据组织示意图

可以简单地套用Windows操作系统管理文件的组织方式：目录类似于这里的BookStore，文件类似于这里的Book，而文件存储在硬盘上的字节码为Book的字节码。也可以用其他任意一种文件格式来分析，大部分文件格式的数据组织方式基本上是一样的。笔者将这种信息组织方式称为“头部+身体”。

[[1\]](file:///Applications/Koodo Reader.app/Contents/Resources/app.asar/build/part0033.xhtml#ch1)中图法即中国图书分类办法。——编者注

# 3.2　与PE有关的基本概念

在详细了解PE文件结构以前，先学习几个基本的概念。理解这些概念有利于我们更好地把握和分析PE中的数据结构。

## 3.2.1　地址

PE中涉及的地址有四类，它们分别是：

- ==虚拟内存地址（VA）==
- ==相对虚拟内存地址（RVA）==
- ==文件偏移地址（FOA）==
- ==特殊地址==

要想了解这些概念，需要先简单地了解一下32位环境下Windows对内存的管理，以及分页机制的原理。

> 扩展阅读　32位环境下的Windows内存管理
>
> 32位CPU的寻址能力为4GB（即232个字节），但有些用户的物理内存达不到这个值。于是操作系统和CPU的内存管理单元共同作用，为用户提供了虚拟内存的管理机制。即分页机制。该机制可以让用户感觉自己好像在使用4GB的内存。
>
> 分页机制的基本原理是：
>
> 操作系统假设一个进程独立拥有4GB内存，按照某个固定的大小（如4KB）将这4GB空间分成N（1M）个页。在某一时刻，所有这些页只有一部分和物理内存是对应的（所以这种机制允许物理内存比4GB小）。没有物理内存对应的页面被标记为脏（dirty）的页面，一般存储在一个名为“交换文件”的磁盘文件中。在Windows XP系统中，交换文件为pagefile.sys，它位于系统盘的根目录，是一个系统隐藏文件。当系统需要读取未在内存中的数据时，这部分数据会将内存中不经常读写的页交换出内存，而把要读取的、位于交换文件中的页换进内存。
>
> 通过这种存取机制可以让一个进程拥有比实际内存大得多的内存。利用这种机制管理的内存称为虚拟内存。

#### 1.虚拟内存地址

==用户的PE文件被操作系统加载进内存后，PE对应的进程支配了自己独立的4GB虚拟空间。在这个空间中定位的地址称为虚拟内存地址（Virtual Address，VA），所以虚拟内存地址的范围是00000000h～0ffffffffh。在PE中，进程本身的VA被解释为：进程的基地址+相对虚拟内存地址。==

#### 2.相对虚拟内存地址

==一个进程被操作系统加载到虚拟内存空间后，其相关的动态链接库也会被加载。这些同时加载到进程地址空间的文件称为模块。每一个模块在加载时都会有一个基地址，也就是预先告诉操作系统：它会占用4GB空间的哪个部分（即从哪里开始存储该模块）。不同模块的基地址一般是不同的，如果两个模块的基地址相同，就由操作系统来决定这两个模块在虚拟空间中的具体位置。==

==相对虚拟内存地址（Reverse Virtual Address，RVA）是相对于基地址的偏移，即RVA是虚拟内存中用来定位某个特定位置的地址，该地址的值是这个特定位置距离某个模块基地址的偏移量，所以说RVA是针对某个模块而存在的==。

关于VA和RVA的概念，可以用图3-4来表示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230725/image.sbigtbthgq8.webp)

图　3-4　内存地址示意图

如图3-4所示，假设模块2的基地址为0x01000000，而模块2中的某个位置距离模块2的基地址偏移为400h，那么值0x00000400就是模块2中某个位置的RVA，而值0x01000400是该位置的VA。==记住，RVA是相对于模块而言的，VA是相对于整个地址空间而言的==。

注意　RVA与具体模块相关，它有一个范围，该范围从模块的开始到模块结束，脱离开这个范围的RVA是无效的，称为越界。越界的RVA地址没有任何意义。

#### 3.文件偏移地址

==文件偏移地址（File Offset Address，FOA）和内存无关，它是指某个位置距离文件头的偏移。==

#### 4.特殊地址

在PE结构中还有一种特殊地址，其计算方法并不是从文件头算起，也不是从内存的某个模块的基地址算起，而是从某个特定的位置算起。这种地址在PE结构中很少见，如在资源表里就出现过这样的地址。

## 3.2.2　指针

==PE数据结构中的指针的定义：如果数据结构中某个字段存储的值为一个地址，那么这个字段就是一个指针。==

例如，在3.1节数据组织方式的实例中，BookStore.Address是一个指针，Book.Address也是一个指针。有时候，你还会遇到一个指针指向了另一个指针的情况。比如，在第10章中，加载配置信息中的数据结构加载配置目录（IMAGE_LOAD_CONFIG_DIRECOTRY）的字段SEHandlerTable的值是一个VA，但该指针所指的位置是一个RVA，该RVA指向了安全的SEH处理函数的Handler。所以，在数据结构中，可能会碰到指针和地址交错使用的情况，大家需要引起重视。

## 3.2.3　数据目录

Windows下的可执行文件是PE中的一种，这种文件中除了包含代码及数据段的相关数据以外，还包含许多与文件执行有关的其他数据，比如引用外部函数的信息、PE程序的图标、内部导出函数等，这些数据可能会随着操作系统新特性的出现而增加。

==PE中有一个数据结构称为数据目录，其中记录了所有可能的数据类型==。这些类型中，目前已定义的有15种，包括==导出表、导入表、资源表、异常表、属性证书表、重定位表、调试数据、Architecture、Global Ptr、线程局部存储、加载配置表、绑定导入表、IAT、延迟导入表和CLR运行时头部。==

## 3.2.4　节

无论是结构化程序设计，还是面向对象程序设计，都提倡程序与数据的独立性，因此，==程序中的代码和数据通常是分开存放的==。为了保证程序执行的安全，保障内核的稳定，Windows操作系统通常对不同用途的数据设置不同的访问权限。比如，代码段中的字节码在程序运行的时候，一般不允许用户进行修改，数据段则允许在程序运行过程中读和写，常量只能读等。Windows操作系统在加载可执行程序时，会为这些具有不同属性的数据分别分配标记有不同属性的页面（当然，相同属性的数据可能会被放到同一个页面中），以确保程序运行时的安全。正是基于这个原因，PE中才出现了所谓的节的概念。

==节就是存放不同类型数据（比如代码、数据、常量、资源等）的地方，不同的节具有不同的访问权限。节是PE文件中存放代码或数据的基本单元==。例如，一个目标文件中的所有代码可以组合成单个节，或者每个函数独占一个节（如果编译器行为允许）。增加节的数目会增加文件开销，但是链接器在链接代码时会有更大的选择余地。一个节中的所有原始数据必须被加载到连续的内存空间中。

从操作系统加载角度来看，节是相同属性数据的组合。与数据目录不同的是，尽管有些数据类型不同，分别属于不同的数据目录，但由于其访问属性相同，便被归类到同一个节中。这个节最终可能会占用一个或多个页面；但无论有多少个，==所有相关页面均会被赋予相同的页属性。这些属性包括只读、只写、可读、可写等==。

汇编语言中以“.”开头的一些伪指令其实就是在声明不同的数据类型。比如".data"声明的是初始化的数据，".data?"声明的是未初始化的数据，".code"声明的是可执行的代码等。Windows操作系统在装载PE文件时会对这些数据执行抛弃、合并、新增、复制等操作。这些不同的操作交叉组合导致了内存中的节和文件中的节会出现很大的不同。例如".data?"的数据在磁盘中不存在，但在内存中存在，而".reloc"重定位表数据却恰恰相反。

## 3.2.5　对齐

对齐这个概念并非只在PE结构中出现，许多文件格式都会有对齐的要求。有的对齐是为了美观，有的对齐则是为了效率。==PE中规定了三类对齐：数据在内存中的对齐、数据在文件中的对齐、资源文件中资源数据的对齐。==

#### 1.内存对齐

由于Windows操作系统对内存属性的设置以页为单位，所以==通常情况下，节在内存中的对齐单位必须至少是一个页的大小。对32位的Windows XP系统来说，这个值是4KB（1000h），而对于64位操作系统来说，这个值就是8KB（2000h）。==

#### 2.文件对齐

相对来说，节在磁盘文件中的对齐尺寸没有那么严格。为了提高磁盘利用率，通常情况下，定义的节在文件中的对齐单位要远小于==内存对齐的单位；通常会以一个物理扇区的大小作为对齐粒度的值，即512字节，十六进制表示为200h。这就是我们在第1章中看到数据段、代码段等起始地址都是200h的倍数的原因了。==

出于节约资源的考虑，操作系统允许节在内存和文件中的对齐尺寸不一致。这就直接造成了PE在文件中和在内存中的大小也会不一致。通常情况下，PE在内存中的尺寸要比在文件中的尺寸大。用户可以自己定义这些对齐的值。

> ==注意　如果内存对齐被定义为小于操作系统页的大小，则文件对齐和内存对齐的值必须一致！==

#### 3.资源数据对齐

资源文件中，资源字节码部分一般要求以双字（4个字节）方式对齐，在资源表部分（详见本书第7章）我们会详细讲解。

## 3.2.6　Unicode字符串

Unicode是继ASCⅡ字符编码后的另一种新型字符编码。==严格意义上讲，ASCⅡ码的每个字符使用7位表示，Unicode则使用全16位表示一个字符。Unicode字符串中的每个字符均为双字节，所以又称为宽字符串==。

由于Unicode兼容ASCⅡ字符，所以被大多数程序所支持，如Windows内核。Unicode的前128个字符码（十六进制，0x0000～0x007F）同ASCⅡ码具有同样的字节值。比如，字母"a"的Unicode编码是0x0061，而"a"的ASCⅡ编码是0x61。虽然占用的字节数不一样，但是两者的值是一样的。接下来的128个Unicode字符（代码为0x0080～0x00FF）是ISO 8859-1对ASCⅡ码的扩展。中国、日本和韩国的象形文字（总称为CJK）占用了0x3000～0x9FFF的代码。如“汉”字的Unicode编码是6C49h（其GB码为0BABAh）。

本书所有的程序都使用一个字节来表示字符串中的字符，称为ANSI字符串。PE格式中涉及字符串的部分均采用ANSI字符串。然而，在资源表中，对菜单名、对话框标题等的描述则全部使用Unicode字符串。所以，在读取这些资源的字符串时，首先需要使用一些API函数实现从宽字符集到窄字符集的转换。

==注意　Unicode字符串不像ANSI字符串那样，保证用字符“\0”结束；如果开发者在程序设计时以字符“\0”作为Unicode字符串结尾的判断条件，就可能发生错误。==

在汇编语言中，Unicode字符串被定义为一个结构体，它的定义如下：

------

```assembly
typedef struct _UNICODE_STRING{
	USHORT Length ;			//字符串的长度（字节数）
	USHORT MaximumLength ;	//字符串缓冲区的长度（字节数）
	PWSTR Buffer ;			//字符串缓冲区
}UNICODE_STRING,*PUNICODE_STRING ;
```

------

由于我们无法保证Unicode字符串结尾一定是“\0”，所以在结构体中，字段Length定义了字符串的长度。一个安全的字符串还必须限定字符的总长度，这由MaximumLength来实现。

# 3.3　PE文件结构

==PE经历了从16位系统到32位系统的过渡，因此，32位系统下的每一个PE文件都可以在16位系统下运行。尽管PE文件的结构一样，但从不同的角度来看其结构的划分却并不一样。==

## 3.3.1　16位系统下的PE结构

==DOS头部分的存在见证了PE的强大兼容性。为了保持与16位系统的兼容，在PE里依旧保留了16位系统下的标准可执行程序执行时所必需的文件头部（DOS MZ头）和指令代码（DOS Stub）。==

==在16位系统下，PE结构可以大致划分为两部分：DOS头和冗余数据==，如图3-5所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230725/image.6kzj1awtmhs0.webp)

图　3-5　16位系统下的PE结构划分

如上图所示，在16位系统下，PE的四部分内容被重新组合成两部分——可以在16位系统下运行的DOS头和冗余数据。把Windows下的PE文件存储到DOS系统并运行，它就是DOS 系统下的一个EXE文件。

DOS头分为两部分，DOS MZ头和DOS Stub（即指令字节码）。大部分情况下，这些指令实现的功能都非常简单，根本不会涉及重定位信息。再往后的PE头和PE数据区可以看做是16位系统下的可执行文件的冗余数据。

### 1.DOS MZ头

在Windows的PE格式中，DOS MZ头的定义如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.1y6b2ou2wuzk.webp)

如上所示，加粗部分在16位系统下是没有定义的。由于其开始的标志字为"MZ"（Mark Zbikowski，他是DOS操作系统的开发者之一），所以称它为“DOS MZ头”。

下面来看第1章提到的HelloWorld.exe的字节数据，HelloWorld中的DOS头如下所示：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.232r6n6q9uxs.webp)

> 注意　这部分内容在源程序HelloWorld.asm中是找不到相应的定义语句的。因为DOS MZ头部分的字节码（包括DOS Stub程序字节码）的添加是由链接程序link.exe自动实现的。
>

### 2.DOS Stub

HelloWorld.exe文件中，DOS Stub的字节码如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.6a6sjlal8480.webp)

由于DOS Stub的大小不固定，因此DOS头的大小也是不固定的。DOS Stub部分是该程序在DOS系统下运行的指令字节码。下面来分析一下DOS Stub中的这些指令都做了哪些工作。

第1章通过DOS命令输出了规则的PE文件字节码，下面还将继续使用DOS命令获取DOS Stub的反汇编代码。

首先将"HelloWorld.exe"更名为“123”，然后复制到C:\Documents and Settings\administrator中。在命令提示符下输入如下命令（加黑部分）：

------

```bash
C:\Documents and Settings\administrator＞debug 123
-U 0140 014D
```

------

反汇编后得到以下结果：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.6wh6c6hftgg0.webp)

==DOS Stub程序的功能很简单，通过调用int 21中断的9号功能，实现在屏幕输出一段字符串。这段字符串提示用户该程序为32位的PE文件，不能运行在DOS环境下。==

如果我们更改DOS Stub默认程序的功能，使其能在16位系统下运行，显示信息后再让电脑的喇叭响一下以提示用户，这样可能会更友好一些。这就要在原来的基础上增加新的代码，增加的代码大小不受限制。下面我们就按照刚才的要求修改一下DOS Stub程序。

如果大家对16位汇编语言不陌生，应该选择调用int 21中断的2号功能，就是向标准的输出设备显示一个字符，而ASCⅡ码中的7即是响铃符号。

### 扩展阅读　【2号功能调用】

**功能：向标准输出设备显示字符**

**输入参数：DL=要显示的字符**

**出口参数：无**

**中断号：21h**

响铃对应的汇编代码为：

------

```assembly
mov dl,7
mov ah,2
int 21h
```

------

打开Debug程序，输入以下命令：

------

```assembly
-a 01aa
```

------

-a命令表示在随后紧跟着的地址01aah处输入汇编代码。

接下来就是输入响铃的汇编代码（注意每行的回车），最后按Ctrl+C告诉Debug结束输入。可使用以下命令查看刚生成的字节码：

------

```assembly
-d 01aa
```

------

-d命令显示了响铃功能的字节码为B2 07 B4 02 CD 21。

整个过程如图3-6所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.o4dcgp9vhts.webp)

图　3-6　汇编响铃代码

使用FlexHex将以上字节码加入到DOS Stub中的21和B8中间，即地址13B7:0148和13B7:0149中间，然后删除24 00后（文件起始地址为0x00000080）的6个字节，并把0Eh更改为14H（知道为什么吗？因为插入的响铃代码已经把要显示的字符串的偏移地址往后移动了6个字节），最后保存。修改过程如图3-7所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.2z8htdhst4w0.webp)

图　3-7　为DOS Stub添加指令字节码

修改以后的DOS Stub汇编源代码如下所示，其中加粗部分为新增加和修改的地方：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.6v1vjpiy5v40.webp)

重新启动电脑，利用安装盘进入DOS环境，然后运行修改后的可执行程序，你就会听到喇叭“嘟”的一声。

是不是很有成就感？大家也可以自己尝试编写一些具有特殊功能的16位程序，并练习将这些程序覆盖到DOS Stub部分。

之所以说PE头和PE数据区是16位系统下的可执行文件的冗余数据，是因为这部分内容的存在与否与DOS Stub程序能否执行无关。大家可以尝试使用FlexHex打开HelloWorld.exe，将这部分冗余数据删除，然后保存文件。经过以上修改的HelloWorld.exe依然可以被系统识别并运行。

## 3.3.2　32位系统下的PE结构

==在16位系统中，PE头和PE数据部分被当成是冗余数据；在32位系统中，刚好相反，即DOS头成为冗余数据==。所谓冗余，是针对DOS头不参与32位系统运行过程而言的。尽管该部分不参与运行，但也不能把这些数据从PE结构中除去。因为在==DOS MZ头中有一个字段非常重要，即IMAGE_DOS_HEADER.e_lfanew，没有它操作系统就定位不到标准的PE头部，可执行程序也就会被操作系统认为是非法的PE映像。==

### 1.定位标准PE头

由于DOS Stub的长度不固定，导致了DOS头也不是一个固定大小的数据结构。那么，在Windows PE中，既然把DOS头放在了PE的起始位置，如何去定位后面的标准PE头所在的位置呢？字段e_lfanew即起这个作用。==该字段的值是一个相对偏移量，绝对定位时需要加上DOS MZ头的基地址。也就是说，通过以下公式可以得出PE头的绝对位置：==

```cpp
PE_start
= DOS MZ基地址 + IMAGE_DOS_HEADER.e_lfanew
= 13B7:0100 + 000000B0H
= 13B7:01B0
```

对比本书1.6节中代码清单1-2列出的HelloWorld.exe的字节码，可以看到该位置是以ASCⅡ字符"PE"开头的，所以，通过字段`IMAGE_DOS_HEADER.e_lfanew`的值可以定位到PE头的起始位置。

### 2.PE文件结构

在32位系统下，最重要的部分就是PE头和PE数据区。随着讲解的不断深入，图3-5也会被不断地细化和丰富。32位系统下的PE结构可以划分如图3-8所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.3d2q0ol7qig0.webp)

图　3-8　32位下的PE结构划分

如上图所示，32位系统下的PE文件结构被划分为5个部分，包括：

- DOS MZ头
- DOS Stub
- PE头
- 节表
- 节内容

节表和节内容两部分其实就是图3-5中所示的PE数据区。==DOS MZ头的大小是64个字节，PE头的大小是456个字节（由于数据目录表项不一定是16个，所以准确地说，PE头也是一个不能确定大小的结构，该结构的实际大小由字段IMAGE_FILE_HEADER.SizeOfOptionalHeader来确定）==。==节表的大小之所以不固定，是因为每个PE中节的数量是不固定的==。==每个节的描述信息则是个固定值，共40个字节，节表是由不确定数量的节描述信息组成的，其大小等于节的数量×40，节的数量由字段IMAGE_FILE_HEADER.NumberOfSections来定义==。DOS Stub和节内容都是大小不确定的。

节表是PE中所有节的目录，每个目录都是一个"BookStore"，其字节码就是节内容。它按照目录里的指针指向的地址，分别将节的字节码在文件空间中排列起来，从而组成了一个完整的PE文件。PE文件头部等于DOS头+PE头。

## 3.3.3　程序员眼中的PE结构

在程序员眼中，PE文件格式是由许多数据结构组成的，数据结构是一系列有组织的数据的集合，如图3-9所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.9yiv93abgqg.webp)

图　3-9　程序员眼中的PE结构

如图所示，一个标准的PE文件一般由四大部分组成：

- DOS头
- PE头（IMAGE_NT_HEADERS）
- 节表（多个IMAGE_SECTION_HEADER结构）
- 节内容

其中，PE头的数据结构最为复杂。简单来说，PE头包含：

- 4个字节的标识符号（Signature）
- 20个字节的基本头信息（IMAGE_FILE_HEADER）
- 216个字节的扩展头信息（IMAGE_OPTIONAL_HEADER32）

> 说明　如果按照“头部+身体”的信息组织方式来看：
>
> - PE文件头部=DOS头+PE头+节表
> - PE文件身体=节内容

==节内容中会出现各种不同的数据结构，如导入表、导出表、资源表、重定位表==等，关于这些数据的组织方式会在后面的章节中陆续接触到。

# 3.4　PE文件头部解析

本节将按照图3-9所示的PE结构，对PE文件头部的各部分数据结构进行声明。这些数据结构将是大家以后学习Windows PE知识需要经常参考和使用的。

## 3.4.1　DOS MZ头IMAGE_DOS_HEADER

该数据结构在3.3.1节已有描述，为了保持完整性，这里再重复一次。IMAGE_DOS_HEADER的具体定义如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.6k3tn3c0jrc0.webp)

> 注意　注释后的偏移是基于IMAGE_DOS_HEADER头的。

DOS MZ头的下面是DOS Stub。整个DOS Stub是一个字节块，其内容随着链接时使用的链接器不同而不同，PE中并没有与之对应的相关结构。

## 3.4.2　PE头标识Signature

==紧跟在DOS Stub后面的是PE头标识Signature==。与大部分文件格式的头部结构一样，PE头部信息中有一个四字节的标识，该标识位于指针IMAGE_DOS_HEADER.e_lfanew指向的位置。==其内容固定，对应于ASCⅡ码的字符串"PE\0\0"==。

## 3.4.3　标准PE头IMAGE_FILE_HEADER

==标准PE头IMAGE_FILE_HEADER紧跟在PE头标识后，即位于IMAGE_DOS_HEADER的e_lfanew值+4的位置==。==由此位置开始的20个字节为数据结构标准PE头IMAGE_FILE_HEADER的内容==。该结构在微软的官方文档中被称为标准通用对象文件格式（Common Object File Format，COFF）头。==它记录了PE文件的全局属性，如该PE文件运行的平台、PE文件类型（是EXE文件还是DLL文件）、文件中存在的节的总数==等，其详细定义如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.35cnrvorhke0.webp)

==该结构常用于判断PE文件是EXE类型还是DLL类型，不但可以通过该结构得到PE文件中节的总量，还可以当成对节区信息进行遍历操作时的循环次数。==

> 注意　注释后的偏移是基于IMAGE_NT_HEADERS头的。

> 提示　为了不分散大家的注意力，这里只讲一些主要的知识点，而把各字段的详细解释放到本章的第3.5节，便于大家先从整体上把握PE文件结构。

## 3.4.4　扩展PE头IMAGE_OPTIONAL_HEADER32

尽管从名字上看好像该部分数据是可选（optional）的，但在PE文件结构中，它却有着比标准PE头更多的内容，让人感觉似乎它才是真正的PE头。其详细定义如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.4j7r9xh6x7c0.webp)

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.x5eexcpvta8.webp)

> 注意　注释后的偏移是基于IMAGE_NT_HEADERS头的。

文件执行时的入口地址、文件被操作系统装入内存后的默认基地址，以及节在磁盘和内存中的对齐单位等信息均可以在此结构中找到。对该结构中的某些数值的随意改动可能会造成PE文件的加载或运行失败。

#### 3.4.5　PE头IMAGE_NT_HEADERS

==这个结构是广义上的PE头，在标准的PE文件中其大小为456个字节==。它是3.4.2节、3.4.3节和3.4.4节中提到的三个数据结构的组合，即IMAGE_NT_HEADERS=4个字节的PE标识+IMAGE_FILE_HEADER+IMAGE_OPTIONAL_HEADER32，如图3-10所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.29p8ghl1kk74.webp)

图　3-10　PE头结构

该结构的详细定义如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.vtxv7x6ogg0.webp)

与DOS头一样，PE头开始也是一个标志，用一个双字的"PE\0\0"来命名，这也是PE头的由来。

## 3.4.6　数据目录项IMAGE_DATA_DIRECTORY

==IMAGE_OPTIONAL_HEADER32（扩展PE头）结构的最后一个字段为DataDirectory。该字段定义了PE文件中出现的所有不同类型的数据的目录信息。==如前所述，应用程序中的数据被按照用途分成很多种类，如导出表、导入表、资源、重定位表等。==在内存中，这些数据被操作系统以页为单位组织起来，并赋以不同的访问属性==；==在文件中，这些数据也同样被组织起来，按照不同类别分别存放在文件的指定位置==。该结构就是用来描述这些不同类别的数据在文件（和内存）中的位置及大小的，因为这个字段比较重要，尽管它与本章其他小节列出的数据结构不在一个层次上，但此处也作为单独的一节来讲。

从Windows NT 3.1操作系统开始到现在，该数据目录中定义的数据类型一直是16种。==PE中使用了一种称作“数据目录项IMAGE_DATA_DIRECTORY”的数据结构来定义每种数据==。该结构只有两个字段，结构具体定义如下：

------

```assembly
IMAGE_DATA_DIRECTORY STRUCT
	VirtualAddress DWORD ? 		;0000h-数据的起始RVA
	isize DWORD ? 				;0004h-数据块的长度
IMAGE_DATA_DIRECTORY ENDS
```



------

两个字段依次为VirtualAddress和isize。如图3-11所示，总的数据目录一共由16个相同的IMAGE_DATA_DIRECTORY结构连续排列在一起组成。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.1fr1y41in4yo.webp)

图　3-11　数据目录结构示意图

这16个元组的数组每一项均代表PE中的某一个类型的数据，各数据类型详见表3-1。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.1r7m9ab8rr6o.webp)

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.6b6j9sa5h600.webp)

如图3-11所示，==如果想在PE文件中寻找特定类型的数据，就需要从该结构开始==。比如，要想查看PE中都调用了哪些动态链接库的函数，则需要从数据目录表的第2个元素（数组编号为1）的IMAGE_DATA_DIRECTORY结构获取导入表在文件中的起始位置和大小，然后再根据VirtualAddress_1地址指向的位置找到导入表相关的字节码。这种信息组织方式正是本章最开始介绍的“头部+身体”的数据组织方式。

下面是将这16个数据目录项依次展开后的新结构：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.36i43ezvvh80.webp)

> 注意　以上结构在PE中并不存在，这里介绍主要是为了以后编程时可作为参考，当然，你也可以使用该结构覆盖字段IMAGE_OPTIONAL_HEADER32.DataDirectory。另外要注意的是，该虚拟结构每个字段后的偏移是基于IMAGE_NT_HEADERS头的。

## 3.4.7　节表项IMAGE_SECTION_HEADER

==PE头IMAGE_NT_HEADERS后紧跟着节表。它由许多个节表项（IMAGE_SECTION_HEADER）组成，每个节表项记录了PE中与某个特定的节有关的信息，如节的属性、节的大小、在文件和内存中的起始位置等。==节表中节的数量由字段IMAGE_FILE_HEADER.NumberOfSections来定义。节表项的数据结构详细定义如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.27a3e7px0o4k.webp)

> 注意　注释后的偏移是基于IMAGE_SECTION_HEADER头的。

节表后面就是节的内容。截至节表，PE文件头部涉及的所有数据结构已经全部介绍完毕。接下来，我们将集中对以上所列数据结构中的每个字段进行详细介绍。

# 3.5　数据结构字段详解

本节将对数据结构中的每一个字段[[1\]](file:///Applications/Koodo Reader.app/Contents/Resources/app.asar/build/part0050.xhtml#ch1-back)进行注解。需要说明的是，由于Windows操作系统并不开源，所以有些字段即使从官方资料中也无从查找，所以这些字段会被略过；另外，Windows操作系统是一个随时在变化的系统，有些字段会因为系统添加的新特性而发生含义上的改变。这里对所有的字段的解释均参照微软官方网站于2010年9月21日发布的Microsoft Portable Executable and Common Object File Format Specifcation（Revision v8.2）文档。

## 3.5.1　PE头IMAGE_NT_HEADER的字段

#### 1.IMAGE_NT_HEADER.Signature

==+0000h，双字。PE文件标识，被定义为00004550h。也就是"P"，"E"加上两个0，这也是PE这个称呼的由来==。如果更改其中的任何一个字节，操作系统就无法把该文件识别为正确的PE文件。通过修改这个字段，会导致PE文件在32位系统中加载失败，但由于文件的其他部分（特别是DOS头）并没有被破坏，系统还是可以识别出其为DOS系统下的可执行程序，并通过调用纯DOS环境来运行DOS Stub中的程序代码。

如果你确认操作系统中的某个PE文件携带病毒，并且开机后会被加载进内存运行，最简单的处理办法是通过Windows PE盘启动系统。在系统中找到病毒文件，使用记事本简单地修改其中任何一个字符，保存文件，重新开机启动后即可防止病毒文件被加载。

> 注意　此PE非彼PE，Windows PE是一个操作系统，其全称为：Windows PreInstallation Environment，即Windows的预安装环境。该操作系统区别于Windows XP/2000/Vista等，可以从光盘引导。
>

#### 2.IMAGE_NT_HEADER.FileHeader

+0004h，结构。该结构指向IMAGE_FILE_HEADER，由于PE扩展自通用COFF规范，所以，该字段在官方文档中被称为标准COFF头。

#### 3.IMAGE_NT_HEADER.OptionalHeader

+0018h，结构。该结构指向IMAGE_OPTIONAL_HEADER32。Windows操作系统可执行文件的大部分特性均在这个结构里呈现。因为在符合COFF规范的".obj"目标文件中该部分并不存在，所以该部分被称为OptionalHeader（可选的头部信息，简称“可选头”），它是操作系统映像文件所独有的头部信息。

==可选头又分为两部分，前10个字段原属于COFF，用来加载和运行一个可执行文件；后21个字段则是通过链接器追加的。它们作为PE扩展的部分，用于描述可执行文件的一些信息，供PE加载器加载使用==。

> [[1\]](file:///Applications/Koodo Reader.app/Contents/Resources/app.asar/build/part0050.xhtml#ch1)这些字段将分别在不同的章节中介绍，编号是连续的1、2、3……

## 3.5.2　标准PE头IAMGE_FILE_HEADER的字段

#### 4.IMAGE_FILE_HEADER.Machine

==+0004h，单字。用来指定PE文件运行的平台==。由于Windows最初被设计为可以运行在Intel、Sun、Dec、IBM等多种硬件平台上，或者能模拟这些平台的软件环境中，而不同的硬件平台其指令的机器码不相同，因此为不同平台编译的EXE文件是无法通用的。假设将运行在Intel 386机器上的PE文件的该字段设置为01f0h，即指定平台为IBM POWER PC（小尾方式），则系统会有如图3-12所示的提示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.2cpjmrtxqp34.webp)

图　3-12　文件运行平台指定错误后的提示

如果使用汇编语言，可以通过如下的伪指令代码对平台进行定义：

------

```assembly
.386
```

------

如上所示，表示指令要运行在Intel 386平台上。该字段预定义的值如表3-2所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.4te54bi12po0.webp)

#### 5.IMAGE_FILE_HEADER.NumberOfSections

+0006h，单字。==文件中存在的节的总数==。在Windows XP中，可以有0个节，但数值不能小于1（在第12章大家会接触到只有一个节的PE文件HelloWorld_7.exe和没有节的PE文件miniPE.exe），也不能超过96。如果将该值设置为0，则操作系统装载时会提示不是有效的Win32程序。如果想在PE中增加或删除节，必须变更此处的值。

另外，==这个值既不能比实际内存中存在的节多，也不能比它少，否则装载时会发生错误，提示不是有效的Win32应用程序==。

#### 6.IMAGE_FILE_HEADER.TimeDateStamp

+0008h，双字。==编译器创建此文件时的时间戳==。低32位存放的值是自1970年1月1日00:00时开始到创建时间为止的总秒数。

该数值可以随意修改而不会影响程序运行。所以，有的链接器在这里填入固定的值，有的则随意写入任何值，这对用户创建的文件并没有实际的意义。另外，这个时间值与操作系统文件属性里看到的三个时间（创建时间、修改时间、访问时间）也没有任何联系。

#### 7.IMAGE_FILE_HEADER.PointerToSymbolTable

+000Ch，双字。==COFF符号表的文件偏移。如果不存在COFF符号表，此值为0==。对于映像文件来说，此值为0，因为微软已经不赞成在PE中使用COFF调试信息了。

#### 8.IMAGE_FILE_HEADER.NumberOfSymbols

+0010h，双字。==符号表中元素的数目。由于字符串表紧跟在符号表后，所以可以利用这个值来定位字符串表==。对于映像文件来说，此值为0，主要用于调试。

#### 9.IMAGE_FILE_HEADER.SizeOfOptionalHeader

+0014h。单字。==指定结构IMAGE_OPTIONAL_HEADER32的长度，默认情况下这个值等于00e0h；如果是64位PE文件，该结构的默认大小为00F0h==。

用户可以自己定义这个值的大小，不过需要注意两点：

1. 更改完以后，需要自行将文件中IMAGE_OPITONAL_HEADER32的大小扩充为你指定的值（一般以0补足）。
2. 扩充完以后，要维持文件中的对齐特性（比如在HelloWorld.exe中，此处增加了8个字节后，一定在后面相应地删除8个字节，以保证.text节起始位置处于0400h）。

#### 10.IMAGE_FILE_HEADER.Characteristics

+0016h，单字。==文件属性标志字段，它的不同数据位定义了不同的文件属性==，具体内容见表3-3。==这是一个很重要的字段，不同的定义将影响系统对文件的装入方式==。比如，当位13为1时，表示这是一个DLL文件，那么系统将使用调用DLL入口函数的方式执行文件入口函数；当位13为0时，表示这是一个普通的可执行文件，系统直接跳到入口处执行。对于普通的可执行PE文件来说，这个字段的值一般是010fh，而对于DLL文件来说，这个字段的值一般是210eh。

如表3-3所示，==当第0位为1时，表明此文件不包含基址重定位信息，因此必须将其加载到文件头中指定的基地址字段位置。如果进程空间此处的基地址被占用，加载器会报错。在程序运行前如果发现文件中存在可重定位信息，链接器会执行移除可执行文件中的重定位信息的操作==。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.sl2axan6scw.webp)

当第1位为1时，表明此映像文件是合法的，可以运行。如果未设置此标志，表明出现了链接器错误。

当第7位为1时，表示文件为小尾方式，即内存中，最低有效位LSB位于最高有效位MSB的前面，与第15位的大尾方式（MSB在前，LSB在后）一样，都不赞成使用该标志，最好将其设置为0。

当第10位为1时，如果此映像文件在可移动存储介质上，那么加载器将完全加载它并把它复制到内存交换文件中。

当第11位为1时，如果此映像文件在网络上，那么加载器也将完全加载它并把它复制到内存交换文件中。

当第13位为1时，==表明此映像文件是动态链接库（DLL）。这样的文件总被认为是可执行文件，尽管它们并不能直接运行==。

可执行文件的标志位设置为010fh，即第0、1、2、3、8位分别被设置为1（如下所示），表示该文件为可执行文件，不含重定位信息，不含符号和行号信息，文件只在32位平台运行。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.5hhevgzdl9s0.webp)

## 3.5.3　扩展PE头IMAGE_OPTIONAL_HEADER32的字段

#### 11.IMAGE_OPTIONAL_HEADER32.Magic

+0018h，单字。==魔术字，说明文件的类型，如果为010BH，则表示该文件为PE32；如果为0107h，则表示文件为ROM映像；如果为020BH，则表示该文件为PE32+，即64位下的PE文件==。

#### 12、13.IMAGE_OPTIONAL_HEADER32.MinorLinkerVersion

+001ah，单字。这两个字段都是字节型，指定链接器版本号，对执行没有任何影响。

#### 14.IMAGE_OPTIONAL_HEADER32.SizeOfCode

+001ch，双字。==所有代码节的总和（以字节计算），该大小是基于文件对齐后的大小，而非内存对齐后的大小==。稍后还会介绍一个字段SizeOfImage，它是基于内存对齐后的大小。需要注意一点：==判断某个节是否包含代码的方法不是根据节的属性中是否含有IMAGE_SCN_MEM_EXECUTE标志，而是根据节的属性中是否含有IMAGE_SCN_CNT_CODE标志==。

#### 15.IMAGE_OPTIONAL_HEADER32.SizeOfInitializedData

+0020h，双字。==所有包含已经初始化的数据的节的总大小==。

#### 16.IMAGE_OPTIONAL_HEADER32.SizeOfUninitializedData

+0024h，双字。==所有包含未初始化的数据的节的总大小。这些数据被定义为未初始化，在文件中不占用空间；但在被加载到内存以后，PE加载程序应该为这些数据分配适当大小的虚拟地址空间。==

#### 17.IMAGE_OPTIONAL_HEADER32.AddressOfEntryPoint

+0028h，双字。在Windows中，可执行程序运行在虚拟地址空间中，由于4GB空间对于程序是唯一的，所以这里的虚拟空间可以简单地理解为真实的地址（我们暂且忘记物理内存地址的概念，这样就不需要理解页面调度机制了）。==该字段的值是一个RVA，它记录了启动代码距离该PE加载后的起始位置到底有多少个字节==。

==如果在一个可执行文件中附加了一段自己的代码，并且想让这段代码首先被执行，一般都要修改这里的值使之指向自己的代码位置。对于一般程序映像来说，它就是启动地址；====对于设备驱动程序来说，它是初始化函数的地址==。==入口点对于DLL来说是可选的，如果不存在入口点，这个字段必须设置为0==。

> 注意　许多病毒程序、加密程序、补丁程序都会劫持这里的值，使其指向其他用途的代码地址。

#### 18.IMAGE_OPTIONAL_HEADER32.BaseOfCode

+002Ch，双字。==代码节的起始RVA，表示映像被加载进内存时代码节的开头相对于映像基址的偏移地址。一般情况下，代码节紧跟在PE头部后面，节的名称通常为".text"。==

#### 19.IMAGE_OPTIONAL_HEADER32.BaseOfData

+0030h，双字。==数据节的起始RVA，表示映像被加载进内存时数据节的开头相对于映像基地址的偏移地址。一般情况下，数据节位于文件末尾，节的名称通常为".data"。==

#### 20.IMAGE_OPTIONAL_HEADER32.ImageBase

+0034h，双字。==该字段指出了PE映像的优先装入地址。也就是在IMAGE_OPTIONAL_HEADER32.AddressOfEntryPoint中说的程序被加载到内存后的起始VA==。那么为什么要设置这个地址呢？因为链接器在产生可执行文件的时候，是对应这个地址来生成机器码的。如果操作系统也是按照这个地址加载机器码到内存中，那么指令中的许多重定位信息就不需要修改了，这样运行速度就会更快一些。

前面说过，==对于EXE文件来说，每个文件使用的都是独立的虚拟地址空间，所以，优先装入的地址通常不会被其他模块占据。也就是说，EXE文件总是能按照这个地址装入，这就意味着装入后的EXE文件不需要进行重定位了==，例如，在HelloWorld.exe中就看不到重定位信息。

在链接的时候，可以使用参数"-base"来指定优先装入的地址，==如果不指定，那么链接器默认装入EXE的地址就是0x00400000。而相对于DLL文件来说，它默认优先装入地址则是0x10000000==。如果一个进程用到了多个DLL文件，其装入地址可能会发生冲突。PE加载器会调整其中的地址，使所有的DLL文件都能被正确装入。所以，不要错误地认为内存中动态链接库的基地址和其文件头字段IAMGE_OPTIONAL_HEADER32.ImageBase指定的完全一样。

你可以自己定义这个值，但取值有限制：第一，取值不能超出边界，即取的值必须在进程地址空间中；第二，该值必须是64KB的整数倍。

#### 21.IMAGE_OPTIONAL_HEADER32.SectionAlignment

+0038h，双字。==内存中节的对齐粒度，该字段指定了节被装入内存后的对齐单位==。为什么要对齐？不对齐的数据可以节省空间（因为对齐的数据要用0填充补齐），但没有规律，而且在运行时需要从磁盘文件调入内存分页时容易导致效率低下。大家应该学习过汇编，知道为什么在16位汇编里取数时要从偶地址开始吗？（取一个字从偶地址开始，只需要一个CPU周期可以取到；而从奇地址取一个字，则需要两个CPU周期。）==其实，对齐和它是一个道理，内存中的数据存取以页面为单位。Win32的页面大小是4KB，所以Win32 PE中节的内存对齐粒度一般都选择4KB大小。十六进制表示为01000h。==

==SectionAlignment必须大于或等于FileAlignment。当它小于系统页面大小时，必须保证SectionAlignment和FileAlignment相等==。

#### 22.IMAGE_OPTIONAL_HEADER32.FileAlignment

+003ch，双字。==文件中节的对齐粒度。文件中的节对齐并不是提高本身代码的执行效率，同样也是为了提高文件从磁盘加载的效率==。Windows XP用来组织硬盘的所有文件系统都是基于簇（分配单元）的，每个簇包含几个物理扇区。扇区是磁盘物理存取的最小单位。簇越大，磁盘存储信息的容量就越大，但存取所花费的时间也越长。通常情况下，Windows会选择使用512字节的簇大小（一个物理扇区的大小）来格式化分区，最大可以达到4KB。在本书的例子中，文件对齐粒度选择了512字节，十六进制表示为200h。

> 小技巧　如何查看当前系统的簇及扇区大小
>
> 方法一：在磁盘上创建一个10个字节的文件，然后查看文件属性，其中占用空间显示的就是簇大小。
>
> 方法二：使用命令fsutil.exe。
>
> ------
>
> C:\Documents and Settings\Administrator＞fsutil fsinfo ntfsinfo c:
>
> ------
>
> 以下为命令执行以后显示的结果，其中就包含了当前系统的簇及扇区大小。
>
> ![image](https://raw.githubusercontent.com/YangLuchao/img_host/master/20230901/image.7kva0d014ug0.webp)

#### 23、24.IMAGE_OPTIONAL_HEADER32.MinorOperatingSystemVersion

+0040h，==23和24标注的两个字段都为单字，共计为双字。标识操作系统的版本号，分为主版本号和次版本号两部分==。

#### 25.IMAGE_OPTIONAL_HEADER32.MajorImageVersion

+0044h，双字。==本PE文件映像的版本号。==

#### 27.IMAGE_OPTIONAL_HEADER32.MajorSubsystemVersion

+0048h，双字。==运行所需要的子系统的版本号。==

#### 29.IMAGE_OPTIONAL_HEADER32.Win32VersionValue

+004ch，双字。==子系统版本的值，暂时保留未用，必须设置为0==。比如将此处的值更改为696C6971h，程序运行将失败，提示信息如图3-13所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.bfsjwvko5a8.webp)

图　3-13　更改Win32VersionValue导致运行失败

#### 30.IMAGE_OPTIONAL_HEADER32.SizeOfImage

+0050h，双字。==内存中整个PE文件的映射尺寸==。以加载到内存中的HelloWorld.exe为例,HelloWorld.exe中文件头占用了1000h字节，三个节各占用1000h字节，所以文件在内存中占用的空间总共大小为04000h。该值可以比实际的值大，但不能比它小，而且==必须保证该值是SectionAlignment的整数倍==。

#### 31.IMAGE_OPTIONAL_HEADER32.SizeOfHeaders

+0054h，双字。==所有头+节表按照文件对齐粒度对齐后的大小（即含补足的0）==，HelloWorld.exe中的值为0400h。==在PE文件中，该部分数据是严格按照200h对齐的，如果不对齐，系统在加载时会提示出错==。

#### 32.IMAGE_OPTIONAL_HEADER32.CheckSum

+0058h，双字。==校验和，在大多数的PE文件中，该值是0，但在一些内核模式的驱动程序和系统DLL中，该值则是必须存在且是正确的，比如kernel32.dll中PE的校验和是0011E97Eh==。Windows系统目录下有一个动态链接库IMAGEHLP.DLL，它是Win32中专门用来操作PE文件的函数库，这里面的函数CheckSumMappedFile就是用来计算文件头校验和的，对于整个PE文件也有一个校验和函数MapFileAndCheckSum。该动态链接库中还包括其他一些常用的函数，可以通过小工具PEInfo输出并查看。关于校验和的具体计算方法，可以参照3.7节关于PE文件头编程的部分。

#### 33.IMAGE_OPTIONAL_HEADER32.Subsystem

+005ch，单字。==指定使用界面的子系统==，它的取值如表3-4所示。==这个字段决定了系统如何为程序建立初始的界面，链接时使用的参数-subsystem:xxx选项指定的就是这个字段的值，如果将子系统指定为Windows命令行用户交互模式（Command User Interface，CUI），那么系统会自动为程序建立一个控制台窗口；如果指定为Windows GUI，窗口程序代码必须由用户自己建立==。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.7u46eegiuc0.webp)

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.26ggfswa3o4g.webp)

MASM32的link程序的链接开关-subsystem的常见选项如表3-5所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.2bajh4rq6s74.webp)

#### 34.IMAGE_OPTIONAL_HEADER32.DllCharacteristics

+005eh，单字。==DLL文件属性。它是一个标志集，不是针对DLL文件的，而是针对所有PE文件的==，其详细定义如表3-6所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.2rwt3jfhi4i0.webp)

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.607zn4hrvyw0.webp)

这个字段定义了PE文件装载时的一些特性，第10章会提供一个使用该标志的例子。

#### 35.IMAGE_OPTIONAL_HEADER32.SizeOfStackReserve

+0060h，双字。==初始化时保留栈的大小。该字段表示为初始线程的栈而保留的虚拟内存数量，然而并不是留出的所有虚拟内存都可以做栈（真正的栈大小由下一个字段SizeOfStackCommit决定）。该字段的默认值为0x100000（1MB），如果调用API函数CreateThread时，把NULL当做传入的参数，那么创建出来的栈大小也会是1MB。==

#### 36.IMAGE_OPTIONAL_HEADER32.SizeOfStackCommit

+0064h，双字。==初始化时实际提交的栈大小。保证初始线程的栈实际占用内存空间的大小，它是被系统提交的。这些提交的栈不存在于交换文件里，而是存在于内存中==。==对于Microsoft的链接器来说，这个域的初始值为0x1000字节（1页），而对于TLINK32，则为2页。==

#### 37.IMAGE_OPTIONAL_HEADER32.SizeOfHeapReserve

+0068h，双字。==初始化时保留的堆大小。用来保留给初始进程堆使用的虚拟内存，这个堆的句柄可以通过调用GetProcessHeap函数获得。每一个进程至少会有一个默认的进程堆，该堆在进程启动的时候被创建，而且在进程的生命期中永远不会被删除。默认值为1MB，我们可以通过链接器的"-heap"参数指定起始的保留堆内存大小和实际提交的堆大小。==

#### 38.IMAGE_OPTIONAL_HEADER32.SizeOfHeapCommit

+006ch，双字。==初始化时实际提交的堆大小，在进程初始化时设定的堆所占用的内存空间。默认值为1页==。

#### 39.IMAGE_OPTIONAL_HEADER32.LoaderFlags

+0070h，双字。==加载标志==。

#### 40.IMAGE_OPTIONAL_HEADER32.NumberOfRvaAndSize

+0074h，双字。==定义数据目录结构的数量，一般为00000010h，即16个。该值由字段SizeOfOptionalHeaders决定，实际应用中可以取2～16的值。==

#### 41.IMAGE_OPTIONAL_HEADER32.DataDirectory

+0078h，结构。由16个IMAGE_DATA_DIRECTORY结构线性排列而成，用于==定义PE中的16种不同类别的数据所在的位置和大小==。前面已对这部分做过说明，后面将会对这些数据进行更详细描述。以下是对这16种数据的说明：

1. [0]==导出数据所在的节通常被命名为.edata，它包含一些可被其他EXE程序访问的符号的相关信息，比如导出函数和资源等==。这些符号通常出现在DLL中，但DLL也可以包含导入符号，而且在某些EXE中也可以有导出符号。对导出表的详细介绍请阅读本书第5章。

2. [1]==导入数据所在的节通常被命名为.idata，它包含了PE映像中所有导入的符号==。导入信息在EXE和DLL中几乎都存在。对导入表的详细介绍请阅读本书第4章。

3. [2]==异常表数据所在的节通常被命名为.pdata。该节是由用于异常处理的函数表项组成的数组==。可选文件头中的ExceptionTable（异常表）字段指向它。在将它们放进最终的映像文件之前，这些表项必须按函数地址进行排序，并且这些函数表项的描述必须符合特定的目标平台。==该部分数据主要用于基于表的异常处理，适用于除x86之外的所有类型的CPU==。

4. [3]==资源数据所在的节通常被命名为.rsrc==。该节是一个多层的二叉排序树，该树的节点指向PE中各种类型的资源，如图标、对话框、菜单等。树的深度可达231层，但是==PE中经常使用的只有3层：类型层、名称层、语言代码层==。对资源表的详细信息请参照本书第7章。

5. [4]==属性证书数据的作用类似于PE文件的校验和或者MD5码，通过这种属性证书方式可以验证一个PE文件是否被非法修改过==。为PE文件添加属性证书表可以使该PE与属性证书相关联。==属性证书表是由一组连续的按八进制字（从任意字节边界开始的16个连续字节）边界对齐的属性证书表项组成，每个属性证书表项指向WIN_CERTIFICATE结构==。此结构可以在WinTrust.H文件中找到，该结构的详细定义如下：

   ![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.4700mkt37ry0.webp)

   > 注意　该数据并不作为映像的一部分被映射到内存，因此，DataDirectory.Certificate _VirtualAddress字段是文件偏移，而不是RVA。

   ==DataDirectory.Certificate _VirtualAddress字段给出了属性证书表中第一个属性证书表项在文件中的偏移==。对于后续的属性证书表项，可以通过将当前属性证书表项的文件偏移加上WIN_CERTIFICATE.dwLength字段的值，并将结果向上舍入为8个字节的倍数来访问。后续的属性证书表项可以一直以这种方式访问，直到这些WIN_CERTIFICATE.dwLength字段（已经向上舍入为8字节的倍数的和等于可选文件头中的DataDirectory.Certificate _isize的值。如果上述的值最后不等于isize字段的值，要么是属性证书表被破坏了，要么是isize域被修改了。

6. [5]==基址重定位信息所处的节通常被命名为.reloc，基址重定位表包含了映像中所有需要重定位的内容==。它被划分成许多块，每一块表示一个4KB页面范围内的基址重定位信息，它必须从32位边界开始。一般情况下，Windows加载器是不需要处理由链接器解析的基址重定位信息的，除非该映像不能被如约地加载到IMAGE_OPTIONAL_HEADER32.ImageBase指定的位置。该部分的详细介绍请阅读本书第6章。

7. [6]==调试数据所处的节通常被命名为.debug，它指向IMAGE_DEBUG_DIRECTORY结构数组。其中的每个元素都描述了PE中的一些调试信息==。要获得IMAGE_DEBUG_DIRECTORY结构的数目，可以用isize字段除以IMAGE_DEBUG_DIRECTORY结构的大小。

   > 注意　在默认情况下，==调试信息==并不会映射到映像的虚拟地址空间中。调试目录可以位于一个可丢弃的.debug节（如果存在）中，或者位于PE文件的其他节中，或者不在任何节中。所以，它可能被加载到虚拟内存中，而==大部分情况下是被丢弃的。==

8. [7]预留，必须为0。

9. [8]==Global Ptr数据描述的是被存储在全局指针寄存器中的一个值==。

10. [9]==线程本地存储数据所处的节，通常命名为.tls。线程本地存储（TLS）是Windows支持的一种特殊存储类别，其中的数据对象不是栈变量，而是对应于运行相应代码的单个线程==。因此，每个线程都可以为使用TLS定义的变量来维护一个不同于其他线程的值。

    ==当创建线程时，PE加载器通过将线程环境块（TEB）的地址放入FS寄存器来传递线程的TLS数组地址，距TEB开头0x2C的位置处有一个指针指向该TLS数组==。线程本地存储技术是特定于Intel x86平台的，关于TLS的详细信息请阅读本书第9章。

11. [10]==加载配置信息用于包含保留的SEH技术。该技术基于x86的32位系统，它提供了一个安全的结构化异常处理程序列表，操作系统在进行异常处理时要用到这些异常处理程序==。详细信息请阅读本书第10章。

12. [11]==绑定导入数据的存在主要是为了优化导入信息，提高PE的加载效率==。==当PE文件被加载到内存时，加载器会先检查导入表，然后把需要加载的DLL载入到地址空间中==。加载器还有一项比较重要的工作是根据导入信息的描述使用动态链接库里输入函数的实际地址去替换IAT表的内容，这个步骤会花去一部分时间。但是，如果程序员（或者链接器）可以完全知道函数的地址，就可以直接把数组中的元素替换为地址，这能节省相当多的时间。这种方法就称为绑定（Binding）。简单来讲，绑定是指由程序员或链接器代替Windows PE加载器完成了一部分对导入表的处理工作（在加载时）。对绑定导入的相关介绍请阅读本书4.5节。

13. [12]==IAT是导入地址表的英文缩写。准确地讲，它是导入表的一部分，这个双字数组里定义了所有导入函数的VA，程序可以直接通过跳转指令跳转到该VA处执行==。该部分的详细介绍请阅读本书第4章。

14. [13]==延迟导入数据也和动态链接库调用有关，这种数据的存在是为了给“应用程序直到首次调用某个DLL中的函数或数据时才加载这个DLL（即延迟加载）”这种行为提供一种统一的访问机制==。详细信息请阅读本书第8章。

15. [14]==CLR数据所处的节通常被命名为.cormeta，该信息是.NET框架的一个重要组成部分，所有基于.NET框架开发的程序，其初始化部分都是通过访问这部分定义而实现的。PE加载时将通过该结构加载代码托管机制需要的所有动态链接库文件，并完成与CLR有关的一些其他操作==。

16. [15]系统预留，未定义。

> 提示　要想在PE中找到特定类型的数据或者资源，就应从这个结构开始的。通过查找不同类别资源的RVA地址和长度，即可获取到相关数据，这在前面已经提到过。

## 3.5.4　数据目录项IMAGE_DATA_DIRECTORY的字段

#### 42.IMAGE_DATA_DIRECTORY.VirtualAddress

+0000h，双字。==如上所述，这个字段记录了特定类型数据的起始RVA==。当然，针对不同的数据结构，该字段包含的数据含义并不一样，有的数据甚至还不是RVA（如属性证书数据中该字段的值表示的是FOA）。

#### 43.IMAGE_DATA_DIRECTORY.isize

+0004h，双字。==该字段记录了特定类型的数据块的长度==。

## 3.5.5　节表项IMAGE_SECTION_HEADER的字段

#### 44.IMAGE_SECTION_HEADER.Name1

+0000h，8字节。==该字段一共8个字节，一般情况下是一个以“\0”结尾的ASCⅡ码字符串来标识节的名称，内容可以自行定义==。

该名称并不遵循Ansi字符串必须以“\0”结尾的规律，如果不以“\0”结尾，系统依然会认为它是一个字符串,但会根据8个字节的长度对其进行截断处理。

#### 45.IMAGE_SECTION_HEADER.Misc

+0008h，双字。==该字段是一个union型的数据，这是节的数据在没有对齐前的真实尺寸，不过很多PE文件里该值并不准确==。

#### 46.IMAGE_SECTION_HEADER.VirtualAddress

+000ch，双字。==节区的RVA地址==。

#### 47.IMAGE_SECTION_HEADER.SizeOfRawData

+0010h，双字。==节在文件中对齐后的尺寸。在HelloWorld.exe中，数据量不大的节，其大小一般为200h==。

#### 48.IMAGE_SECTION_HEADER.PointerToRawData

+0014h，双字。==节区起始数据在文件中的偏移。比如我们的例子中，.text节是在偏移0x00000400处==。

#### 49.IMAGE_SECTION_HEADER.PointerToRelocations

+0018h，双字。==在".obj"文件中使用，指向重定位表的指针==。

#### 50.IMAGE_SECTION_HEADER.PointerToLinenumbers

+001ch，双字。==行号表的位置（供调试用）==。

#### 51.IMAGE_SECTION_HEADER.NumberOfRelocations

+0020h，单字。==重定位表的个数（在OBJ文件中使用）==。

#### 52.IMAGE_SECTION_HEADER.NumberOfLinenumbers

+0022h，单字。==行号表中行号的数量==。

#### 53.IMAGE_SECTION_HEADER.Characteristics

+0024h，双字。==节的属性。这个字段很重要，这是节的属性标志字段，其中不同的数据位代表了不同的属性==，具体的定义如表3-7所示。==这些数据位的组合描述了内存中的一个节所拥有的访问属性==。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.21qsww6w9yf4.webp)

==代码节的属性一般为60000020h，也就是可执行、可读和“节中包含代码”==；==数据节的属性一般为c0000040h，也就是可读、可写和“包含已初始化数据”==；而==常量节（对应源代码中的.const段）的属性为40000040h，也就是可读和“包含已初始化数据”==；==资源节的属性和常量节的属性一般是相同的==。

当然，==节属性的定义不一定必须是这些值。比如，当PE文件被压缩工具压缩以后，包含代码的节往往被同时设置成具有可执行、可读和可写属性，因为解压部分需要将解压后的代码回写到代码段中==。大家可以做个实验：==先往代码段中写数据，编译链接完成后执行，这时肯定会引发异常；如果用压缩软件压缩后再执行，就会发现文件可以正常执行了，这就是因为压缩软件为了解压的需要而将节的属性设置为可写了==。

## 3.5.6　解析HelloWorld程序的字节码

接下来，我们就来解析HelloWorld.exe的字节码，并分析每一个字段的含义。本书后面还会围绕这些字节码，通过一些实例来进一步深入讲解它们。请你经常阅读此部分字节码的内容，以加深对PE文件的印象。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.4bva77xx92g0.webp)

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.20bektap54o0.webp)

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.56qcn4b6u5s0.webp)

> 需要明确一点：以上内容是文件中的实际字节码。当该文件被操作系统加载进内存以后，这些内容会或多或少地发生一些变化。要想真正理解PE文件格式，还必须明白PE文件被装载到内存后映像字节码所产生的变化。

# 3.6　PE内存映像

运行OD软件，依次选择“文件”→“打开”选项，在弹出的对话框中选择要打开的文件（D:\masm32\source\chapter3\HelloWorld.exe）；然后选择“查看”→“内存”选项，查看其内存分配，如图3-14所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.2n3wlitgn9u0.webp)

图　3-14　加载到内存中的HelloWorld.exe映像

从图中可以看出，文件字节码在内存中的大致分布：

```cpp
PE文件头+代码+输入表+数据
```

==每个部分都按照1000h对齐，因为在Windows操作系统中，每个运行的程序都有自己独立的地址空间，所以，根据文件字节码中IMAGE_OPTIONAL_HEADER32.ImageBase的建议装入映像基地址的值，该EXE文件被装入到起始地址为0x00400000h的虚拟内存地址处==。

请大家自行练习在OD中查看HelloWorld.exe的头部描述信息。要想深入了解关于Windows虚拟内存地址空间的分配，可以参照第11章的内容。图3-15说明了文件和内存中的PE字节码之间的区别。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.4mmxp89aemq0.webp)

图　3-15　PE文件映像与PE内存映像对比

如图3-15所示，==从文件到内存，“头+节表”部分的数据没有做任何更改，多出的部分也只是以0补足的数据而已。对于各个节，其对齐的方式则是由数据结构中的字段IMAGE_OPTIONAL_HEADER32.FileAlignment和IMAGE_OPTIONAL_HEADER32.SectionAlignment分别定义的==。

# 3.7　PE文件头编程

了解了PE文件的头部结构，以及PE在内存中的映像后，接下来将要学习的是==用汇编语言编写的与文件头部数据结构有关的函数==。这些函数并不复杂，但大部分函数在以后的编程中会被反复用到。

## 3.7.1　RVA与FOA的转换

==RVA是相对虚拟地址，FOA是文件偏移==，在一些补丁程序的编写过程中，经常会涉及两者之间的相互转换，下面将介绍通过程序实现两者之间的相互转换的方法。

==PE文件头和PE内存映像的文件头大小都是一样的，它们受对齐粒度不同的影响；节的数据在内存和磁盘文件的大小是不一样的，节表项记录了内存映像中节的起始RVA，也同样记录了本节在文件中的起始偏移。节表项IMAGE_SECTION_HEADER是我们可以找到这两个字段之间存在关联的唯一地方==。重新看一下IMAGE_SECTION_HEADER的定义：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.2llgdjwbyfs0.webp)

==由于节在内存中是线性排列的，因此如果找到下一个节的内存起始RVA就能知道上一个节的大小==。==所有的节组合起来就是PE中除去文件头以外的所有内容，而文件头在磁盘文件和内存中是没有变化的==。

==这些特点使得在文件头部数据结构中的所有RVA字段都可以通过比较方法将该RVA定位到某个具体的节==。==有了这个节的内存起始RVA0，就可以求出指定RVA距离节头的偏移off，而这个偏移在磁盘文件和内存中都是一样的==（因为对齐时是在节的数据后面补0，而不是前面）。

==当我们获取到某个RVA在某个节中距离节头的偏移off以后，就可以通过该节在文件中的偏移求出这个RVA在文件中的偏移了==。大致的步骤如下：

1. 步骤1　判断指定的RVA落在哪个节内。

2. 步骤2　求出该节的起始 `RVA0 = IMAGE_SECTION_HEADER.VirtualAddress`

3. 步骤3　求出偏移量 `offset1 = RVA0 - RVA`

4. 步骤4　求出该RVA相对于磁盘文件头的偏移 `FOA = IMAGE_SECTION_HEADER.PointerToRawData + off`


如图3-16所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.5bhkvs15twc0.webp)

图　3-16　RVA到FOA的转换

按照上面描述的步骤和图3-16可以得出结论：

1. 步骤1　很明显，通过对比`RVA20＜RVA＜RVA30`，指定的RVA落在节2内。

2. 步骤2　该节的起始为：`RVA0 = RVA20`

3. 步骤3　距离本节的偏移量为：`off = RVA - RVA20`

4. 步骤4　该RVA相对于磁盘文件头的偏移为：

   `FOA = IMAGE_SECTION_HEADER.PointerToRawData + off = FOA20 + off = FOA20 + RVA - RVA20`

从内存RVA到文件偏移（距离文件头）的转换函数详见代码清单3-1。

代码清单3-1　将内存偏移RVA转换为文件偏移的函数_RVAToOffset（chapter3\PEHeader.asm）

------

```assembly
;---------------------
; 将内存偏移量RVA转换为文件偏移
; 参数1： lp_FileHead为文件头的起始地址
; 参数2：_dwRVA为给定的RVA地址
;---------------------
_RVAToOffset proc _lpFileHead, _dwRVA
  ; 定义局部变量
  local @dwReturn

  pushad ; 保存所有寄存器的值到堆栈中，以便稍后恢复

  mov esi, _lpFileHead ; 将文件头地址存入esi寄存器
  assume esi:ptr IMAGE_DOS_HEADER ; 假设esi指向IMAGE_DOS_HEADER结构体类型的指针
  add esi, [esi].e_lfanew ; 计算偏移到PE文件头

  assume esi:ptr IMAGE_NT_HEADERS ; 假设esi指向IMAGE_NT_HEADERS结构体
  mov edi, _dwRVA ; 将传入的RVA地址存入edi寄存器
  mov edx, esi ; 备份esi到edx寄存器
  add edx, sizeof IMAGE_NT_HEADERS ; 移动到PE文件头之后

  assume edx:ptr IMAGE_SECTION_HEADER ; 假设edx指向IMAGE_SECTION_HEADER结构体的指针
  movzx ecx, [esi].FileHeader.NumberOfSections ; 获取节表的数量

  ; 遍历节表
  .repeat
    mov eax, [edx].VirtualAddress ; 获取当前节的VirtualAddress
    add eax, [edx].SizeOfRawData ; 计算该节的结束RVA

    ; 检查给定的RVA是否在当前节的范围内
    .if (edi >= [edx].VirtualAddress) && (edi < eax)
      mov eax, [edx].VirtualAddress ; 获取当前节的VirtualAddress
      sub edi, eax ; 计算RVA在当前节内的偏移
      mov eax, [edx].PointerToRawData ; 获取当前节的PointerToRawData
      add eax, edi ; 加上偏移量，计算文件偏移
      jmp @F ; 跳到结束标签
    .endif

    add edx, sizeof IMAGE_SECTION_HEADER ; 移动到下一个节表项
  .untilcxz ; 当cx寄存器为0时退出循环

  assume edx:nothing ; 取消对edx的假设
  assume esi:nothing ; 取消对esi的假设

  mov eax, -1 ; 如果没有找到合适的节，将返回-1
@@:
  mov @dwReturn, eax ; 将结果存入局部变量
  popad ; 恢复之前保存的所有寄存器值
  mov eax, @dwReturn ; 将结果移动到eax寄存器中
  ret ; 返回结果
_RVAToOffset endp ; 过程结束

```

------

同理，大家可以自己分析从文件偏移到RVA的转换。不过从文件偏移到RVA的转换在代码中用处不大，在使用OD进行调试的时候经常会用到。详细代码可以从chapter3\PEInfo.asm中获得。

## 3.7.2　数据定位

==在实现PE文件头部的编码过程中，大部分都要经过3个步骤：定位、取数据和操作。而定位包括：PE头定位、数据目录表项定位、节表项定位==。

数据定位函数会在两种情况下被调用，第一种情况是针对PE映像文件的信息存取，第二种情况是针对内存映射文件的信息存取。下面详细介绍PE文件头中的三种常见地址的定位。

### 1.PE头定位

因为PE中任何数据的定位必须首先找到PE头部标识，所以==PE头定位代码被广泛地应用于PE中其他数据的定位代码中==，具体如代码清单3-2所示。

代码清单3-2　定位到PE标识的函数_rPE（chapter3\PEHeader.asm）

------

```assembly
;-------------------
; 定位到PE标识
; _lpHeader 头部基地址
; _dwFlag1
;    为0表示_lpHeader是PE映像头
;    为1表示_lpHeader是内存映射文件头 
; _dwFlag2
;    为0表示返回RVA+模块基地址
;    为1表示返回FOA+文件基地址
;    为2表示返回RVA
;    为3表示返回FOA
; 返回eax=PE标识所在地址
;
; 注意：当_lpHeader是PE映像头时，
;       _dwFlag2为1是无意义的，所以返回FOA
;-------------------
_rPE  proc _lpHeader, _dwFlag1, _dwFlag2
   local @ret ; 声明局部变量，用于存储返回值
   local @imageBase ; 声明局部变量，用于存储ImageBase值

   pushad ; 保存所有寄存器的值到堆栈中，以便稍后恢复

   mov esi, _lpHeader ; 将传入的头部地址存入esi寄存器
   assume esi:ptr IMAGE_DOS_HEADER ; 假设esi指向IMAGE_DOS_HEADER结构体
   add esi, [esi].e_lfanew ; 计算偏移到PE文件头

   mov edi, esi ; 备份esi到edi寄存器
   assume edi:ptr IMAGE_NT_HEADERS ; 假设edi指向IMAGE_NT_HEADERS结构体

   mov eax, [edi].OptionalHeader.ImageBase ; 获取程序的建议装载地址，即ImageBase
   mov @imageBase, eax ; 将ImageBase存入局部变量@imageBase

   .if _dwFlag1 == 0 ; _lpHeader是PE映像头
     .if _dwFlag2 == 0 ; RVA+模块基地址
       mov eax, esi ; 将esi中的地址存入eax，即RVA地址
       mov @ret, eax ; 将eax中的值存入局部变量@ret
     .elseif _dwFlag2 == 1 ; 无意义，只返回FOA
       sub esi, _lpHeader ; 计算RVA地址与头部地址的差值，即FOA
       mov eax, esi ; 将FOA存入eax
       mov @ret, eax ; 将eax中的值存入局部变量@ret
     .else ; 当_dwFlag2=2或3时返回值相同
       sub esi, _lpHeader ; 计算RVA地址与头部地址的差值
       mov eax, esi ; 将差值存入eax，可以是RVA或FOA
       mov @ret, eax ; 将eax中的值存入局部变量@ret
     .endif
   .else ; _lpHeader是内存映射文件头
     .if _dwFlag2 == 0 ; RVA+模块基地址
       sub esi, _lpHeader ; 计算RVA地址与头部地址的差值
       add esi, @imageBase ; 加上ImageBase，得到RVA+模块基地址
       mov eax, esi ; 将RVA+模块基地址存入eax
       mov @ret, eax ; 将eax中的值存入局部变量@ret
     .elseif _dwFlag2 == 1 ; FOA+文件基地址
       mov eax, esi ; 将esi中的地址存入eax，即FOA地址
       mov @ret, eax ; 将eax中的值存入局部变量@ret
     .else ; 当_dwFlag2=2或3时返回值相同
       sub esi, _lpHeader ; 计算RVA地址与头部地址的差值
       mov eax, esi ; 将差值存入eax，可以是RVA或FOA
       mov @ret, eax ; 将eax中的值存入局部变量@ret
     .endif
   .endif

   popad ; 恢复之前保存的所有寄存器值
   mov eax, @ret ; 将局部变量@ret的值存入eax
   ret ; 返回结果
_rPE endp ; 过程结束

```

------

如上所示，==函数的入口参数为0时，表示\_lpHeader头部基地址是基于PE映像文件的；反之则是基于内存映射文件的。函数会返回4种地址，类型用\_dwFlag2来区分==。\_dwFlag2的取值及含义如下：

- 如果为0，表示返回RVA+模块基地址。
- 如果为1，表示返回FOA+文件映射地址。
- 如果为2，表示RVA。
- 如果为3，表示FOA。

当然，\_dwFlag1和\_dwFlag2的组合有时候是没有意义的。比如，当\_dwFlag1=0、\_dwFlag2=1时，返回值就没有意义，因为此时基地址是内存的PE映像，此时的文件映射地址就是一个模糊值，这种情况下程序只是简单地返回FOA地址。

### 2.数据目录表项定位

==数据目录表项定位一般会涉及对不同数据类型的存取==，具体实现如代码清单3-3所示。

代码清单3-3　定位数据目录项函数_rDDEntry（chapter3\PEHeader.asm）

------

```assembly
;-------------------
; 定位到指定索引的数据目录项所在数据的起始地址
; _lpHeader 头部基地址
; _index 数据目录表索引，从0开始
; _dwFlag1
;    为0表示_lpHeader是PE映像头
;    为1表示_lpHeader是内存映射文件头 
; _dwFlag2
;    为0表示返回RVA+模块基地址
;    为1表示返回FOA+文件基地址
;    为2表示返回RVA
;    为3表示返回FOA
; 返回eax=指定索引的数据目录项的数据所在地址
;-------------------
_rDDEntry  proc _lpHeader, _index, _dwFlag1, _dwFlag2
   local @ret, @ret1, @ret2 ; 声明局部变量，用于存储返回值
   local @imageBase ; 声明局部变量，用于存储ImageBase值

   pushad ; 保存所有寄存器的值到堆栈中，以便稍后恢复

   mov esi, _lpHeader ; 将传入的头部地址存入esi寄存器
   assume esi:ptr IMAGE_DOS_HEADER ; 假设esi指向IMAGE_DOS_HEADER结构体
   add esi, [esi].e_lfanew   ; 计算偏移到PE文件头

   assume esi:ptr IMAGE_NT_HEADERS ; 假设esi指向IMAGE_NT_HEADERS结构体
   mov eax, [esi].OptionalHeader.ImageBase ; 获取程序的建议装载地址，即ImageBase
   mov @imageBase, eax ; 将ImageBase存入局部变量@imageBase

   add esi, 0078h ; 指向DataDirectory

   xor eax, eax ; 索引*8
   mov eax, _index
   mov bx, 8
   mul bx
   mov ebx, eax

   ; 取出指定索引数据目录项的位置，是RVA
   mov eax, dword ptr [esi][ebx]
   mov @ret1, eax

   .if _dwFlag1 == 0  ; _lpHeader是PE映像头  
     .if _dwFlag2 == 0     ; RVA+模块基地址
       add eax, _lpHeader
       mov @ret, eax
     .elseif _dwFlag2 == 1 ; 无意义，返回FOA 
       invoke _RVAToOffset, _lpHeader, eax
       mov @ret, eax  
     .elseif _dwFlag2 == 2 ; RVA
       mov @ret, eax
     .elseif _dwFlag2 == 3 ; FOA
       invoke _RVAToOffset, _lpHeader, eax
       mov @ret, eax
     .endif
  .else  ; _lpHeader是内存映射文件头
     .if _dwFlag2 == 0     ; RVA+模块基地址
       add eax, @imageBase
       mov @ret, eax
     .elseif _dwFlag2 == 1 ; FOA+文件基地址
       ; 先将RVA转换为文件偏移
       invoke _RVAToOffset, _lpHeader, eax
       mov @ret2, eax  
       add eax, _lpHeader
       mov @ret, eax
     .elseif _dwFlag2 == 2 ; RVA
       mov @ret, eax
     .elseif _dwFlag2 == 3 ; FOA
       ; 先将RVA转换为文件偏移
       invoke _RVAToOffset, _lpHeader, eax
       mov @ret, eax
     .endif
  .endif

   popad ; 恢复之前保存的所有寄存器值
   mov eax, @ret ; 将局部变量@ret的值存入eax
   ret ; 返回结果
_rDDEntry endp ; 过程结束

```

------

第19行将_内存映射文件头的地址lpHeader传给了寄存器esi；第21行通过字段IMAGE_DOS_HEADER.e_lfanew定位PE头。第23～24行取出PE模块建议的装载基地址给变量@imageBase；第26行将esi的值加上78h，使esi指向数据目录表；第28～32行计算出指定索引的数据目录表项基于数据目录表起始地址的偏移；第37～67行根据传入的参数计算不同条件下指定的数据目录表项的各种地址返回值。

在主程序中要调用该函数，可以使用以下代码：

------

```assembly
;PEHeader.exe导入表数据所在VA
invoke _rDDEntry,00400000h,01h,0,0
invoke wsprintf,addr szBuffer,addr szOut,eax
invoke MessageBox,NULL,offset szBuffer,NULL,MB_OK ;显示00402014h
;PEHeader.exe导入表数据在文件中的偏移地址FOA
invoke _rDDEntry,00400000h,01h,0,3
invoke wsprintf,addr szBuffer,addr szOut,eax
invoke MessageBox,NULL,offset szBuffer,NULL,MB_OK ;显示00000614h
```

------

### 3.节表项定位

==节表项定位一般用在对某个节的数据获取上==，其实现如代码清单3-4所示。

代码清单3-4　定位节表项的函数_rSection（chapter3\PEHeader.asm）

------

```assembly
;-------------------
; 定位到指定索引的节表项
; _lpHeader 头部基地址
; _index 表示第几个节表项，从0开始
; _dwFlag1
;    为0表示_lpHeader是PE映像头
;    为1表示_lpHeader是内存映射文件头 
; _dwFlag2
;    为0表示返回RVA+模块基地址
;    为1表示返回FOA+文件基地址
;    为2表示返回RVA
;    为3表示返回FOA
; 返回eax=指定索引的节表项所在地址
;-------------------
_rSection  proc _lpHeader,_index,_dwFlag1,_dwFlag2
   local @ret,@ret1,@ret2
   local @imageBase
   pushad
   mov esi,_lpHeader
   assume esi:ptr IMAGE_DOS_HEADER
   add esi,[esi].e_lfanew   ;PE标识
   assume esi:ptr IMAGE_NT_HEADERS
   mov eax,[esi].OptionalHeader.ImageBase  ;程序的建议装载地址
   mov @imageBase,eax

   mov eax,[esi].OptionalHeader.NumberOfRvaAndSizes
   mov bx,8
   mul bx
   
   add esi,0078h ;指向DataDirectory
   add esi,eax   ;加上DataDirectory的大小,指向节表开始
   
   xor eax,eax  ;索引*40
   mov eax,_index
   mov bx,40
   mul bx

   add esi,eax   ;索引项所在地址

   .if _dwFlag1==0  ;_lpHeader是PE映像头  
     .if _dwFlag2==0     ;RVA+模块基地址
       mov eax,esi 
       mov @ret,eax
     .else
       sub esi,_lpHeader
       mov eax,esi
       mov @ret,eax
     .endif
  .else  ;_lpHeader是内存映射文件头
     .if _dwFlag2==0     ;RVA+模块基地址
       sub esi,_lpHeader
       add esi,@imageBase
       mov @ret,eax
     .elseif _dwFlag2==1 ;FOA+文件基地址
       mov eax,esi
       mov @ret,eax
     .else
       sub esi,_lpHeader
       mov eax,esi
       mov @ret,eax
     .endif
  .endif
   popad
   mov eax,@ret
   ret
_rSection endp
```

------

第26～28行根据字段IMAGE_OPTIONAL_HEADER32.NumberOfRvaAndSizes的值得出数据目录表的长度，存储在寄存器eax中。第33～37行计算指定索引的节表项距离节表起始地址的偏移。第40～62行根据传入的参数计算不同条件下的指定索引的节表项的各种地址返回值。

在主程序中的调用代码如下：

------

```assembly
;-------------------
; 定位到指定索引的节表项
; _lpHeader 头部基地址
; _index 表示第几个节表项，从0开始
; _dwFlag1
;    为0表示_lpHeader是PE映像头
;    为1表示_lpHeader是内存映射文件头 
; _dwFlag2
;    为0表示返回RVA+模块基地址
;    为1表示返回FOA+文件基地址
;    为2表示返回RVA
;    为3表示返回FOA
; 返回eax=指定索引的节表项所在地址
;-------------------
_rSection  proc _lpHeader, _index, _dwFlag1, _dwFlag2
   local @ret, @ret1, @ret2 ; 声明局部变量，用于存储返回值
   local @imageBase ; 声明局部变量，用于存储ImageBase值

   pushad ; 保存所有寄存器的值到堆栈中，以便稍后恢复

   mov esi, _lpHeader ; 将传入的头部地址存入esi寄存器
   assume esi:ptr IMAGE_DOS_HEADER ; 假设esi指向IMAGE_DOS_HEADER结构体
   add esi, [esi].e_lfanew   ; 计算偏移到PE文件头

   assume esi:ptr IMAGE_NT_HEADERS ; 假设esi指向IMAGE_NT_HEADERS结构体
   mov eax, [esi].OptionalHeader.ImageBase ; 获取程序的建议装载地址，即ImageBase
   mov @imageBase, eax ; 将ImageBase存入局部变量@imageBase

   mov eax, [esi].OptionalHeader.NumberOfRvaAndSizes ; 获取节表项数量
   mov bx, 8
   mul bx

   add esi, 0078h ; 指向DataDirectory
   add esi, eax   ; 加上DataDirectory的大小，指向节表开始

   xor eax, eax  ; 索引*40
   mov eax, _index
   mov bx, 40
   mul bx

   add esi, eax   ; 索引项所在地址

   .if _dwFlag1 == 0  ; _lpHeader是PE映像头  
     .if _dwFlag2 == 0     ; RVA+模块基地址
       mov eax, esi 
       mov @ret, eax
     .else
       sub esi, _lpHeader
       mov eax, esi
       mov @ret, eax
     .endif
  .else  ; _lpHeader是内存映射文件头
     .if _dwFlag2 == 0     ; RVA+模块基地址
       sub esi, _lpHeader
       add esi, @imageBase
       mov @ret, eax
     .elseif _dwFlag2 == 1 ; FOA+文件基地址
       mov eax, esi
       mov @ret, eax
     .else
       sub esi, _lpHeader
       mov eax, esi
       mov @ret, eax
     .endif
  .endif

   popad ; 恢复之前保存的所有寄存器值
   mov eax, @ret ; 将局部变量@ret的值存入eax
   ret ; 返回结果
_rSection endp ; 过程结束

```

------

==通过遍历节表，将给定的RVA与节表中的每个节的地址范围进行比对，如果RVA落在该节表地址范围内，则返回该节的名称字符串地址==，具体如代码清单3-5所示。

代码清单3-5　获取RVA所在节的名称的函数_getRVASectionName（chapter2\PEHeader.asm）

------

```assembly
;------------------------
; 获取RVA所在节的名称
;------------------------
_getRVASectionName  proc _lpFileHead, _dwRVA
  local @dwReturn ; 声明局部变量，用于存储返回值
  
  pushad ; 保存所有寄存器的值到堆栈中，以便稍后恢复

  mov esi, _lpFileHead ; 将文件头地址存入esi寄存器
  assume esi:ptr IMAGE_DOS_HEADER ; 假设esi指向IMAGE_DOS_HEADER结构体
  add esi, [esi].e_lfanew ; 计算偏移到PE文件头

  assume esi:ptr IMAGE_NT_HEADERS ; 假设esi指向IMAGE_NT_HEADERS结构体
  mov edi, _dwRVA ; 将传入的RVA地址存入edi寄存器
  mov edx, esi ; 备份esi到edx寄存器
  add edx, sizeof IMAGE_NT_HEADERS ; 移动到PE文件头之后

  assume edx:ptr IMAGE_SECTION_HEADER ; 假设edx指向IMAGE_SECTION_HEADER结构体
  movzx ecx, [esi].FileHeader.NumberOfSections ; 获取节表的数量

  ; 遍历节表
  .repeat
    mov eax, [edx].VirtualAddress ; 获取当前节的VirtualAddress
    add eax, [edx].SizeOfRawData ; 计算该节的结束RVA

    ; 检查给定的RVA是否在当前节的范围内
    .if (edi >= [edx].VirtualAddress) && (edi < eax)
      mov eax, edx ; 将当前节的地址存入eax
      jmp @F ; 跳到结束标签
    .endif

    add edx, sizeof IMAGE_SECTION_HEADER ; 移动到下一个节表项
  .untilcxz ; 当cx寄存器为0时退出循环

  assume edx:nothing ; 取消对edx的假设
  assume esi:nothing ; 取消对esi的假设

  mov eax, offset szNotFound ; 如果没有找到合适的节，将返回 "szNotFound" 字符串的地址
@@:
  mov @dwReturn, eax ; 将结果存入局部变量
  popad ; 恢复之前保存的所有寄存器值
  mov eax, @dwReturn ; 将结果移动到eax寄存器中
  ret ; 返回结果
_getRVASectionName  endp ; 过程结束

```

------

## 3.7.3　标志位操作

在PE文件头的字段中有很多标志位字段，比如IMAGE_FILE_HEADER.Characteristics、IMAGE_OPTIONAL_HEADER32.DllCharacteristics、IMAGE_SECTION_HEADER.Characteristics等。在实际编程中需要对这些标志位进行操作，下面以IMAGE_SECTION_HEADER.Characteristics为例，讲解在编写汇编代码时如何读取和设置这些标志位。

==标志位的操作不是以字节、字或双字为单位进行存取，而是以位来操作，所以需要用到汇编语言中的位操作符，如and、or、not等==。

#### 1.标志位

一个字节（如0fh）的标志位如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.4uu89o48q740.webp)

一个字的标志位如表3-8所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.5c8yb6g6gk40.webp)

标志位还可以进行组合==。比如，如果要标识一个节的数据的属性为：包含代码、可读、可写、可执行，且包含初始化数据，那么根据节的属性字段的描述，第5、6、29、30、31位均应该设置为1==。组合以后的双字为：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.49psinwsbfk0.webp)

该双字对应的十六进制为：0E0000060h。

#### 2.读标志位

==假设双字在eax中，如果要判断第10位是否为1==，可以这样来操作：首先通过表3-8可查到所在位对应的十六进制值为0400h，然后使用如下代码：

------

```assembly
and eax,00000400h 	;将双字值与0400h相与
jne loc1 			;如果结果不为0，则表示eax的第10位为1，跳转到loc1处执行
```

------

and（与）操作针对每一位，如果两个操作数中的某位有一个为0，则最后结果为0。

当然，我们可以同时测试多个位。==如果要测试节的数据属性是否为可读、可写，则可以使用如下的代码（假设属性值已经在eax中）：==

------

```assembly
and eax,0C0000000h 	;测试高两位（即第30位和31位）是否为1
jne loc1 			;如果满足条件，则跳转到loc1处执行
```

------

#### 3.写标志位

==有时候需要对某个节的数据添加可写属性，可以使用如下代码==（假设该节的原始属性已经存储在eax中）：

------

```assembly
or eax,80000000h
```

------

or（或）操作针对每一位，如果两个操作数中的某位有一个为1，则最后结果为1。

#### 3.7.4　PE校验和

==校验和是一个WORD值。它是通过对一段数据进行一定的算法进行计算以后生成的值，通常作为判断这段数据是否被非法修改的依据==。

PE文件头部的校验和的算法很简单，共分三步：

1. 步骤1　将文件头部的字段IMAGE_OPTIONAL_HEADER32.CheckSum清0。
2. 步骤2　以WORD为单位对数据块进行带进位的累加，大于WORD部分自动溢出。
3. 步骤3　将累加和加上文件的长度。

PE文件头部的校验和的详细实现如代码清单3-6所示。

代码清单3-6　计算PE校验和的函数\_checkSum1（chapter3\PEHeader.asm）

------

```assembly
;-------------------
; 通过调用API函数计算校验和
; kernel32.dll的校验和为：0011e97e
;-------------------
_checkSum1 proc _lpExeFile 
   local @cSum, @hSum
   local @ret

   pushad ; 保存所有寄存器的值到堆栈中，以便稍后恢复

   invoke MapFileAndCheckSum, _lpExeFile, \
                 addr @hSum, addr @cSum ; 调用API函数MapFileAndCheckSum来计算校验和

   mov eax, @cSum ; 将校验和值存入eax
   mov @ret, eax ; 将校验和值存入局部变量@ret

   popad ; 恢复之前保存的所有寄存器值
   mov eax, @ret ; 将结果移动到eax寄存器中
   ret ; 返回结果
_checkSum1 endp ; 过程结束

;-------------------
; 自己编写程序计算校验和
;-------------------
_checkSum2 proc _lpExeFile
   local hFile, dwSize, hBase
   local @size
   local @ret

   pushad ; 保存所有寄存器的值到堆栈中，以便稍后恢复

   ; 打开文件
   invoke CreateFile, _lpExeFile, GENERIC_READ, \
                  FILE_SHARE_READ, NULL, OPEN_EXISTING, \
                  FILE_ATTRIBUTE_NORMAL, 0
   mov hFile, eax

   invoke GetFileSize, hFile, NULL ; 获取文件大小
   mov dwSize, eax

   ; 为文件分配内存，并读入
   invoke VirtualAlloc, NULL, dwSize, \
                  MEM_COMMIT, PAGE_READWRITE
   mov hBase, eax

   invoke ReadFile, hFile, hBase, dwSize, addr @size, NULL

   ; 关闭文件
   invoke CloseHandle, hFile

   ; 第一步，将CheckSum清零
   mov ebx, hBase
   assume ebx:ptr IMAGE_DOS_HEADER
   mov ebx, [ebx].e_lfanew
   add ebx, hBase
   assume ebx:ptr IMAGE_NT_HEADERS
   mov [ebx].OptionalHeader.CheckSum, 0
   assume ebx:ptr nothing

   mov ecx, dwSize
   mov esi, hBase

   ; 第二步，按字进位加，溢出忽略
   push ecx
   inc ecx
   shr ecx, 1
   xor ebx, ebx
   clc
loc1:
   lodsw
   adc bx, ax
   loop loc1

   invoke VirtualFree, hBase, dwSize, MEM_DECOMMIT

   ; 第三步，加文件长度
   pop eax
   add eax, ebx
   mov @ret, eax ; 将校验和结果存入局部变量@ret

@exit:
   popad ; 恢复之前保存的所有寄存器值
   mov eax, @ret ; 将校验和结果移动到eax寄存器中
   ret ; 返回结果
_checkSum2 endp ; 过程结束

```

------

函数\_checkSum1通过调用动态链接库IMAGEHLP.DLL的MapFileAndCheckSum函数来获取校验和，而函数\_checkSum2则按照校验和算法规则来自定义校验和的获取。通过运行这两个函 数，可以对C:\windows\system32\kernel32.dll文件进行检验，这两个函数算出来的校验和都是0011e97eh，说明该值与kernel32.dll文件头中记录的值是一致的。

以下字节码来自kernel32.dll文件的头部，加粗部分即为字段IMAGE_OPTIONAL_HEADER32.CheckSum的值：

![image](https://github.com/YangLuchao/img_host/raw/master/20230901/image.1hbv8pm6bc4g.webp)
