[toc]

第12章介绍了PE变形技术，该技术研究的是程序的字节码；本章来研究PE补丁技术，该技术侧重于研究使用Masm32编写的补丁程序，而非程序字节码。==PE补丁技术被广泛应用于PE病毒、PE加密解密等领域，通过对目标程序嵌入不同的补丁程序，可以实现不同的目的==。

==PE补丁分为动态补丁和静态补丁，其中静态补丁框架由两部分组成：补丁程序和将补丁程序附加到目标PE的补丁工具==。

# 13.1　动态补丁

==动态补丁是指目标PE处于活动状态时（即进程）为其实施的补丁==。==PE文件被映像加载器装载到内存后，就变成了进程，由Windows子系统调度PE映像里预先存放的指令代码完成指定的功能==。前面讲过，==每个进程其存取空间为4GB，各进程的地址空间独立，相互之间并不影响，动态补丁技术即要求我们打破这种传统的认识，实现一个进程可以操作另外一个进程的地址空间==。==动态补丁常用于游戏修改器、动态调试、病毒生存等领域==。

一个完整的动态补丁一般需要具备以下四个要素：

1. ==与其他进程通信的能力。==

2. ==良好的读写其他进程地址空间的能力。==

3. ==能正确识别要补丁的目标进程。==

4. ==在其他进程地址空间执行代码的能力。==


下面就针对以上四点展开讨论。

## 13.1.1　进程间的通信机制

==在实施补丁过程中，两个进程之间会相互交换数据，如补丁程序必须动态获取目标进程运行的状态，以确定在什么时候，什么地点实施补丁==。==这些信息的传递需要用到Windows系统中进程间的数据通信机制==。

在Windows中，实现进程间通信的机制有很多方法，归纳一下分为两大类：

1. ==一种是通过两个进程实施的耦合性强的进程间通信==。这种通信机制要求参与通信的两个进程必须密切配合，两个进程工作在服务器/客户端模式。==这类通信机制主要包括匿名管道、命名管道、邮件槽、远程方法调用==等。

2. ==另外一种是由第三方参与的耦合性相对较弱的进程间通信==，==比如通过剪贴板、共享内存、动态链接库、映射文件、注册表、一般文件、Socket、Windows消息队列、信号量等==。


以下是常见的进程通信机制。

### 1.管道技术

==管道（pipe）是一种具有两个端点的通信通道，两个端点分别连接两个进程。管道可以是一个方向的，也可以是两个方向的；连接管道的两个端点既可以从管道中读取数据，也可以将数据写进管道==。

==匿名管道（Anonymous Pipe）存在于父进程与子进程之间，由于它连接了两个具有继承关系的进程，所以该管道不需要名字，管道的创建由父进程完成==。==匿名管道是单机上实现子进程标准I/O重定向的有效方法，它无法在网络上使用，也不能用于两个不相关的进程==。==创建匿名管道的API函数是`CreatePipe`==。

==命名管道（Named Pipe）是服务器进程和一个或多个客户进程之间通信的单向或双向管道==。==创建管道的服务器端在建立管道时会给管道指定一个名字，其他任何进程都可以通过这个名字打开管道的另一端，并根据给定的权限与创建管道的进程实施通信==。==创建命名管道的API函数是`CreateNamedPipe`==。

### 2.邮件槽

==单一的邮件槽（Mail Slots）提供了两个进程间的单向通信能力==。==由一个进程建立邮件槽从而成为邮件槽服务器，而其他进程，则通过邮件槽的名字向服务器发送消息==。==该消息一直处在邮件槽中直到服务器读取它==。==这种机制与命名管道的机制类似，都是基于SOCKET技术通过端口实现的，但两者传递数据的协议不同==。

如果要建立双向的通信，则客户端也可以建立相同的邮件槽，从而使得客户端同时具备服务器和客户端两种角色。两个这样的进程连在一起就形成了一种双向的可读写的通信通道。由于邮件槽使用了不可靠的数据报协议，所以其通常用于广播消息。==创建邮件槽的API函数是`CreateMailslot`==。

### 3.剪贴板

==剪贴板（Clipped Board）是为应用程序之间进行数据共享而提供的一个第三方的数据存储区==。两个需要传递数据的进程无需进行协商，由一方通过剪切（或复制）操作实施数据的转移，另一方则可以在任何时刻（保证剪贴板中数据没有被重新覆盖）从剪贴板中取回数据。==进程间存取数据唯一的限制是两者必须使用同样格式的数据==。

### 4.共享内存

==共享内存是文件映射机制的一个特例==。==内存映射文件（Memory Mapped Files）将磁盘不连续存储的文件复制到连续内存空间中，在前面有所介绍==。Win32 API允许多个进程访问同一文件映射对象，各个进程在它自己的地址空间里接收指向内存线性文件的指针。通过使用这些指针，不同进程就可以读写文件的内容，从而实现对文件中数据的共享。

Win32 API中共享内存（Shared Memory）实际是文件映射的一种特殊情况。进程在创建文件映射对象时用0xFFFFFFFF来代替正常的文件句柄，表示对应的文件映射对象是从操作系统页面文件来访问内存，其他进程只要打开该文件映射对象就可以访问该内存块，进而实现多进程共享同一段内存数据的目的。==建立内存映射对象的API函数是`CreateFileMapping`，其他进程访问内存映射文件的API函数是`OpenFileMapping`==。

### 5.消息机制

==消息机制是Windows应用程序的核心，在Windows中发生的大部分事件都可以用消息来表示。消息可以告诉操作系统发生了什么，所有的Windows应用程序都是消息驱动的==。==可以说，消息机制是Windows系统间、进程间传递数据的最好的方法==。

窗口移动、鼠标点击、键盘按键等事件的发生，以及程序的启动或退出都会产生标准的Windows消息。这些消息告诉Windows操作系统（或接管了消息处理的程序）当前系统（或进程）的运行状态。当然，Windows也提供了一些其他的非标准的消息，如异常消息，这些消息与系统的某些机制相关。

==动态补丁程序使用消息机制，配合内存读写来实现进程间数据传递会相对容易些==。==一个进程在运行时会根据运行状态产生各种消息（比如，因异常事件触发的异常消息、程序中由中断指令引发的调试消息等），这些消息会通过进程的外露端口（如异常调试消息经由异常端口）传输出去==。==由于引发异常调试消息事件`EXCEPTION_DEBUG_EVENT`的指令最为精简（`即int 3指令，一个字节，十六进制字节码为0CCh`），所以这种进程间传递数据的方式被普遍用在动态补丁技术中==。通过该消息传递数据的流程如图13-1所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20231018/image.pe96h07bi5c.jpg)

图　13-1　动态补丁中的信息传递

如图所示，==补丁工具通过进程内存读写技术将补丁代码写入目标进程指定位置（补丁代码为int 3，即0CCh）==；==同时，补丁工具记录该位置的字节值==。==当目标进程执行到该位置时将产生异常，操作系统将该异常产生时的相关信息（各寄存器的值等）包装到数据结构`EXCEPTION_RECORD`中，并查找此时调试目标进程的进程（即动态补丁工具），操作系统将该结构通过消息传递给动态补丁工具==；==然后，由动态补丁工具完成对目标进程信息的解读，将解读以后的相关信息再有选择地重新写回到目标进程地址空间，以改变目标进程的运行行为或当前的进程状态==。

## 13.1.2　读写进程内存

==读写其他进程内存地址空间是动态补丁必须具备的功能，Windows API中提供了读写其他进程地址空间的函数==。首先介绍这些相关的函数。

### 1.相关函数

==Windows的安全机制不允许一个进程直接读写其他进程空间的数据，除非使用了特定的Windows API函数==。这些函数包括：

- `OpenProcess`（通过设置访问权限打开要读写的进程）
- `ReadProcessMemory`（实现打开进程空间数据的读取）
- `WriteProcessMemory`（完成向打开的进程空间写入数据）

以下是这三个函数的详细介绍。

#### （1）`OpenProcess`函数

==`OpenProcess`函数用来打开一个已存在的进程对象，并返回进程的句柄==。函数原型定义如下：

------

```c
HANDLE OpenProcess(
	DWORD dwDesiredAccess,	//访问权限
	BOOL bInheritHandle,	//继承标志，若句柄能由子进程继承，则设置为TRUE
	DWORD dwProcessId		//进程号
);
```

------

各参数解释如下：

1）`dwDesiredAccess`：访问权限。它可以是表13-1所列的值。

![image](https://github.com/YangLuchao/img_host/raw/master/20231018/image.3ysf7wgetue.jpg)

2）`bInheritHandle`：继承标志；如果设置为TRUE，表示继承打开的进程，否则表示不继承。

3）`dwProcessId`：进程的ID号。

4）返回值：==如成功，返回值为指定进程的句柄==；==如失败，返回值为空==。==可调用GetLastError获得错误代码==。

#### （2）`ReadProcessMemory`函数

==读进程内存函数==。以下是函数原型：

------

```c
BOOL ReadProcessMemory(
	HANDLE hProcess,		//远程进程句柄
	PVOID pvAddressRemote,	//远程进程地址VA值
	PVOID pvBufferLocal,	//存放数据的缓冲区
	DWORD dwSize,			//缓冲区大小
	PDWORD pdwNumBytesRead	//读出的实际字节数，是输出参数
);
```

------

各参数解释如下：

1）`hProcess`：远程进程的句柄，远程进程即为要操作的进程。

2）`pvAddressRemote`：要操作的进程的地址空间，该地址为VA。

3）`pvBufferLocal`：存放要操作的数据的本地缓冲区。

4）`dwSize`：本地缓冲区大小。

5）`pdwNumBytesRead`：输出参数，表示本次读取的实际字节数。

6）==返回值：如成功，返回TRUE，否则返回NULL==。

#### （3）`WriteProcessMemory`函数

==写进程内存函数==。完整定义如下：

------

```c
BOOL WriteProcessMemory(
	HANDLE hProcess,		//远程进程句柄
	PVOID pvAddressRemote,	//远程进程地址VA值
	PVOID pvBufferLocal,	//存放数据的缓冲区
	DWORD dwSize,			//缓冲区大小
	PDWORD pdwNumBytesRead	//读写的字节数，是返回值
);
```

------

读进程内存和写进程内存的函数的参数定义是一样的，各参数的解释如下：

1）`hProcess`：指定将要被读写的目标进程句柄。

2）`pvAddressRemote`：目标进程中被读写的起始线性地址。

3）`pvBufferLocal`：用来接收读取数据的缓冲区（对于ReadProcessMemory函数）或者要写到目标进程的数据缓冲区（对于WriteProcessMemory函数）。

4）`dwSize`：要读写的字节数。

5）`pdwNumBytesRead`：指向一个双字变量，供函数返回实际读写的字节数；如果不关心这个结果，可以将其设置为NULL。

6）==返回值：如果函数执行成功，那么返回值是非0值，执行失败的话返回0==。

### 2.读写进程内存实例分析

如果大家经常使用PEInfo小工具，就会发现该工具在查看一些有大量数据的PE时，经常会出现界面“死住”的情况，关于原因和解决方法已经在第2章里讲过了，现在来看看通过动态补丁技术如何解决这一问题。

#### （1）修改代码

为了简化问题的描述，配合大家理解进程内存读写，本实例采用了一些技巧，比如，在需要打补丁的PEInfo.asm中，做了如下修改：

##### 步骤1　在数据段中添加一个标志dwFlag：

------

```assembly
szFileName db MAX_PATH dup(?),0FFh
dwFlag dd 0FFFFFFFFh ;新增加的标志
szDllEdit db 'RichEd20.dll',0
szClassEdit db 'RichEdit20A',0
```

------

##### 步骤2　在代码中增加检测标志位的代码：

------

```assembly
.while [esi].VirtualAddress
	cld
	……
	invoke _appendInfo,addr @szBuffer
	pop ecx ;重定位项数量
	xor edi,edi
	
	.repeat
		push ecx
		invoke _appendInfo,addr @szBuffer
		pop ecx
		.break.if dwFlag == 1 ;加入一个看似永远也不可能成立的条件
		;该标志会由其他进程修改！
	.untilcxz
	
	.break.if dwFlag == 1 ;加入一个看似永远也不可能成立的条件
		;该标志会由其他进程修改！
		
	.if edi
		invoke _appendInfo,addr szCrLf
	.endif
.endw
```

------

==在两层循环中均增加了对标志位的判断，如果该标志位值为1，则退出循环==。因为dwFlag在定义时被设置为值0xffffffff，并且chapter13\PEInfo.asm中再也没有与dwFlag有关的赋值代码，所以，该程序中这个退出条件似乎永远也不会发生。

#### （2）补丁工具源代码

==动态补丁技术是通过修改进程内存空间数据，使被修改进程发生程序流向转移的技术==。==起到这种作用的程序一般称为补丁工具==，代码清单13-1是补丁工具的部分源代码（完整代码请参照随书文件chapter13\DPatchPEInfo.asm）。

代码清单13-1　读写进程内存的函数`_writeToPEInfo`（chapter13\DPatchPEInfo.asm）

------

```assembly
.386
.model flat,stdcall
option casemap:none

include    windows.inc
include    user32.inc
includelib user32.lib
include    kernel32.inc
includelib kernel32.lib
include    comdlg32.inc
includelib comdlg32.lib


ICO_MAIN equ 1000
DLG_MAIN equ 1000
IDC_INFO equ 1001
IDM_MAIN equ 2000
IDM_OPEN equ 2001
IDM_EXIT equ 2002
IDM_1    equ 4000
IDM_2    equ 4001
IDM_3    equ 4002
IDB_UPDATE equ 5000
UPDATE     equ 6000

STOP_FLAG_POSITION=00404115h
MAJOR_IMAGE_VERSION=1
MINOR_IMAGE_VERSION=0

_QLSuspend typedef proto :dword      ;声明函数
_QLResume  typedef proto :dword      ;声明函数

_ApiSuspend  typedef ptr _QLSuspend  ;声明函数引用
_ApiResume  typedef ptr _QLResume  ;声明函数引用

.data
hInstance   dd ?
hProcess    dd 0
hProcessID  dd 0
phwnd       dd ?
hRichEdit   dd ?
hWinMain    dd ?
hWinEdit    dd ?
szFileName  db MAX_PATH dup(?)
strTitle    db  256 dup(0)
parent      dd 0
szBuffer    db  256 dup(0)
dwPatchDD   dd 1
dwFlag      dd 0
szOut1      db '窗口ID=%d',0
szOut2      db '进程号=%d',0
szOut3      db '进程ID=%d',0
szOut       db '从进程PEInfo.exe中取出的标志位的值为：%08x',0

hNtdll      dd   ?
_suspendProcess _ApiSuspend ?
_resumeProcess  _ApiResume ?

stStartUp	STARTUPINFO		<?>
stProcInfo	PROCESS_INFORMATION	<?> 
hRes        dd ?
hFile       dd ?
dwResSize   dd ?
lpRes       dd ?

.const
szErr1       db 'Error happend when openning.',0
szErr2       db 'Error happend when reading.',0
szErr3       db 'Error happend when getting address.',0

szDllEdit   db 'RichEd20.dll',0
szClassEdit db 'RichEdit20A',0
szFont      db '宋体',0
szTitle     db 'PEInfo by qixiaorui',0

szNtdll     db 'ntdll.dll',0
szSuspend   db 'ZwSuspendProcess',0
szResume    db 'ZwResumeProcess',0

szSrcName   db 'update.exe',0


.code

;----------------
;初始化窗口程序
;----------------
_init proc
  local @stCf:CHARFORMAT
  
  invoke GetDlgItem,hWinMain,IDC_INFO
  mov hWinEdit,eax
  invoke LoadIcon,hInstance,ICO_MAIN
  invoke SendMessage,hWinMain,WM_SETICON,ICON_BIG,eax       ;为窗口设置图标
  invoke SendMessage,hWinEdit,EM_SETTEXTMODE,TM_PLAINTEXT,0 ;设置编辑控件
  invoke RtlZeroMemory,addr @stCf,sizeof @stCf
  mov @stCf.cbSize,sizeof @stCf
  mov @stCf.yHeight,9*20
  mov @stCf.dwMask,CFM_FACE or CFM_SIZE or CFM_BOLD
  invoke lstrcpy,addr @stCf.szFaceName,addr szFont
  invoke SendMessage,hWinEdit,EM_SETCHARFORMAT,0,addr @stCf
  invoke SendMessage,hWinEdit,EM_EXLIMITTEXT,0,-1
  ret
_init endp

;--------------------
; 写内存示例
; 测试方法：首先运行PEInfo.exe
;           显示Kernel32.dll的信息
; 启动该程序,在kernel32.dll显示重定位时单击菜单第一项
; 会发现PEInfo.exe的遍历重定位信息被终止
;--------------------
_writeToPEInfo  proc
  pushad

  ;通过标题获得进程的handle
  invoke GetDesktopWindow
  invoke GetWindow,eax,GW_CHILD
  invoke GetWindow,eax,GW_HWNDFIRST
  mov phwnd,eax
  invoke GetParent,eax
  .if !eax
    mov parent,1
  .endif

  mov eax,phwnd
  .while eax
     .if parent
         mov parent,0   ;复位标志
         ;得到窗口标题文字
         invoke GetWindowText,phwnd,addr strTitle,\
                               sizeof strTitle
         nop
         invoke lstrcmp,addr strTitle,addr szTitle
         .if  !eax
           mov eax,phwnd
           .break
         .endif
     .endif

     ;寻找这个窗口的下一个兄弟窗口
     invoke GetWindow,phwnd,GW_HWNDNEXT 
     mov phwnd,eax
     invoke GetParent,eax
     .if !eax
       invoke IsWindowVisible,phwnd
       .if eax
          mov parent,1
       .endif
     .endif
     mov eax,phwnd
  .endw

  ;mov eax,phwnd  
  ;invoke wsprintf,addr szBuffer,addr szOut1,eax
  ;invoke MessageBox,NULL,addr szBuffer,NULL,MB_OK

  ;根据窗口句柄获取进程ID
  invoke GetWindowThreadProcessId,phwnd,addr hProcessID

  ;mov eax,hProcessID
  ;invoke wsprintf,addr szBuffer,addr szOut2,eax
  ;invoke MessageBox,NULL,addr szBuffer,NULL,MB_OK

  invoke OpenProcess,PROCESS_ALL_ACCESS,\
                     FALSE,hProcessID
  .if !eax
    invoke MessageBox,NULL,addr szErr1,NULL,MB_OK
    jmp @ret
  .endif
  mov hProcess,eax  ;找到的进程句柄在hProcess中


  ;invoke wsprintf,addr szBuffer,addr szOut3,eax
  ;invoke MessageBox,NULL,addr szBuffer,NULL,MB_OK


  ;将进程挂起
  ;invoke _suspendProcess,hProcess

  ;读内存
  invoke ReadProcessMemory,hProcess,STOP_FLAG_POSITION,\
                       addr dwFlag,4,NULL
  .if eax
    ;mov eax,dwFlag  
    ;invoke wsprintf,addr szBuffer,addr szOut,eax
    ;invoke MessageBox,NULL,addr szBuffer,NULL,MB_OK

    ;写内存，将标志位赋值
    invoke WriteProcessMemory,hProcess,\
                       STOP_FLAG_POSITION,\
                       addr dwPatchDD,4,NULL
  .else
    invoke MessageBox,NULL,addr szErr2,NULL,MB_OK
    jmp @ret
  .endif

  ;继续进程的运行
  ;invoke _resumeProcess,hProcess
  invoke CloseHandle,hProcess

@ret:
  popad
  ret
_writeToPEInfo  endp

;--------------------------
; 释放资源
;--------------------------
_createDll proc _hInstance
  local @dwWritten

  pushad

  ;寻找资源
  invoke FindResource,_hInstance,IDB_UPDATE,UPDATE
  .if eax
    mov hRes,eax
    invoke SizeofResource,_hInstance,eax ;获取资源尺寸
    mov dwResSize,eax
    invoke LoadResource,_hInstance,hRes ;装入资源
    .if eax
         invoke LockResource,eax ;锁定资源
         .if eax
             mov lpRes,eax  ;将资源内存地址给lpRes

             ;打开文件写入
             invoke CreateFile,addr szSrcName,GENERIC_WRITE,\
                                            FILE_SHARE_READ,\
                          0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0
             mov hFile,eax
             invoke WriteFile,hFile,lpRes,dwResSize,\
                                        addr @dwWritten,NULL
             invoke CloseHandle,hFile      
         .endif
    .endif
  .endif
  popad
  ret
_createDll endp
;-------------------
; 窗口程序
;-------------------
_ProcDlgMain proc uses ebx edi esi hWnd,wMsg,wParam,lParam
  local @value

  mov eax,wMsg
  .if eax==WM_CLOSE
    invoke EndDialog,hWnd,NULL
  .elseif eax==WM_INITDIALOG  ;初始化
    push hWnd
    pop hWinMain
    call _init
  .elseif eax==WM_COMMAND  ;菜单
    mov eax,wParam
    .if eax==IDM_EXIT       ;退出
      invoke EndDialog,hWnd,NULL 
    .elseif eax==IDM_OPEN   ;停止
      invoke _writeToPEInfo
    .elseif eax==IDM_1      ;升级
      ;写入三个变量
      invoke GetWindowThreadProcessId,hWnd,addr @value
      mov eax,@value

      mov ebx,0040528eh
      mov dword ptr [ebx],eax
    
      mov ax,MAJOR_IMAGE_VERSION
      mov word ptr [ebx+4],ax
      mov ax,MINOR_IMAGE_VERSION
      mov word ptr [ebx+6],ax

      ;释放update.exe程序
      invoke _createDll,hInstance

      ;运行update.exe程序
      invoke GetStartupInfo,addr stStartUp
      invoke CreateProcess,NULL,addr szSrcName,NULL,NULL,\
                      NULL,NORMAL_PRIORITY_CLASS,NULL,NULL,\
                      offset stStartUp,offset stProcInfo 

    .elseif eax==IDM_2
    .elseif eax==IDM_3
    .endif
  .else
    mov eax,FALSE
    ret
  .endif
  mov eax,TRUE
  ret
_ProcDlgMain endp

start:
  invoke LoadLibrary,offset szDllEdit
  mov hRichEdit,eax

  invoke LoadLibrary,offset szNtdll
  mov hNtdll,eax
  invoke GetProcAddress,hNtdll,addr szSuspend
  mov _suspendProcess,eax

  .if !eax
    invoke MessageBox,NULL,addr szErr3,NULL,MB_OK
  .endif

  invoke GetProcAddress,hNtdll,addr szResume
  mov _resumeProcess,eax

  .if !eax
    invoke MessageBox,NULL,addr szErr3,NULL,MB_OK
  .endif


  invoke GetModuleHandle,NULL
  mov hInstance,eax
  invoke DialogBoxParam,hInstance,\
         DLG_MAIN,NULL,offset _ProcDlgMain,NULL
  invoke FreeLibrary,hRichEdit
  invoke ExitProcess,NULL
  end start

```

------

==`STOP_FLAG_POSITION`是PEInfo.asm中定义的标志`dwFlag`所在进程地址空间中的VA值==。==该位置可以通过以下方法计算出来==：

==首先，找到dwFlag变量在文件中的位置（加黑部分）（静态分析）==：

![image](https://github.com/YangLuchao/img_host/raw/master/20231018/image.1fsc132dic0w.jpg)

如上所示，==标志字节dwFlag在文件地址0x00002510==处。通过PEInfo小工具查看该文件的所有的节的相关信息，结果如下：

![image](https://github.com/YangLuchao/img_host/raw/master/20231018/image.4k2dohlzez60.jpg)

==根据RVA和FOA的换算关系可以得出，停止标志位的内存地址（VA）为：`0x00404115`==。在DPatchPEInfo.asm的开始部分声明一个常量即可：

------

```cpp
STOP_FLAG_POSITION = 00404115h
```

------

#### （3）运行测试

接下来，就是见证奇迹的时刻。==整体思路是：当PEInfo小工具运行时，如果用户发现要获取的信息已经输出，则可以通过另外一个程序终止PEInfo代码的运行（注意，不是终止进程的运行），看起来好像这个补丁程序也参与了PEInfo指令代码的流程控制过程==。

现在来看该动态补丁的三要素：

1. 1）==该补丁可以读写PEInfo.exe的进程内存==。
2. 2）==该补丁的调用时机由用户判断==。==当发现需要的信息已经输出，即选择菜单选项“文件”|“停止遍历重定位表”，补丁会立刻生效，补丁的位置已经事先计算出来了==。
3. 3）尽管补丁没有实现代码部分，为了简化任务，代码事先已经安排到原始程序中等待补丁对它的激活。以后我们看到的大部分的动态补丁则是将要追加的代码通过补丁工具直接写入补丁程序。

> 扩展阅读　关于热补
>
> ==通常情况下，补丁程序总是在被补丁的程序后期开发的，有时候，为了后期补丁方便，有些程序会事先给自己留一个“后门”==。比如，微软的大部分内核函数，检查Windows的ntdll.dll中大部分函数的源代码，其起始位置的代码看起来总是这样的：
>
> ------
>
> ```assembly
> MOV EDI,EDI
> PUSH EBP
> MOV EBP,ESP
> ```
>
> ------
>
> ==`mov edi,edi`指令为两个字节，可以存放短跳转指令，短跳转指令指向的位置可以存放一个指向长跳转指令的地址，从而在运行期实现热补（hotfix）==。
>
> 在Visual C++的编译器选项中也有类似的参数/hotpatch可以创建可热修补的PE映像。
>
> 以上只是演示了一个思路，大家可以在此基础上自行添加功能，比如==提升补丁工具的权限、修改进程空间代码、增强内存读写能力等==。

## 13.1.3　目标进程枚举

==在进行动态补丁时，有一步是必需的，即获取目标进程的句柄或者ID号==。通过枚举系统进程即可获取这些信息。

### 1.枚举系统进程的方法

==枚举Win32子系统进程的方法很多，常见的有以下四种==。

#### （1）==调用PSAPI.DLL提供的函数==

该动态链接库是微软Windows NT开发小组开发的与进程有关的函数集。核心函数包括：

![image](https://github.com/YangLuchao/img_host/raw/master/20231018/image.4pl2w5mncn80.jpg)

#### （2）==调用ToolHelp API提供的函数==

==ToolHelp32函数是一组存储在Kernel32.dll中的Windows API函数，它能够通过Snapshot获得驻留在系统内存中的进程表、线程表、模块表和堆表==。核心函数包括：

![image](https://github.com/YangLuchao/img_host/raw/master/20231018/image.6mymbazafpw0.jpg)

#### （3）==调用ntdll.dll中未公开的API函数==

==在ntdll.dll中，有一组以NtQuery开头的函数集，利用其中的函数可以获取系统相关数据结构的信息，其中就包括进程信息==。核心函数包括：

![image](https://github.com/YangLuchao/img_host/raw/master/20231018/image.27mi11krwxzw.jpg)

#### （4）==调用PDH.DLL中的API函数==

==PDH（Performance Data Helper，性能数据辅助数据库）中包含了大量的信息，例如CPU使用率、内存使用率、系统进程信息等==；==该数据库既可以通过注册表函数来访问，也可以通过动态链接库PDH.DLL提供的系列函数来访问==。核心函数包括：

![image](https://github.com/YangLuchao/img_host/raw/master/20231018/image.16ifxs4fwnsw.jpg)

### 2.==遍历系统进程示例分析==

下面以第二种方法为例，即调用ToolHelp API提供的函数，实现遍历系统进程，以获取指定进程关联模块列表。

#### （1）源代码

获取指定进程关联模块列表的源代码见代码清单13-2。

代码清单13-2　获取指定进程关联模块列表函数（chapter13\\`qltools.asm`）

------

```assembly
;-----------------------
; 获取指定进程关联模块列表
;-----------------------
_GetModuleList proc uses ebx esi edi processID:DWORD
          local temp:BOOL

          invoke SendMessage,hModuleShowList,LB_RESETCONTENT,0,0
          mov ebx,processID
          invoke CreateToolhelp32Snapshot,TH32CS_SNAPMODULE,ebx
          mov hModuleSnapshot,eax
          invoke Module32First,hModuleSnapshot,addr process_ME

          mov temp,eax
          .while temp
             .if process_ME.th32ProcessID==ebx
                 invoke SendMessage,hModuleShowList,LB_ADDSTRING,\
                       0,addr process_ME.szExePath
             .endif
             invoke Module32Next,hModuleSnapshot,addr process_ME
             mov temp,eax
          .endw
          ret
_GetModuleList endp
          
;-----------------------
; 获取进程列表
;-----------------------
_GetProcessList   proc   _hWnd
          local temp:BOOL

          invoke RtlZeroMemory,addr process_PE,sizeof process_PE
          invoke SendMessage,hProcessListBox,LB_RESETCONTENT,0,0
          mov process_PE.dwSize,sizeof process_PE
          invoke CreateToolhelp32Snapshot,TH32CS_SNAPPROCESS,0
          mov hProcessSnapshot,eax
          
          invoke Process32First,hProcessSnapshot,addr process_PE
          .while eax
              invoke SendMessage,hProcessListBox,LB_ADDSTRING,\
                     0,addr process_PE.szExeFile
              invoke SendMessage,hProcessListBox,LB_SETITEMDATA,eax,\
                     process_PE.th32ProcessID
              invoke Process32Next,hProcessSnapshot,addr process_PE
          .endw
          invoke CloseHandle,hProcessSnapshot
          ;选中第一项
          invoke SendMessage,hProcessListBox,LB_SETCURSEL,0,0          
          invoke SendMessage,hProcessListBox,LB_GETITEMDATA,eax,0
          invoke _GetModuleList,eax

          invoke GetDlgItem,_hWnd,IDOK
          invoke EnableWindow,eax,FALSE
          ret
_GetProcessList endp
```

------

行34通过调用函数`CreateToolhelp32Snapshot`获取`Snapshot`。

行37调用`Process32First`从`Snapshot`中获取第一个进程所对应的磁盘文件。

行38～44是一个循环，通过调用函数`Process32Next`完成对`Snapshot`中进程的遍历。

主程序通过以下代码调用两个函数：

------

```assembly
;--------------------------
; 结束进程窗口程序
;--------------------------
_ProcKillMain   proc  uses ebx edi esi hProcessKillDlg:HWND,wMsg,wParam,lParam
          mov eax,wMsg

          .if eax==WM_CLOSE
             invoke EndDialog,hProcessKillDlg,NULL
          .elseif eax==WM_INITDIALOG
             invoke GetDlgItem,hProcessKillDlg,IDC_PROCESS
             mov hProcessListBox,eax
             invoke GetDlgItem,hProcessKillDlg,IDC_PROCESS_MODEL
             mov hModuleShowList,eax
             ;显示进程，并把第一项进程的映射模块也显示出来
             invoke _GetProcessList,hProcessKillDlg 
          .elseif eax==WM_COMMAND
             mov eax,wParam
             .if ax==IDOK
                 invoke SendMessage,hProcessListBox,LB_GETCURSEL,0,0
                 invoke SendMessage,hProcessListBox,\
                        LB_GETITEMDATA,eax,0

                 invoke _RunThread,eax

                 invoke Sleep,200
                 invoke _GetProcessList,hProcessKillDlg
                 jmp @F
                 invoke MessageBox,hProcessKillDlg,addr szErrTerminate,\
                      NULL,MB_OK or MB_ICONWARNING
                 @@:
             .elseif ax==IDC_REFRESH
                 invoke SendMessage,hProcessListBox,LB_RESETCONTENT,0,0
                 invoke CreateToolhelp32Snapshot,TH32CS_SNAPPROCESS,0

                 mov hProcessSnapshot,eax
                 invoke _GetProcessList,hProcessKillDlg
             .elseif ax==IDC_PROCESS
                 shr eax,16
                 .if ax==LBN_SELCHANGE
                     invoke SendMessage,hProcessListBox,LB_GETCURSEL,0,0
                     invoke SendMessage,hProcessListBox,LB_GETITEMDATA,\
                         eax,0
                     invoke _GetModuleList,eax ;重新显示映射的模块
                     invoke GetDlgItem,hProcessKillDlg,IDOK
                     invoke EnableWindow,eax,TRUE
                 .endif
             .endif
         .else
             mov eax,FALSE
             ret
         .endif
         mov eax,TRUE
         ret
_ProcKillMain    endp

```

------

#### （2）测试运行

运行界面见图13-2。

![image](https://github.com/YangLuchao/img_host/raw/master/20231018/image.4xbty834yj60.jpg)

图　13-2　枚举系统进程运行界面

## 13.1.4　执行远程线程

==大部分的动态补丁最后一步要实现代码的运行，即确保插入到目标进程内存的数据要具备运行权，并能最终运行起来==。==在一个进程中要运行插入的代码，最好的办法就是通过远程线程技术，即将一段代码挂接到目标进程中，并指定代码块作为该目标进程的一个线程来运行==。

### 1.相关函数

Windows API为远程线程执行提供了函数支持。以下是大致的步骤：

1. **步骤1**　使用`OpenProcess`函数打开目标进程，获取进程操作句柄。
2. **步骤2**　使用`VirtualAllocEx`函数在目标进程中分配内存。
3. **步骤3**　使用`WriteProcessMemory`函数将远程代码写入。
4. **步骤4**　使用`CreateRemoteThread`函数在目标进程中创建远程线程并执行。

`OpenProcess`函数和`WriteProcessMemory`函数在13.1.2小节已介绍过，下面重点介绍另外两个函数。

#### （1）`VirtualAllocEx`函数

`VirtualAllocEx`函数内存分配函数的原型如下：

------

```c
LPVOID VirtualAllocEx(
	HANDLE hProcess,		//申请内存所在的进程句柄
	LPVOID lpAddress,		//保留页面的内存地址，NULL表示自动分配
	SIZE_T dwSize,			//欲分配的内存大小
	DWORD flAllocationType, //内存分配属性
	DWORD flProtect			//分配区页面属性
);
```

------

其中各参数解释如下：

##### 1）flAllocationType，内存分配属性，可取下列值：

`MEM_COMMIT`，为特定的页面区域分配内存中或磁盘的页面文件中的物理存储。

`MEM_PHYSICAL`，分配物理内存（仅用于地址窗口扩展内存）。

`MEM_RESERVE`，保留进程的虚拟地址空间，而不分配任何物理存储。保留页面可通过继续调用函数VirtualAlloc而被占用，直到最终提交。

`MEM_RESET`，指明在内存中由参数lpAddress和dwSize指定的数据无效。

`MEM_TOP_DOWN`，在尽可能高的地址上分配内存。

##### 2）FlProtect，分配区的页面属性，可取下列值：

`PAGE_READONLY`区域为只读，如果应用程序试图访问区域中的页的时候，将会被拒绝访问。

`PAGE_READWRITE`区域可被应用程序读写。

`PAGE_EXECUTE`区域包含可被系统执行的代码。试图读写该区域的操作将被拒绝。

`PAGE_EXECUTE_READ`区域包含可执行代码，应用程序可以读该区域。

`PAGE_EXECUTE_READWRITE`区域包含可执行代码，应用程序可以读写该区域。

`PAGE_GUARD`区域第一次被访问时进入一个`STATUS_GUARD_PAGE`异常，这个标志要和其他保护标志合并使用，表明区域被第一次访问的权限。

`PAGE_NOACCESS`，任何访问该区域的操作将被拒绝。

`PAGE_NOCACHE` RAM中的页映射到该区域时将不会被微处理器缓存（cached）。

> 注意　==`PAGE_GUARD`和`PAGE_NOCHACHE`标志可以和其他标志合并使用，以进一步指定页的特征==。`PAGE_GUARD`标志指定了一个防护页（guard page），即当一个页被提交时会因第一次被访问而产生一个`one-shot`异常，接着取得指定的访问权限。`PAGE_NOCACHE`防止当它映射到虚拟页的时候被微处理器缓存，这个标志方便设备驱动使用直接内存访问方式（DMA）来共享内存块。
>

==返回值：如果执行成功就返回分配内存的首地址，不成功则返回NULL。==

#### （2）`CreateRemoteThread`函数

`CreateRemoteThread`函数的原型如下：

------

```c
HANDLE CreateRemoteThread(
	HANDLE hProcess,							//目标进程句柄
	LPSECURITY_ATTRIBUTES lpThreadAttributes,	//安全属性
	SIZE_T dwStackSize,							//线程栈大小
	LPTHREAD_START_ROUTINE lpStartAddress,		//线程起始地址
	LPVOID lpParameter,							//传入参数
	DWORD dwCreationFlags,						//创建标志字
	LPDWORD lpThreadId							//（输出）线程句柄
);
```

------

各参数解释如下：

1）`hProcess`，目标进程句柄。

2）`lpThreadAttributes`，线程安全描述字，一个指向`SECURITY_ATTRIBUTES`结构的指针。

3）`dwStackSize`，线程栈大小，以字节表示。

4）`lpStartAddress`，一个`LPTHREAD_START_ROUTINE`类型的指针，指向在远程进程中执行的函数地址。

5）`lpParameter`，传入参数。

6）`dwCreationFlags`，创建线程的其他标志。

7）`lpThreadId`，（输出），返回线程号，如果为NULL，则不返回。

8）==返回值：如果成功返回新线程句柄，失败返回NULL，并且可调用`GetLastError`获得错误值==。

### 2.向目标进程植入远程线程示例分析

本示例的目标是在进程PEInfo.exe中插入一个线程代码，运行并显示HelloWorldPE弹出对话框。

#### （1）源代码

向目标进程植入远程线程的部分源代码见代码清单13-3。

代码清单13-3　向目标进程植入远程线程（chapter13\remoteThread.asm）

------

```assembly
.code

REMOTE_THREAD_START equ this byte
;------------------------------------
; 获取kernel32.dll的基地址
;------------------------------------
_getKernelBase  proc
   local @dwRet

   pushad

   assume fs:nothing
   mov eax,fs:[30h] ;获取PEB所在地址
   mov eax,[eax+0ch] ;获取PEB_LDR_DATA 结构指针
   mov esi,[eax+1ch] ;获取InInitializationOrderModuleList 链表头
   ;第一个LDR_MODULE节点InInitializationOrderModuleList成员的指针
   lodsd             ;获取双向链表当前节点后继的指针
   mov eax,[eax+8]   ;获取kernel32.dll的基地址
   mov @dwRet,eax
   popad
   mov eax,@dwRet
   ret
_getKernelBase  endp   

;-------------------------------
; 获取指定字符串的API函数的调用地址
; 入口参数：_hModule为动态链接库的基址
;           _lpApi为API函数名的首址
; 出口参数：eax为函数在虚拟地址空间中的真实地址
;-------------------------------
_getApi proc _hModule,_lpApi
   local @ret
   local @dwLen

   pushad
   mov @ret,0
   ;计算API字符串的长度，含最后的零
   mov edi,_lpApi
   mov ecx,-1
   xor al,al
   cld
   repnz scasb
   mov ecx,edi
   sub ecx,_lpApi
   mov @dwLen,ecx

   ;从pe文件头的数据目录获取导出表地址
   mov esi,_hModule
   add esi,[esi+3ch]
   assume esi:ptr IMAGE_NT_HEADERS
   mov esi,[esi].OptionalHeader.DataDirectory.VirtualAddress
   add esi,_hModule
   assume esi:ptr IMAGE_EXPORT_DIRECTORY

   ;查找符合名称的导出函数名
   mov ebx,[esi].AddressOfNames
   add ebx,_hModule
   xor edx,edx
   .repeat
     push esi
     mov edi,[ebx]
     add edi,_hModule
     mov esi,_lpApi
     mov ecx,@dwLen
     repz cmpsb
     .if ZERO?
       pop esi
       jmp @F
     .endif
     pop esi
     add ebx,4
     inc edx
   .until edx>=[esi].NumberOfNames
   jmp _ret
@@:
   ;通过API名称索引获取序号索引再获取地址索引
   sub ebx,[esi].AddressOfNames
   sub ebx,_hModule
   shr ebx,1
   add ebx,[esi].AddressOfNameOrdinals
   add ebx,_hModule
   movzx eax,word ptr [ebx]
   shl eax,2
   add eax,[esi].AddressOfFunctions
   add eax,_hModule
   
   ;从地址表得到导出函数的地址
   mov eax,[eax]
   add eax,_hModule
   mov @ret,eax

_ret:
   assume esi:nothing
   popad
   mov eax,@ret
   ret
_getApi endp

_remoteThread  proc uses ebx edi esi lParam 
    
    call @F   ; 免去重定位
@@:
    pop ebx
    sub ebx,offset @B

    ;获取kernel32.dll的基地址
    invoke _getKernelBase
    mov [ebx + offset hKernel32Base],eax

    ;从基地址出发搜索GetProcAddress函数的首址
    mov eax,offset szGetProcAddr
    add eax,ebx

    mov edi,offset hKernel32Base
    mov ecx,[ebx + edi]


    invoke _getApi,ecx,eax
    mov [ebx + offset lpGetProcAddr],eax

    ;为函数引用赋值 GetProcAddress
    mov [ebx + offset _getProcAddress],eax   

    ;使用GetProcAddress函数的首址
    ;传入两个参数调用GetProcAddress函数，获得LoadLibraryA的首址
    mov eax,offset szLoadLib
    add eax,ebx
   
    mov edi,offset hKernel32Base
    mov ecx,[ebx+edi]
    
    mov edx,offset _getProcAddress
    add edx,ebx
    
    ;模仿调用 invoke GetProcAddress,hKernel32Base,addr szLoadLib
    push eax
    push ecx
    call dword ptr [edx]   

    mov [ebx+offset _loadLibrary],eax

    ;使用LoadLibrary获取user32.dll的基地址

    mov eax,offset user32_DLL
    add eax,ebx

    mov edi,offset _loadLibrary
    mov edx,[ebx+edi]
    
    push eax
    call edx   ; invoke LoadLibraryA,addr _loadLibrary

    mov [ebx+offset hUser32Base],eax

    ;使用GetProcAddress函数的首址，获得函数MessageBoxA的首址
    mov eax,offset szMessageBox
    add eax,ebx
   
    mov edi,offset hUser32Base
    mov ecx,[ebx+edi]
    
    mov edx,offset _getProcAddress
    add edx,ebx


    ;模仿调用 invoke GetProcAddress,hUser32Base,addr szMessageBox
    push eax
    push ecx
    call dword ptr [edx]   
    mov [ebx+offset _messageBox],eax

    ;调用函数MessageBoxA
    mov eax,offset szText
    add eax,ebx

    mov edx,offset _messageBox
    add edx,ebx

    ;模仿调用 invoke MessageBoxA,NULL,addr szText,NULL,MB_OK    
    push MB_OK
    push NULL
    push eax
    push NULL
    call dword ptr [edx]   
    ret
_remoteThread endp

;------------------------------------------------
; 远程线程用到的数据
;------------------------------------------------
szText         db  'HelloWorldPE',0
szGetProcAddr  db  'GetProcAddress',0
szLoadLib      db  'LoadLibraryA',0
szMessageBox   db  'MessageBoxA',0

user32_DLL     db  'user32.dll',0,0

;定义函数
_getProcAddress _ApiGetProcAddress  ?             
_loadLibrary    _ApiLoadLib         ?
_messageBox     _ApiMessageBoxA     ?


hKernel32Base   dd  ?
hUser32Base     dd  ?
lpGetProcAddr   dd  ?
lpLoadLib       dd  ?

REMOTE_THREAD_END equ this byte
REMOTE_THREAD_SIZE = offset REMOTE_THREAD_END-offset REMOTE_THREAD_START

;----------------
;初始化窗口程序
;----------------
_init proc
  local @stCf:CHARFORMAT
  
  invoke GetDlgItem,hWinMain,IDC_INFO
  mov hWinEdit,eax
  invoke LoadIcon,hInstance,ICO_MAIN
  invoke SendMessage,hWinMain,WM_SETICON,ICON_BIG,eax       ;为窗口设置图标
  invoke SendMessage,hWinEdit,EM_SETTEXTMODE,TM_PLAINTEXT,0 ;设置编辑控件
  invoke RtlZeroMemory,addr @stCf,sizeof @stCf
  mov @stCf.cbSize,sizeof @stCf
  mov @stCf.yHeight,9*20
  mov @stCf.dwMask,CFM_FACE or CFM_SIZE or CFM_BOLD
  invoke lstrcpy,addr @stCf.szFaceName,addr szFont
  invoke SendMessage,hWinEdit,EM_SETCHARFORMAT,0,addr @stCf
  invoke SendMessage,hWinEdit,EM_EXLIMITTEXT,0,-1
  ret
_init endp

;--------------------
; 将远程线程打到进程PEInfo.exe中
; 测试方法：首先运行PEInfo.exe
; 启动该程序,单击第一个菜单的第一项
; 会发现桌面上弹出HelloWorldPE对话框
;--------------------
_patchPEInfo  proc
  local @dwTemp

  pushad

  ;通过标题获得进程的handle
  invoke GetDesktopWindow
  invoke GetWindow,eax,GW_CHILD
  invoke GetWindow,eax,GW_HWNDFIRST
  mov phwnd,eax
  invoke GetParent,eax
  .if !eax
    mov parent,1
  .endif

  mov eax,phwnd
  .while eax
     .if parent
         mov parent,0   ;复位标志
         ;得到窗口标题文字
         invoke GetWindowText,phwnd,addr strTitle,\
                               sizeof strTitle
         nop
         invoke lstrcmp,addr strTitle,addr szTitle
         .if  !eax
           mov eax,phwnd
           .break
         .endif
     .endif

     ;寻找这个窗口的下一个兄弟窗口
     invoke GetWindow,phwnd,GW_HWNDNEXT 
     mov phwnd,eax
     invoke GetParent,eax
     .if !eax
       invoke IsWindowVisible,phwnd
       .if eax
          mov parent,1
       .endif
     .endif
     mov eax,phwnd
  .endw

  ;mov eax,phwnd  
  ;invoke wsprintf,addr szBuffer,addr szOut1,eax
  ;invoke MessageBox,NULL,addr szBuffer,NULL,MB_OK

  ;根据窗口句柄获取进程ID
  invoke GetWindowThreadProcessId,phwnd,addr hProcessID

  ;mov eax,hProcessID
  ;invoke wsprintf,addr szBuffer,addr szOut2,eax
  ;invoke MessageBox,NULL,addr szBuffer,NULL,MB_OK

  invoke OpenProcess,PROCESS_ALL_ACCESS,\
                     FALSE,hProcessID
  .if !eax
    invoke MessageBox,NULL,addr szErr1,NULL,MB_OK
    jmp @ret
  .endif
  mov hProcess,eax  ;找到的进程句柄在hProcess中


  ;invoke wsprintf,addr szBuffer,addr szOut3,eax
  ;invoke MessageBox,NULL,addr szBuffer,NULL,MB_OK

  ;分配空间
  invoke VirtualAllocEx,hProcess,NULL,\
               REMOTE_THREAD_SIZE,MEM_COMMIT,\
               PAGE_EXECUTE_READWRITE
  .if eax
      mov lpRemote,eax
      ;写入线程代码
      invoke WriteProcessMemory,hProcess,\
                       lpRemote,\
                       offset REMOTE_THREAD_START,\
                       REMOTE_THREAD_SIZE,\
                       addr @dwTemp
      mov eax,lpRemote
      add eax,offset _remoteThread-offset REMOTE_THREAD_START
      invoke CreateRemoteThread,hProcess,NULL,0,eax,0,0,NULL
  .endif

  invoke CloseHandle,hProcess

@ret:
  popad
  ret
_patchPEInfo  endp


;-------------------
; 窗口程序
;-------------------
_ProcDlgMain proc uses ebx edi esi hWnd,wMsg,wParam,lParam
  mov eax,wMsg
  .if eax==WM_CLOSE
    invoke EndDialog,hWnd,NULL
  .elseif eax==WM_INITDIALOG  ;初始化
    push hWnd
    pop hWinMain
    call _init
  .elseif eax==WM_COMMAND  ;菜单
    mov eax,wParam
    .if eax==IDM_EXIT       ;退出
      invoke EndDialog,hWnd,NULL 
    .elseif eax==IDM_OPEN   ;停止
      invoke _patchPEInfo
    .elseif eax==IDM_1  
    .elseif eax==IDM_2
    .elseif eax==IDM_3
    .endif
  .else
    mov eax,FALSE
    ret
  .endif
  mov eax,TRUE
  ret
_ProcDlgMain endp
```

------

程序思路很清晰，由`REMOTE_THREAD_START`和`REMOTE_THREAD_END`将线程代码（行68～274）包裹起来，代码中包含定义的数据变量；其中，定义远程线程函数`_remoteThread`（行164～251）是最终进入到目标进程要执行的线程函数。代码的编写采用了第6章的免重定位技术和第11章介绍的动态加载技术。

行309～352通过==遍历并匹配操作系统打开的窗口标题得到PEInfo进程的进程号==。

行358～364使用==函数`OpenProcess`打开PEInfo进程==。

行370～373使用==函数`VirtualAllocEx`在打开的PEInfo进程中分配内存==。

行377～381使用==函数`WriteProcessMemory`将线程代码（含数据）部分写入到目标进程地址空间==。

行382～384使用==函数`CreateRemoteThread`在PEInfo进程空间执行`_remoteThread`，并将其作为进程的一个独立的线程运行==。

#### （2）运行测试

从运行结果看，弹出的对话框继承了所属进程的部分特性，比如图标，见图13-3。

![image](https://github.com/YangLuchao/img_host/raw/master/20231018/image.4j9q662drew0.jpg)

图　13-3　错误提示对话框

> 提示　==链接remotethread.obj时需要指定代码段属性为可读、可写和可执行==。
>

# 13.2　静态补丁

13.1节介绍的==动态补丁是针对PE映像内存空间==的，本节要介绍的==静态补丁技术则是针对PE本身及相关联文件==的。==静态补丁常用于PE加密、汉化、软件升级等领域==。

==静态补丁可以通过对PE文件进行整体替换、对动态链接库进行替换、部分修改PE文件==，==即向PE文件附加代码并劫持映像入口等技术来实现==，下面将分别讲述。

## 13.2.1　整体替换PE文件

==软件升级时，经常要做的事情就是对旧版的PE文件实施整体替换==，下面以一个通过网络环境自动完成程序升级的例子来介绍这种静态补丁技术。其基本思路如下：

### 1.设置网络升级环境

在网络上放置两个文件，一个是PE版本描述文件，一个是PE新版本文件。在本例中分别为：

http://10.112.132.100/version.ini

http://10.112.132.100/soft/DPatchPEInfo_1_0.exe

PE版本描述文件由客户端下载，并识别客户端当前部署的程序是否为新版本；PE新版本文件则用于替换客户端旧版本文件。`version.ini`的内容如下：

------

```assembly
[DPatchPEInfo.exe]
majorImageVersion = 1 ;主版本
minorImageVersion = 0 ;子版本
downloadfile = DPatchPEInfo_1_0.exe ;下载文件
[PEInfo.exe]
majorImageVersion = 1
minorImageVersion = 1
downloadfile = PEInfo_1_1.exe
……
```

------

`version.ini`文件中记录了两个可以升级的文件，通过这种方式可以定义更多的供客户升级的文件，每个文件均由以下三个项构成：

`majorImageVersion`（程序主版本号）

`minorImageVersion`（程序次版本号）

`downloadfile`（部署在服务器上的该版本对应的文件名称）

### 2.用户执行升级程序

由用户运行升级程序update.exe，该程序从网络下载PE版本描述文件，并与当前PE文件版本进行比对；如果发现当前版本低，则下载对应的新版本文件，并保存。

在对比时，可以使用PE文件头部的两个字段：

```assembly
IMAGE_OPTIONAL_HEADER32.MajorImageVersion（记录主版本号）
IMAGE_OPTIONAL_HEADER32.MinorImageVersion（记录次版本号）
```

主进程在释放update.exe以后，将该信息连同进程的PID号一起写入update.exe文件的指定位置，便于update.exe实施对比，下载文件与判断是否新版本的操作均在update.exe里完成。当然，大家也可以在主程序里维护这两个变量，而无需将版本信息写入PE头部，运行效果是一样的。

### 3.完成新版本文件的替换

update.exe提示用户有新程序可升级，从服务器上下载`version.ini`中记录的新版本文件，结束当前运行的旧版本的PE文件对应的进程，并通过重命名的方式实现新版本文件与旧版本文件的替换。

> **注意**　==update.exe升级程序是以资源的形式存储到DPatchPEInfo.exe文件的，直到用户选择了升级菜单选项才被释放出来，并执行升级操作==。

升级程序`update.asm`的源代码见代码清单13-4。

代码清单13-4　软件升级程序（chapter13\update.asm）

------

```assembly
;------------------------
; 补丁升级程序
; 戚利
; 2010.11.28
;------------------------
    .386
    .model flat,stdcall
    option casemap:none

include    windows.inc
include    user32.inc
includelib user32.lib
include    kernel32.inc
includelib kernel32.lib
include    urlmon.inc
includelib urlmon.lib

;数据段
    .data
szINI          db '下载配置文件：http://10.112.132.100/version.ini',0
szIsNewVesion  db '程序已经是最新版本',0
szLINI         db '.\_tmp.ini',0

hProcessID   dd ?  ;主进程释放时会修改此处的三个值  
oldMajor     dw 0  ; 分别是：主程序进程号，主次旧版本的值
oldMinor     dw 0

hProcess     dd ?
newMajor     dw 0
newMinor     dw 0

szOut1     db '%s_%d_%d.exe',0
szOut2     db '下载补丁文件:http://10.112.132.100/soft/%s',0 ;要下载的EXE文件
szFailRead db 256 dup(0)
szSectionName   db  'DPatchPEInfo.exe',0  ;针对不同的程序修改此处的值
szKeyName1    db  'majorImageVersion',0
szKeyName2    db  'minorImageVersion',0
szKeyName3    db  'downloadfile',0


stStartUp	STARTUPINFO		<?>
stProcInfo	PROCESS_INFORMATION	<?> 

szExeFile     db  256 dup(0)
szBuffer      db  256 dup(0)
szDataBuffer  db  256 dup(0)
;代码段
    .code


start:
    invoke MessageBox,NULL,offset szINI,NULL,MB_OK
    ;下载ini文件
    invoke URLDownloadToFile,0, \
                      addr szINI,
                      addr szLINI,0,0
    ;打开分析ini文件
    invoke GetPrivateProfileInt,addr szSectionName,\
                                addr szKeyName1,\
                                0,\
                                addr szLINI
    mov newMajor,ax
    invoke GetPrivateProfileInt,addr szSectionName,\
                                addr szKeyName2,\
                                0,\
                                addr szLINI
    mov newMinor,ax

    ;判断是否是新版本PE

    mov ax,newMajor
    mov bx,newMinor

    .if ax==oldMajor && bx==oldMinor

      ;显示已经是最新版本 
      invoke MessageBox,NULL,offset szIsNewVesion,NULL,MB_OK

    .else
       ;是新版本，则下载该PE，并实施替换

       ;取文件名DPatchPEInfo.exe_1_0.exe

       invoke RtlZeroMemory,addr szDataBuffer,256
       invoke GetPrivateProfileString,addr szSectionName,\
                                   addr szKeyName3,\
                                   NULL,\
                                   addr szDataBuffer,\
                                   sizeof szDataBuffer,\
                                   addr szLINI  ;取文件名

       invoke wsprintf,addr szBuffer,addr szOut2,\
                                   addr szDataBuffer

       invoke MessageBox,NULL,addr szBuffer,NULL,MB_OK

       ;下载exe文件
       invoke URLDownloadToFile,0, \
                      addr szBuffer,
                      addr szDataBuffer,0,0


       ;结束当前主进程
       invoke OpenProcess,PROCESS_ALL_ACCESS,\
                     FALSE,hProcessID
       mov hProcess,eax
       invoke Sleep,1000

       invoke TerminateProcess,hProcess,0
       invoke CloseHandle,hProcess

       invoke Sleep,1000
       ;将下载的文件替换为PE文件
       invoke DeleteFile,addr szSectionName
       invoke CopyFile,addr szDataBuffer,addr szSectionName,\
                                                  TRUE
       invoke Sleep,1000
       ;重启PE程序
       invoke GetStartupInfo,addr stStartUp
       invoke CreateProcess,NULL,addr szSectionName,NULL,NULL,\
                      NULL,NORMAL_PRIORITY_CLASS,NULL,NULL,\
                      offset stStartUp,offset stProcInfo 
    .endif

    invoke ExitProcess,NULL
    end start

```

------

如代码清单所示，升级程序`update.asm`的主要思路是：

行53～56：调用==函数`URLDownloadToFile`下载`version.ini`==。

行57～67：调用==函数`GetPrivateProfileInt`获取文件在服务器上的最新版本号==（包含主版本和次版本）。

行71～74：用==新获取到的版本号与旧版本号对比，判断文件是否需要更新==。在这里要特别注意，旧版本号在本程序中并没有任何一个语句或函数为其赋值。它的值来自另一个程序，这个程序就是释放update.exe的主程序DPatchPEInfo.exe。

行80～123：==要升级的文件在服务器上有新版本，首先通过`version.ini`获得文件名，然后连接网络下载该文件，结束当前主进程，替换旧版本文件==。

至此，补丁更新程序的所有工作都做完了，下面来看要升级的主程序应该做哪些工作。

==`DPatchPEInfo`主程序要做的事情包括：==

#### （1）在资源文件中定义资源

在资源文件`DPatchPEInfo.rc`里定义资源`IDB_UPDATE`，资源的内容为`update.exe`文件的字节码：

------

```cpp
IDB_UPDATE UPDATE "update.exe"
```

------

#### （2）在主程序代码中维护版本

在主程序开始定义两个常量，用来标识主程序的主版本和次版本。该值在释放update.asm时将被传入update.asm的数据段定义的变量中。

------

```cpp
MAJOR_IMAGE_VERSION = 1
MINOR_IMAGE_VERSION = 0
```

------

#### （3）编写调用升级补丁代码

在窗口回调函数中定义对菜单“选项”|“检查网络升级”的响应代码，如下所示：

------

```assembly
.elseif eax == IDM_1 ;升级程序
;写入3个变量
invoke GetWindowThreadProcessId,hWnd,addr @value
mov eax,@value
mov ebx,0040528eh
mov dword ptr [ebx],eax
mov ax,MAJOR_IMAGE_VERSION
mov word ptr [ebx+4],ax
mov ax,MINOR_IMAGE_VERSION
mov word ptr [ebx+6],ax
;释放update.exe程序
invoke _createDll,hInstance
;运行update.exe程序
invoke GetStartupInfo,addr stStartUp
invoke CreateProcess,NULL,addr szSrcName,NULL,NULL,\
NULL,NORMAL_PRIORITY_CLASS,NULL,NULL,\
offset stStartUp,offset stProcInfo
……
```

------

### 4.运行测试

测试通过网络升级的详细步骤包括以下几步：

**步骤1**　正常编译update.asm源代码，链接update.obj生成update.exe文件。

**步骤2**　使用如下命令编译链接直至生成DPatchPEInfo.exe文件。

------

```bash
rc -r DPatchPEInfo.rc
ml -c -coff DPatchPEInfo.asm
link -subsystem:windows -section:.text,ERW -section:.text,ERW DPatchPEInfo.obj DPatchPEInfo.res
```

------

**步骤3**　用OD打开DPatchPEInfo.exe，查找需要修正的两个位置(静态分析)。

![image](https://github.com/YangLuchao/img_host/raw/master/20231018/image.2j1aj8zltrw0.jpg)

黑体部分为三个需要修正的变量位置。如上所示，记录起始地址为`0x0040528e`。

**步骤4**　修正源代码DPatchPEInfo.asm中的部分指令操作数的值。

------

```assembly
;写入3个变量
invoke GetWindowThreadProcessId,hWnd,addr @value
mov eax,@value
mov ebx,0040528eh ;将该值修正为刚记录的值
mov dword ptr [ebx],eax
mov ax,MAJOR_IMAGE_VERSION
mov word ptr [ebx+4],ax
mov ax,MINOR_IMAGE_VERSION
mov word ptr [ebx+6],ax
;释放update.exe程序
invoke _createDll,hInstance
```

------

**步骤5**　重新执行步骤2操作，生成新的DPatchPEInfo.exe文件。

**步骤6**　在服务器上部署“升级文件”与“升级配置文件”，在客户端运行旧版本（通过修改两个常量可改变程序版本）的DPatchPEInfo进行升级。

## 13.2.2　整体替换DLL文件

Windows操作系统在运行程序时大量使用动态链接库技术，所以==静态补丁的目标除了PE文件本身外，还包含与PE文件相关联的动态链接库文件==。==通过对导入函数的持有者DLL进行替换（专业术语为劫持），也可以实现针对PE的静态补丁==。==动态链接库劫持（`DLL HOOK`）技术经常用于病毒与反病毒程序领域==。

### 1.静态DLL调用与动态DLL调用对比

==DLL是用于向主程序提供函数调用的，在大多数的PE中，DLL是被PE加载器加载到进程地址空间的==。==PE程序对DLL的调用分为静态调用和动态调用两种，相对这两种不同的调用方法，DLL劫持的方法也不一样==。

==首先来看针对静态DLL调用的劫持==。==如果有恶意用户在加载前对DLL进行替换，使用一个自己定义的DLL替换程序原有的DLL，且保证替换后的DLL中存在原有DLL中所有函数的实现，那么，当进程运行调用到DLL的函数时，就等于运行了补丁后的DLL==。向静态DLL调用中的主程序实施补丁的流程见图13-4。

![image](https://github.com/YangLuchao/img_host/raw/master/20231018/image.43eqfjuh1o60.jpg)

图　13-4　静态DLL调用的DLL补丁调用流程

如图13-4所示，==静态调用DLL的主程序在被加载器加载到内存前，就已经更换了主程序调用的动态链接库文件。主程序本来应该直接调用原始DLL的，通过定义补丁DLL，使得主程序的调用发生转向，而对原始DLL的调用则转由补丁DLL实现==。

==下面来看针对动态DLL调用的劫持==。==在有些情况下，如PE使用了动态加载技术或者使用了延迟加载导入技术，那就更简单了，在运行期替换DLL都可以==。向动态DLL调用中的主程序实施补丁的流程见图13-5。

![image](https://github.com/YangLuchao/img_host/raw/master/20231018/image.14zljdgf5lj4.jpg)

图　13-5　动态DLL调用的DLL补丁调用流程

==在使用了动态DLL调用（如PE中存在延迟加载导入特性）的程序中，补丁DLL可以在加载前实施，也可以在运行期实施==。而==静态DLL调用的程序则只能在加载前执行补丁程序==。

有一些DLL文件在程序部署时会被复制到系统目录中，与应用程序不在同一个目录，而PE加载器在加载DLL文件时会有一个搜索指定DLL文件的过程，这个过程会按照一个特定顺序的路径逐个查找，当前目录是这个搜索过程中第一个要查找的目录。只要将同名的DLL放置到与应用程序相同的目录下，使得加载程序认定该DLL即为要加载的DLL文件，这样DLL劫持就发生了。

> ==注意　这里提到的动态DLL调用中的“动态”与动态补丁中的“动态”是完全不同的两个概念，动态DLL调用描述的是PE调用DLL的方式，动态补丁则是针对进程的。动态DLL调用与补丁是静态还是动态无关，读者不要被文字表象迷惑了。==

### 2.动态DLL劫持实例

下面通过一个例子，介绍DLL劫持。==本例中的PE文件使用了动态DLL调用，所以发生的劫持是基于动态DLL调用的，替换原始DLL文件的操作可以在运行前进行，也可以在运行期DLL中的函数未调用前进行==。相关文件在随书文件的chapter13\b目录中。以下是实例的详细步骤。

#### 步骤1　编写新的DLL

以winResult.dll为例，==编写新的DLL，通过动态加载原始DLL获取原始DLL中函数的地址==，相关代码如下：

------

```assembly
realDLL db 'C:\windows\winResult.dll',0 ;指定要动态加载的原始DLL文件
hDLL dd ?
szFadeIn db 'FadeInOpen',0
szFadeOut db 'FadeOutClose',0
szHello db 'HelloWorldPE',0
_fadeOutClose _ApiFadeOutClose ? ;原始导出函数地址
_fadeInOpen _ApiFadeInOpen ?
……
;------------------
;DLL入口在入口函数中动态调用原始DLL获取导出函数地址
;------------------
DllEntry proc _hInstance,_dwReason,_dwReserved
	invoke LoadLibrary,offset realDLL
	mov hDLL,eax
	invoke GetProcAddress,hDLL,addr szFadeIn
	mov _fadeInOpen,eax
	invoke GetProcAddress,hDLL,addr szFadeOut
	mov _fadeOutClose,eax
	mov eax,TRUE
	ret
DllEntry endp
```

------

==对原始DLL的加载在新的DLL的入口函数中实现，加载后通过函数`GetProcAddress`获取原始DLL中各函数的地址==，以备后用。

#### 步骤2　重写导出方法

==在新DLL中的相关方法中，先执行补丁代码（这里显示一个对话框），然后跳转到正常的函数处执行==。以`FadeInOpen`函数为例，相关代码如下：

------

```assembly
;--------------------------------------------
;窗口淡入效果，被劫持的API函数
;--------------------------------------------
FadeInOpen proc hWin:DWORD
	invoke MessageBox,NULL,addr szHello,\ ;模拟插入补丁代码
	NULL,MB_OK
	invoke _fadeInOpen,hWin ;调用原始的函数实现函数功能
	ret
FadeInOpen endp
```

------

==要想使劫持发生，需要具备以下三个条件：==

==1）原始的DLL被移动到系统目录，或者被更名。==

==2）新的DLL必须包含所有原始DLL导出的函数。==

==3）新的DLL在执行补丁程序后必须调用原始DLL函数相关代码。==

对DLL的替换及相关的测试请读者自行完成。

## 13.2.3　部分修改PE文件

==与整体替换PE文件所不同的是，部分修改PE文件是向PE文件附加代码==。==这种静态补丁技术又被称为嵌入补丁技术，主要是利用PE变形技术将代码嵌入到原始PE文件里，然后修改程序流程转向以达到运行自己的目的==。它也是PE进阶部分重点讨论的内容，本章随后还会用专门的一节（13.3节）来描述基于这种技术的汇编程序编写。

==PE被加载到内存以后，将执行入口地址指向的代码，该地址由文件头部的字段`IMAGE_OPTIONAL_HEADER32.AddressOfEntryPoint`来决定==。==要想将成段代码嵌入到已发布的PE文件中，需要解决两个问题==：

1. ==一个是代码空间问题==
2. ==一个是流程转向问题==

下面首先来看==流程转向问题，有两种方法可以实现==。关于空间的问题，在后续的章节中将依据不同的补丁方法单独描述。

==**第一种实现方法**，利用补丁工具将入口地址修改为附加补丁代码的起始地址，并保存该原始的入口地址==。

==当进程的第一个线程开始工作的时候，补丁程序先工作，在附加的补丁代码最后有一个跳转指令，由该跳转指令跳转到原始的入口地址处执行==。

流程转向如图13-6所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20231018/image.1hzsltw6m49s.jpg)

图　13-6　将入口地址作为起始地址的流程转向

==**第二种实现方法**是通过覆盖代码实现流程转向。这种方法不需要修改入口地址，而是通过修改入口地址处的代码来完成==，流程转向如图13-7所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20231018/image.2l8gh608zyi0.jpg)

图　13-7　修改入口地址处代码的流程转向

==与第一种方法一样，补丁程序自己要记录原始入口地址位置的指令字节码==。==完成功能返回该处前，首先恢复原始代码处的指令字节码内容，再完成跳转==。

==为了提高补丁代码的可移植性，补丁代码需要完全独立，即所有的代码尽量不与原代码发生关系（除了跳转以外），只有这样才能适应各种目标程序==。==要想实现这个目标，需要在编写补丁代码时，尽量使用**局部（即栈）变量**、**重定位技术**，以及**动态DLL载入技术**==。

# 13.3　嵌入补丁程序

==因为后面的4章内容都是围绕嵌入补丁技术来写的，所以，有必要了解一下该技术的编程方法==。==对嵌入补丁的讨论将会涉及补丁程序本身和补丁工具（将补丁合理合法地嵌入PE文件内部，而不影响PE运行的一个程序）==。本节主要讲补丁程序本身，因为补丁工具会因嵌入补丁所在PE中的位置不同而有所不同，所以补丁工具的编写将分别在接下来的第14～17章中介绍。首先来看嵌入补丁程序框架。

## 13.3.1　==嵌入补丁程序框架==

==框架是一项工作开始的基础==，在第2章我们已经初步领略了使用框架的好处。代码清单13-5是基于汇编语言的嵌入补丁程序框架。

代码清单13-5　嵌入补丁程序框架（chapter13\patch.asm）

------

```assembly
;-------------------------
; 补丁代码
; 本段代码使用了API函数地址动态获取以及重定位技术
; 程序功能：弹出对话框
; 作者：戚利
; 开发日期：2011.2.22
;-------------------------

    .386
    .model flat,stdcall
    option casemap:none

include    windows.inc

;注意此处不静态包含引入任何其他动态链接库

_ProtoGetProcAddress  typedef proto :dword,:dword
_ProtoLoadLibrary     typedef proto :dword

_ApiGetProcAddress    typedef ptr _ProtoGetProcAddress
_ApiLoadLibrary       typedef ptr _ProtoLoadLibrary


;-------------------------------------------
; 补丁代码中引入的其他动态链接库的函数的声明
;-------------------------------------------
_ProtoMessageBox       typedef proto :dword,:dword,:dword,:dword
_ApiMessageBox         typedef ptr _ProtoMessageBox


;被添加到目标文件的代码从这里开始，到APPEND_CODE_END处结束

    .code

jmp _NewEntry

; 以下内容为两个重要函数名
; 几乎所有补丁都必须使用的
szGetProcAddr  db  'GetProcAddress',0
szLoadLib      db  'LoadLibraryA',0

;------------------------------------------------------
; 补丁代码中其他全局变量的定义
;------------------------------------------------------

szUser32Dll    db  'user32.dll',0
szMessageBox   db  'MessageBoxA',0   ;该方法在kernel32.dll中
szHello        db  'HelloWorldPE',0  ;要创建的目录


;-----------------------------
; 错误 Handler
;-----------------------------
_SEHHandler proc _lpException,_lpSEH,_lpContext,_lpDispatcher
  pushad
  mov esi,_lpException
  mov edi,_lpContext
  assume esi:ptr EXCEPTION_RECORD,edi:ptr CONTEXT
  mov eax,_lpSEH
  push [eax+0ch]
  pop [edi].regEbp
  push [eax+8]
  pop [edi].regEip
  push eax
  pop [edi].regEsp
  assume esi:nothing,edi:nothing
  popad
  mov eax,ExceptionContinueExecution
  ret
_SEHHandler endp

;------------------------------------
; 获取kernel32.dll的基地址
;------------------------------------
_getKernelBase  proc
   local @dwRet

   pushad

   assume fs:nothing
   mov eax,fs:[30h] ;获取PEB所在地址
   mov eax,[eax+0ch] ;获取PEB_LDR_DATA 结构指针
   mov esi,[eax+1ch] ;获取InInitializationOrderModuleList 链表头
   ;第一个LDR_MODULE节点InInitializationOrderModuleList成员的指针
   lodsd             ;获取双向链表当前节点后继的指针
   mov eax,[eax+8]   ;获取kernel32.dll的基地址
   mov @dwRet,eax
   popad
   mov eax,@dwRet
   ret
_getKernelBase  endp   

;-------------------------------
; 获取指定字符串的API函数的调用地址
; 入口参数：_hModule为动态链接库的基址
;           _lpApi为API函数名的首址
; 出口参数：eax为函数在虚拟地址空间中的真实地址
;-------------------------------
_getApi proc _hModule,_lpApi
   local @ret
   local @dwLen

   pushad
   mov @ret,0
   ;计算API字符串的长度，含最后的零
   mov edi,_lpApi
   mov ecx,-1
   xor al,al
   cld
   repnz scasb
   mov ecx,edi
   sub ecx,_lpApi
   mov @dwLen,ecx

   ;从pe文件头的数据目录获取导出表地址
   mov esi,_hModule
   add esi,[esi+3ch]
   assume esi:ptr IMAGE_NT_HEADERS
   mov esi,[esi].OptionalHeader.DataDirectory.VirtualAddress
   add esi,_hModule
   assume esi:ptr IMAGE_EXPORT_DIRECTORY

   ;查找符合名称的导出函数名
   mov ebx,[esi].AddressOfNames
   add ebx,_hModule
   xor edx,edx
   .repeat
     push esi
     mov edi,[ebx]
     add edi,_hModule
     mov esi,_lpApi
     mov ecx,@dwLen
     repz cmpsb
     .if ZERO?
       pop esi
       jmp @F
     .endif
     pop esi
     add ebx,4
     inc edx
   .until edx>=[esi].NumberOfNames
   jmp _ret
@@:
   ;通过API名称索引获取序号索引再获取地址索引
   sub ebx,[esi].AddressOfNames
   sub ebx,_hModule
   shr ebx,1
   add ebx,[esi].AddressOfNameOrdinals
   add ebx,_hModule
   movzx eax,word ptr [ebx]
   shl eax,2
   add eax,[esi].AddressOfFunctions
   add eax,_hModule
   
   ;从地址表得到导出函数的地址
   mov eax,[eax]
   add eax,_hModule
   mov @ret,eax

_ret:
   assume esi:nothing
   popad
   mov eax,@ret
   ret
_getApi endp

;------------------------
; 补丁功能部分
; 传入三个参数：
;      _kernel:kernel32.dll的基地址
;      _getAddr:函数GetProcAddress地址
;      _loadLib:函数LoadLibraryA地址
;------------------------
_patchFun  proc _kernel,_getAddr,_loadLib

    ;------------------------------------------------------
    ; 补丁功能代码局部变量定义
    ;------------------------------------------------------

    local hUser32Base:dword
    local _messageBox:_ApiMessageBox    


    pushad


    ;------------------------------------------------------
    ; 补丁功能代码，以下只是一个范例，功能为弹出对话框
    ;------------------------------------------------------


    ;获取user32.dll的基地址
    mov eax,offset szUser32Dll
    add eax,ebx

    mov edx,_loadLib
    push eax
    call edx
    mov hUser32Base,eax


    ;使用GetProcAddress函数的首址，
    ;传入两个参数调用GetProcAddress函数，
    ;获得MessageBoxA的首址
    mov eax,offset szMessageBox
    add eax,ebx
   
    mov edx,_getAddr
    mov ecx,hUser32Base
    push eax
    push ecx
    call edx
    mov _messageBox,eax
    
    ;调用函数MessageBox !!
    mov eax,offset szHello
    add eax,ebx
    mov edx,_messageBox

    push MB_OK
    push NULL
    push eax
    push NULL
    call edx


    popad
    ret
_patchFun  endp


_start  proc
    local hKernel32Base:dword  ;存放kernel32.dll基址

    local _getProcAddress:_ApiGetProcAddress  ;定义函数
    local _loadLibrary:_ApiLoadLibrary

    pushad

    ;获取kernel32.dll的基地址
    lea edx,_getKernelBase
    add edx,ebx
    call edx
    mov hKernel32Base,eax

    ;从基地址出发搜索GetProcAddress函数的首址
    mov eax,offset szGetProcAddr
    add eax,ebx

    mov edi,hKernel32Base
    mov ecx,edi
    lea edx,_getApi
    add edx,ebx

    push eax
    push ecx
    call edx
    mov _getProcAddress,eax

    ;从基地址出发搜索LoadLibraryA函数的首址
    mov eax,offset szLoadLib
    add eax,ebx

    mov edi,hKernel32Base
    mov ecx,edi
    lea edx,_getApi
    add edx,ebx

    push eax
    push ecx
    call edx
    mov _loadLibrary,eax

    ;调用补丁代码
    lea edx,_patchFun
    add edx,ebx

    push _loadLibrary
    push _getProcAddress
    push hKernel32Base
    call edx

    popad
    ret
_start  endp

; EXE文件新的入口地址

_NewEntry:
    call @F   ; 免去重定位
@@:
    pop ebx
    sub ebx,offset @B

    invoke _start
    jmpToStart   db 0E9h,0F0h,0FFh,0FFh,0FFh
    ret
    end _NewEntry
```

------

==黑体部分为一个框架程序的大部分内容，包括`引入函数声明`、`全局数据变量定义`、`局部变量定义`、`补丁功能码`等==。==从框架中可以看出代码流程的转向过程：程序先调用函数`_start`（行297）初始化一些变量；然后，在该函数最后调用了补丁代码程序`_patchFun`（行276～283）；执行完补丁代码以后，通过一个跳转指令E9返回到原始入口地址处执行==。

> 注意　E9指令的地址必须通过补丁工具进行修正。

接下来具体看通用补丁框架的编写规则。

## 13.3.2　嵌入补丁程序编写规则

==在编写补丁程序程序时，必须考虑的因素有==：==对补丁代码中用到的全局变量的数据处理==、==通过DLL基地址和函数名获取其他函数地址的方法==、==补丁函数的调用方法==等。下面分别介绍。

### 1.全局变量及局部变量的数据处理

==对全局变量的引用需要考虑重定位问题==，如下所示：

------

```assembly
195 mov eax,offset szUser32Dll ;全局变量szUser32Dll存放了动态链接库名字字符串
196 add eax,ebx
```

------

==在整个程序框架中，ebx寄存器存放了用于修正全局变量地址的值，获取的全局变量与ebx相加后即可得到重定位后的正确地址==。

局部变量即为栈里的变量，可以直接操作，如：

------

```assembly
201 mov hUser32Base,eax
```

------

### 2.获取DLL基地址方法

==以下代码演示了如何获取某个特定DLL的基地址==。==该DLL以名称字符串标识，通过调用函数`kernel32.dll!LoadLibraryA`将指定的动态链接库加载进内存并得到该动态链接库的基地址==。

------

```assembly
194 ;获取user32.dll的基地址
195 mov eax,offset szUser32Dll ;DLL名字"user32.dll"
196 add eax,ebx ;修正地址
197
198 mov edx,_loadLib ;函数参数3，LoadLibraryA函数VA
199 push eax ;传入修正后的指向DLL名字的指针
200 call edx ;调用LoadLibraryA
```

------

### 3.获取其他函数地址

==知道了函数所在动态链接库的基地址和函数的名字，通过调用函数`GetProcAddress`即可获取动态链接库中的导出函数的地址==：

------

```assembly
206 ;获取MessageBoxA的首址
207 mov eax,offset szMessageBox ;全局变量，需要修正
208 add eax,ebx
209
210 mov edx,_getAddr ;传入的参数2，局部变量，直接赋值
211 mov ecx,hUser32Base ;在函数中定义的局部变量，直接赋值
212 push eax ;将参数压入栈
213 push ecx
214 call edx ;调用函数GetProcAddress
215 mov _messageBox,eax ;在函数中定义的局部变量，直接赋值
```

------

### 4.补丁函数代码调用其他公有函数

==如果在框架中添加了其他函数，那么，在调用这些函数的时候必须通过使用地址的方式==，如下所示：

------

```assembly
248 ;从基地址出发搜索GetProcAddress函数的首址
249 mov eax,offset szGetProcAddr
250 add eax,ebx
251
252 mov edi,hKernel32Base
253 mov ecx,edi
254 lea edx,_getApi;将公有函数_getApi的地址传给edx，全局变量，要修正
255 add edx,ebx
256
257 push eax
258 push ecx
259 call edx
260 mov _getProcAddress,eax
```

------

==凡是全局变量（包含公用函数地址）均需要加ebx进行修正==，==局部变量（在栈中，如函数传递的参数，函数内部定义的变量等）则可以直接使用==。

以上简单描述了使用嵌入补丁通用框架编程时需要注意的几个问题，下面来看通用补丁程序框架的字节码。

## 13.3.3　嵌入补丁字节码实例分析

以下为HelloWorldPE补丁的字节码内容：

![image](https://github.com/YangLuchao/img_host/raw/master/20231018/image.5dzkqrsxm500.jpg)

如上所示，==字节码开始和结束都是跳转指令，前一个跳转指令跳转到该数据块的起始代码处运行，后一个跳转指令跳转到目标程序的入口地址处执行==。

整个数据块具备良好的可移植性，通过下面的测试即可看出这一点。

测试目标定位为PEInfo.exe。将补丁字节码覆盖PEInfo入口地址（文件偏移0xF5F）开始的指令字节码，然后运行PEInfo.exe。你会发现PEInfo整个变成了HelloWorldPE程序。

对系统程序的测试如对记事本程序notepad.exe（文件偏移0x679d）的测试效果也是一样的，测试用的文件在随书文件的chapter13\c目录中。

# 13.4　万能补丁码

本节介绍一种基于嵌入补丁技术的万能补丁码，相关文件在随书文件chapter13\d目录中。

## 13.4.1　原理

==当一个进程动态加载外部DLL文件时，除了将DLL内容映射到内存外，还会执行DLL的入口函数==；==而动态加载DLL的API函数是`kernel32.dll`中的`LoadLibraryX`系列函数==。==所以，补丁代码需要做的工作就是找到内存中的`kernel32.dll`的基地址，然后查找其导出表获取`LoadLibraryA`的`VA`，该地址在该系统下肯定是可用的==。==执行该函数，加载特定的DLL程序（在万能补丁码的例子中为pa.dll），这个DLL的入口函数中存放着补丁代码==。==万能补丁码就是通过这种原理实现的一种补丁技术。因为其小巧，可移植性强，所以可用性比较高==，图13-8展示了万能补丁工作原理。

==补丁代码-1负责嵌入目标PE文件内部，执行加载动态链接库pa.dll的任务==。==在执行时会首先调用pa.dll的入口函数==。==在pa.dll的入口函数中，嵌入真正要打的补丁是补丁代码-2，通过这样一种传递方式，使得补丁程序可以脱离开目标PE文件而获得执行==。==这样生产的补丁代码具有更大的扩展空间，所以称为万能补丁码==。下面介绍万能补丁码的源代码。

![image](https://github.com/YangLuchao/img_host/raw/master/20231018/image.77rxigd12tc0.jpg)

图　13-8　万能补丁工作原理示意图

## 13.4.2　源代码

代码清单13-6为万能补丁的源代码。

代码清单13-6　万能补丁源代码（chapter13\d\getLoadLib.asm）

------

```assembly
;------------------------
; 万能补丁码
; 获取LoadLibraryA的函数地址并调用
; 
; 00000245      00001d7b      LoadLibraryA

; 戚利
; 2011.2.22
;------------------------
    .386
    .model flat,stdcall
    option casemap:none

include    windows.inc
include    user32.inc
includelib user32.lib
include    kernel32.inc
includelib kernel32.lib

;数据段
    .data

szText  db 'LoadLibrary的函数地址为： %08x',0
szOut   db '%08x',0dh,0ah,0
szBuffer db 256 dup(0)

;代码段
    .code

start:
   mov edi,edi
   call loc0
   db 'LoadLibraryA',0  ;特征函数名
   db 'pa',0            ;动态链接库pa.dll
loc0:
   pop edx            ;edx中存放了特征函数名所在地址
   push edx

   push edx

   assume fs:nothing
   mov eax,fs:[30h] ;获取PEB所在地址
   mov eax,[eax+0ch] ;获取PEB_LDR_DATA 结构指针
   mov esi,[eax+1ch] ;获取InInitializationOrderModuleList 链表头
                     ;第一个LDR_MODULE节点InInitializationOrderModuleList成员的指针
   lodsd             ;获取双向链表当前节点后继的指针
   mov ebx,[eax+8]   ;获取kernel32.dll的基地址


loc2:   ;遍历导出表
   mov esi,dword ptr [ebx+3ch] 
   add esi,ebx ;ESI指向PE头
   mov esi,dword ptr [esi+78h]
   add esi,ebx ;ESI指向数据目录中的导出表
   mov edi,dword ptr [esi+20h] ;指向导出表的AddressOfNames
   add edi,ebx ;EDI为AddressOfNames数组起始位置
   mov ecx,dword ptr [esi+14h] ;指向导出表的NumberOfNames

   push esi
   xor eax,eax

loc3:
   push edi
   push ecx
   mov edi,dword ptr [edi]
   add edi,ebx  ;edi指向了第一个函数的字符串名起始
   mov esi,edx  ;esi指向了特征函数名起始
   xor ecx,ecx
   mov cl,0ch   ;特征函数名的长度
   repe cmpsb
   je loc4    ;找到特征函数，转移

   pop ecx
   pop edi
   add edi,4  ;edi移动到下一个函数名所在地址
   inc eax    ;eax为索引
   loop loc3
loc4:
   pop ecx
   pop edi
   pop esi ;ESI指向数据目录中的导出表   
   mov edi,dword ptr [esi+24h] ;指向导出表的Name索引
   add edi,ebx ;EDI为AddressOfNamesOrdinals数组起始位置

   ;计算eax处的值
   sal eax,1   ;eax中存放了指定索引距离数组的偏移
   add edi,eax
   mov ax,word ptr [edi]  ;又是一个索引
   mov edi,dword ptr [esi+1ch]  ;AddressOfFunctions
   add edi,ebx   
   
   sal eax,2
   add edi,eax
   mov eax,dword ptr [edi]
   add eax,ebx

   ;edx指向patch.dll
   ;加载dll，引发对补丁的调用
   pop edx
   add edx,0dh 
   push edx
   call eax
   ;跳转
   db 0E9h,0FFh,0FFh,0FFh,0FFh
   end start

```

------

行28～34是==通过`PEB`获取`kernel32.dll`基地址==。

行37～82是==获取`LoadLibraryA`的函数VA==。

行84～89是==调用`LoadLibraryA`函数，动态引入动态链接库`pa.dll`==。

行90～91是==跳转到入口地址执行，该部分代码也可以使用`FF 25`无条件跳转指令==。

## 13.4.3　字节码

使用FlexHex打开最终生成的getLoadLib.exe，将代码段的字节码复制出来如下所示。该代码在源代码中已有比较详尽的描述，经过特意调整动态链接库的名称为"pa"，即"patch.dll"的意思。==调整后的大小为80h，即128个字节，这个尺寸要比最小的弹出对话框的PE（133字节）还要小，但它实现的功能却超出你的想象==！

![image](https://github.com/YangLuchao/img_host/raw/master/20231018/image.5nel5rg5ft80.jpg)

## 13.4.4　运行测试

下面使用记事本程序进行测试。将以上代码复制到记事本程序的文件偏移`00007b48`处，然后修改`E9 FF FF FF FF`为`E9 D5 EB FF FF`。

将记事本入口点（位于文件偏移`0x00000108`处）由原来的`0000739D`更改为`00008748`。运行记事本程序查看运行效果。

可以看到，在运行记事本前先弹出了对话框。

# 13.5　小结

本章主要描述了对PE进程和PE文件进行补丁的不同方法，==即动态补丁和静态补丁==。==重点对静态补丁中的基于PE文件的嵌入补丁技术进行了描述，内容包括补丁程序框架、补丁编写规则等==。此外，还为读者描述了一种基于嵌入补丁技术的万能补丁码。

后续四章将分别介绍对PE文件实施嵌入补丁的四种不同方法，因此，熟练掌握本章的内容是学习后续章节的基础。